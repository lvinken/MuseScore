// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "musicxml.hxx"

namespace musicxml
{
  // above_below
  // 

  above_below::
  above_below (value v)
  : ::xml_schema::token (_xsd_above_below_literals_[v])
  {
  }

  above_below::
  above_below (const char* v)
  : ::xml_schema::token (v)
  {
  }

  above_below::
  above_below (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  above_below::
  above_below (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  above_below::
  above_below (const above_below& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  above_below& above_below::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_above_below_literals_[v]);

    return *this;
  }


  // beam_level
  // 


  // color
  // 


  // comma_separated_text
  // 


  // css_font_size
  // 

  css_font_size::
  css_font_size (value v)
  : ::xml_schema::token (_xsd_css_font_size_literals_[v])
  {
  }

  css_font_size::
  css_font_size (const char* v)
  : ::xml_schema::token (v)
  {
  }

  css_font_size::
  css_font_size (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  css_font_size::
  css_font_size (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  css_font_size::
  css_font_size (const css_font_size& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  css_font_size& css_font_size::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_css_font_size_literals_[v]);

    return *this;
  }


  // divisions
  // 


  // enclosure_shape
  // 

  enclosure_shape::
  enclosure_shape (value v)
  : ::xml_schema::token (_xsd_enclosure_shape_literals_[v])
  {
  }

  enclosure_shape::
  enclosure_shape (const char* v)
  : ::xml_schema::token (v)
  {
  }

  enclosure_shape::
  enclosure_shape (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  enclosure_shape::
  enclosure_shape (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  enclosure_shape::
  enclosure_shape (const enclosure_shape& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  enclosure_shape& enclosure_shape::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_enclosure_shape_literals_[v]);

    return *this;
  }


  // fermata_shape
  // 

  fermata_shape::
  fermata_shape (value v)
  : ::xml_schema::string (_xsd_fermata_shape_literals_[v])
  {
  }

  fermata_shape::
  fermata_shape (const char* v)
  : ::xml_schema::string (v)
  {
  }

  fermata_shape::
  fermata_shape (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  fermata_shape::
  fermata_shape (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  fermata_shape::
  fermata_shape (const fermata_shape& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  fermata_shape& fermata_shape::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_fermata_shape_literals_[v]);

    return *this;
  }


  // font_family
  // 


  // font_size
  //

  font_size::
  font_size (const char* s)
  : ::xml_schema::string (s)
  {
  }

  font_size::
  font_size (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  font_size::
  font_size (const font_size& o,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // font_style
  // 

  font_style::
  font_style (value v)
  : ::xml_schema::token (_xsd_font_style_literals_[v])
  {
  }

  font_style::
  font_style (const char* v)
  : ::xml_schema::token (v)
  {
  }

  font_style::
  font_style (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  font_style::
  font_style (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  font_style::
  font_style (const font_style& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  font_style& font_style::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_font_style_literals_[v]);

    return *this;
  }


  // font_weight
  // 

  font_weight::
  font_weight (value v)
  : ::xml_schema::token (_xsd_font_weight_literals_[v])
  {
  }

  font_weight::
  font_weight (const char* v)
  : ::xml_schema::token (v)
  {
  }

  font_weight::
  font_weight (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  font_weight::
  font_weight (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  font_weight::
  font_weight (const font_weight& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  font_weight& font_weight::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_font_weight_literals_[v]);

    return *this;
  }


  // left_center_right
  // 

  left_center_right::
  left_center_right (value v)
  : ::xml_schema::token (_xsd_left_center_right_literals_[v])
  {
  }

  left_center_right::
  left_center_right (const char* v)
  : ::xml_schema::token (v)
  {
  }

  left_center_right::
  left_center_right (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  left_center_right::
  left_center_right (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  left_center_right::
  left_center_right (const left_center_right& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  left_center_right& left_center_right::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_left_center_right_literals_[v]);

    return *this;
  }


  // left_right
  // 

  left_right::
  left_right (value v)
  : ::xml_schema::token (_xsd_left_right_literals_[v])
  {
  }

  left_right::
  left_right (const char* v)
  : ::xml_schema::token (v)
  {
  }

  left_right::
  left_right (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  left_right::
  left_right (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  left_right::
  left_right (const left_right& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  left_right& left_right::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_left_right_literals_[v]);

    return *this;
  }


  // line_length
  // 

  line_length::
  line_length (value v)
  : ::xml_schema::token (_xsd_line_length_literals_[v])
  {
  }

  line_length::
  line_length (const char* v)
  : ::xml_schema::token (v)
  {
  }

  line_length::
  line_length (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  line_length::
  line_length (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  line_length::
  line_length (const line_length& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  line_length& line_length::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_line_length_literals_[v]);

    return *this;
  }


  // line_shape
  // 

  line_shape::
  line_shape (value v)
  : ::xml_schema::token (_xsd_line_shape_literals_[v])
  {
  }

  line_shape::
  line_shape (const char* v)
  : ::xml_schema::token (v)
  {
  }

  line_shape::
  line_shape (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  line_shape::
  line_shape (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  line_shape::
  line_shape (const line_shape& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  line_shape& line_shape::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_line_shape_literals_[v]);

    return *this;
  }


  // line_type
  // 

  line_type::
  line_type (value v)
  : ::xml_schema::token (_xsd_line_type_literals_[v])
  {
  }

  line_type::
  line_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  line_type::
  line_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  line_type::
  line_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  line_type::
  line_type (const line_type& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  line_type& line_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_line_type_literals_[v]);

    return *this;
  }


  // midi_16
  // 


  // midi_128
  // 


  // midi_16384
  // 


  // mute
  // 

  mute::
  mute (value v)
  : ::xml_schema::string (_xsd_mute_literals_[v])
  {
  }

  mute::
  mute (const char* v)
  : ::xml_schema::string (v)
  {
  }

  mute::
  mute (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  mute::
  mute (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  mute::
  mute (const mute& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  mute& mute::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_mute_literals_[v]);

    return *this;
  }


  // non_negative_decimal
  // 


  // number_level
  // 


  // number_of_lines
  // 


  // number_or_normal
  //

  number_or_normal::
  number_or_normal (const char* s)
  : ::xml_schema::string (s)
  {
  }

  number_or_normal::
  number_or_normal (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  number_or_normal::
  number_or_normal (const number_or_normal& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // numeral_value
  // 


  // over_under
  // 

  over_under::
  over_under (value v)
  : ::xml_schema::token (_xsd_over_under_literals_[v])
  {
  }

  over_under::
  over_under (const char* v)
  : ::xml_schema::token (v)
  {
  }

  over_under::
  over_under (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  over_under::
  over_under (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  over_under::
  over_under (const over_under& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  over_under& over_under::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_over_under_literals_[v]);

    return *this;
  }


  // percent
  // 


  // positive_decimal
  // 


  // positive_divisions
  // 


  // positive_integer_or_empty
  //

  positive_integer_or_empty::
  positive_integer_or_empty (const char* s)
  : ::xml_schema::string (s)
  {
  }

  positive_integer_or_empty::
  positive_integer_or_empty (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  positive_integer_or_empty::
  positive_integer_or_empty (const positive_integer_or_empty& o,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // rotation_degrees
  // 


  // semi_pitched
  // 

  semi_pitched::
  semi_pitched (value v)
  : ::xml_schema::string (_xsd_semi_pitched_literals_[v])
  {
  }

  semi_pitched::
  semi_pitched (const char* v)
  : ::xml_schema::string (v)
  {
  }

  semi_pitched::
  semi_pitched (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  semi_pitched::
  semi_pitched (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  semi_pitched::
  semi_pitched (const semi_pitched& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  semi_pitched& semi_pitched::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_semi_pitched_literals_[v]);

    return *this;
  }


  // smufl_glyph_name
  // 


  // smufl_accidental_glyph_name
  // 


  // smufl_coda_glyph_name
  // 


  // smufl_lyrics_glyph_name
  // 


  // smufl_pictogram_glyph_name
  // 


  // smufl_segno_glyph_name
  // 


  // smufl_wavy_line_glyph_name
  // 


  // start_note
  // 

  start_note::
  start_note (value v)
  : ::xml_schema::token (_xsd_start_note_literals_[v])
  {
  }

  start_note::
  start_note (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_note::
  start_note (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_note::
  start_note (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_note::
  start_note (const start_note& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_note& start_note::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_note_literals_[v]);

    return *this;
  }


  // start_stop
  // 

  start_stop::
  start_stop (value v)
  : ::xml_schema::token (_xsd_start_stop_literals_[v])
  {
  }

  start_stop::
  start_stop (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_stop::
  start_stop (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop::
  start_stop (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop::
  start_stop (const start_stop& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_stop& start_stop::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_stop_literals_[v]);

    return *this;
  }


  // start_stop_continue
  // 

  start_stop_continue::
  start_stop_continue (value v)
  : ::xml_schema::token (_xsd_start_stop_continue_literals_[v])
  {
  }

  start_stop_continue::
  start_stop_continue (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_continue::
  start_stop_continue (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_continue::
  start_stop_continue (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_continue::
  start_stop_continue (const start_stop_continue& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_stop_continue& start_stop_continue::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_stop_continue_literals_[v]);

    return *this;
  }


  // start_stop_single
  // 

  start_stop_single::
  start_stop_single (value v)
  : ::xml_schema::token (_xsd_start_stop_single_literals_[v])
  {
  }

  start_stop_single::
  start_stop_single (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_single::
  start_stop_single (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_single::
  start_stop_single (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_single::
  start_stop_single (const start_stop_single& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_stop_single& start_stop_single::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_stop_single_literals_[v]);

    return *this;
  }


  // string_number
  // 


  // symbol_size
  // 

  symbol_size::
  symbol_size (value v)
  : ::xml_schema::token (_xsd_symbol_size_literals_[v])
  {
  }

  symbol_size::
  symbol_size (const char* v)
  : ::xml_schema::token (v)
  {
  }

  symbol_size::
  symbol_size (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  symbol_size::
  symbol_size (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  symbol_size::
  symbol_size (const symbol_size& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  symbol_size& symbol_size::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_symbol_size_literals_[v]);

    return *this;
  }


  // tenths
  // 


  // text_direction
  // 

  text_direction::
  text_direction (value v)
  : ::xml_schema::token (_xsd_text_direction_literals_[v])
  {
  }

  text_direction::
  text_direction (const char* v)
  : ::xml_schema::token (v)
  {
  }

  text_direction::
  text_direction (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  text_direction::
  text_direction (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  text_direction::
  text_direction (const text_direction& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  text_direction& text_direction::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_text_direction_literals_[v]);

    return *this;
  }


  // tied_type
  // 

  tied_type::
  tied_type (value v)
  : ::xml_schema::token (_xsd_tied_type_literals_[v])
  {
  }

  tied_type::
  tied_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  tied_type::
  tied_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  tied_type::
  tied_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  tied_type::
  tied_type (const tied_type& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  tied_type& tied_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_tied_type_literals_[v]);

    return *this;
  }


  // time_only
  // 


  // top_bottom
  // 

  top_bottom::
  top_bottom (value v)
  : ::xml_schema::token (_xsd_top_bottom_literals_[v])
  {
  }

  top_bottom::
  top_bottom (const char* v)
  : ::xml_schema::token (v)
  {
  }

  top_bottom::
  top_bottom (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  top_bottom::
  top_bottom (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  top_bottom::
  top_bottom (const top_bottom& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  top_bottom& top_bottom::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_top_bottom_literals_[v]);

    return *this;
  }


  // tremolo_type
  // 

  tremolo_type::
  tremolo_type (value v)
  : ::xml_schema::token (_xsd_tremolo_type_literals_[v])
  {
  }

  tremolo_type::
  tremolo_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  tremolo_type::
  tremolo_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  tremolo_type::
  tremolo_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  tremolo_type::
  tremolo_type (const tremolo_type& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  tremolo_type& tremolo_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_tremolo_type_literals_[v]);

    return *this;
  }


  // trill_beats
  // 


  // trill_step
  // 

  trill_step::
  trill_step (value v)
  : ::xml_schema::token (_xsd_trill_step_literals_[v])
  {
  }

  trill_step::
  trill_step (const char* v)
  : ::xml_schema::token (v)
  {
  }

  trill_step::
  trill_step (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  trill_step::
  trill_step (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  trill_step::
  trill_step (const trill_step& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  trill_step& trill_step::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_trill_step_literals_[v]);

    return *this;
  }


  // two_note_turn
  // 

  two_note_turn::
  two_note_turn (value v)
  : ::xml_schema::token (_xsd_two_note_turn_literals_[v])
  {
  }

  two_note_turn::
  two_note_turn (const char* v)
  : ::xml_schema::token (v)
  {
  }

  two_note_turn::
  two_note_turn (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  two_note_turn::
  two_note_turn (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  two_note_turn::
  two_note_turn (const two_note_turn& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  two_note_turn& two_note_turn::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_two_note_turn_literals_[v]);

    return *this;
  }


  // up_down
  // 

  up_down::
  up_down (value v)
  : ::xml_schema::token (_xsd_up_down_literals_[v])
  {
  }

  up_down::
  up_down (const char* v)
  : ::xml_schema::token (v)
  {
  }

  up_down::
  up_down (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  up_down::
  up_down (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  up_down::
  up_down (const up_down& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  up_down& up_down::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_up_down_literals_[v]);

    return *this;
  }


  // upright_inverted
  // 

  upright_inverted::
  upright_inverted (value v)
  : ::xml_schema::token (_xsd_upright_inverted_literals_[v])
  {
  }

  upright_inverted::
  upright_inverted (const char* v)
  : ::xml_schema::token (v)
  {
  }

  upright_inverted::
  upright_inverted (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  upright_inverted::
  upright_inverted (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  upright_inverted::
  upright_inverted (const upright_inverted& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  upright_inverted& upright_inverted::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_upright_inverted_literals_[v]);

    return *this;
  }


  // valign
  // 

  valign::
  valign (value v)
  : ::xml_schema::token (_xsd_valign_literals_[v])
  {
  }

  valign::
  valign (const char* v)
  : ::xml_schema::token (v)
  {
  }

  valign::
  valign (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  valign::
  valign (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  valign::
  valign (const valign& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  valign& valign::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_valign_literals_[v]);

    return *this;
  }


  // valign_image
  // 

  valign_image::
  valign_image (value v)
  : ::xml_schema::token (_xsd_valign_image_literals_[v])
  {
  }

  valign_image::
  valign_image (const char* v)
  : ::xml_schema::token (v)
  {
  }

  valign_image::
  valign_image (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  valign_image::
  valign_image (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  valign_image::
  valign_image (const valign_image& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  valign_image& valign_image::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_valign_image_literals_[v]);

    return *this;
  }


  // yes_no
  // 

  yes_no::
  yes_no (value v)
  : ::xml_schema::token (_xsd_yes_no_literals_[v])
  {
  }

  yes_no::
  yes_no (const char* v)
  : ::xml_schema::token (v)
  {
  }

  yes_no::
  yes_no (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  yes_no::
  yes_no (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  yes_no::
  yes_no (const yes_no& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  yes_no& yes_no::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_yes_no_literals_[v]);

    return *this;
  }


  // yes_no_number
  //

  yes_no_number::
  yes_no_number (const char* s)
  : ::xml_schema::string (s)
  {
  }

  yes_no_number::
  yes_no_number (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  yes_no_number::
  yes_no_number (const yes_no_number& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // yyyy_mm_dd
  // 


  // cancel_location
  // 

  cancel_location::
  cancel_location (value v)
  : ::xml_schema::string (_xsd_cancel_location_literals_[v])
  {
  }

  cancel_location::
  cancel_location (const char* v)
  : ::xml_schema::string (v)
  {
  }

  cancel_location::
  cancel_location (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  cancel_location::
  cancel_location (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  cancel_location::
  cancel_location (const cancel_location& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  cancel_location& cancel_location::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_cancel_location_literals_[v]);

    return *this;
  }


  // clef_sign
  // 

  clef_sign::
  clef_sign (value v)
  : ::xml_schema::string (_xsd_clef_sign_literals_[v])
  {
  }

  clef_sign::
  clef_sign (const char* v)
  : ::xml_schema::string (v)
  {
  }

  clef_sign::
  clef_sign (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  clef_sign::
  clef_sign (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  clef_sign::
  clef_sign (const clef_sign& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  clef_sign& clef_sign::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_clef_sign_literals_[v]);

    return *this;
  }


  // fifths
  // 


  // mode
  // 


  // show_frets
  // 

  show_frets::
  show_frets (value v)
  : ::xml_schema::token (_xsd_show_frets_literals_[v])
  {
  }

  show_frets::
  show_frets (const char* v)
  : ::xml_schema::token (v)
  {
  }

  show_frets::
  show_frets (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  show_frets::
  show_frets (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  show_frets::
  show_frets (const show_frets& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  show_frets& show_frets::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_show_frets_literals_[v]);

    return *this;
  }


  // staff_line
  // 


  // staff_line_position
  // 


  // staff_number
  // 


  // staff_type
  // 

  staff_type::
  staff_type (value v)
  : ::xml_schema::string (_xsd_staff_type_literals_[v])
  {
  }

  staff_type::
  staff_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  staff_type::
  staff_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  staff_type::
  staff_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  staff_type::
  staff_type (const staff_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  staff_type& staff_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_staff_type_literals_[v]);

    return *this;
  }


  // time_relation
  // 

  time_relation::
  time_relation (value v)
  : ::xml_schema::string (_xsd_time_relation_literals_[v])
  {
  }

  time_relation::
  time_relation (const char* v)
  : ::xml_schema::string (v)
  {
  }

  time_relation::
  time_relation (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  time_relation::
  time_relation (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  time_relation::
  time_relation (const time_relation& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  time_relation& time_relation::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_time_relation_literals_[v]);

    return *this;
  }


  // time_separator
  // 

  time_separator::
  time_separator (value v)
  : ::xml_schema::token (_xsd_time_separator_literals_[v])
  {
  }

  time_separator::
  time_separator (const char* v)
  : ::xml_schema::token (v)
  {
  }

  time_separator::
  time_separator (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  time_separator::
  time_separator (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  time_separator::
  time_separator (const time_separator& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  time_separator& time_separator::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_time_separator_literals_[v]);

    return *this;
  }


  // time_symbol
  // 

  time_symbol::
  time_symbol (value v)
  : ::xml_schema::token (_xsd_time_symbol_literals_[v])
  {
  }

  time_symbol::
  time_symbol (const char* v)
  : ::xml_schema::token (v)
  {
  }

  time_symbol::
  time_symbol (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  time_symbol::
  time_symbol (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  time_symbol::
  time_symbol (const time_symbol& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  time_symbol& time_symbol::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_time_symbol_literals_[v]);

    return *this;
  }


  // backward_forward
  // 

  backward_forward::
  backward_forward (value v)
  : ::xml_schema::token (_xsd_backward_forward_literals_[v])
  {
  }

  backward_forward::
  backward_forward (const char* v)
  : ::xml_schema::token (v)
  {
  }

  backward_forward::
  backward_forward (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  backward_forward::
  backward_forward (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  backward_forward::
  backward_forward (const backward_forward& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  backward_forward& backward_forward::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_backward_forward_literals_[v]);

    return *this;
  }


  // bar_style
  // 

  bar_style::
  bar_style (value v)
  : ::xml_schema::string (_xsd_bar_style_literals_[v])
  {
  }

  bar_style::
  bar_style (const char* v)
  : ::xml_schema::string (v)
  {
  }

  bar_style::
  bar_style (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  bar_style::
  bar_style (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  bar_style::
  bar_style (const bar_style& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  bar_style& bar_style::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_bar_style_literals_[v]);

    return *this;
  }


  // ending_number
  // 


  // right_left_middle
  // 

  right_left_middle::
  right_left_middle (value v)
  : ::xml_schema::token (_xsd_right_left_middle_literals_[v])
  {
  }

  right_left_middle::
  right_left_middle (const char* v)
  : ::xml_schema::token (v)
  {
  }

  right_left_middle::
  right_left_middle (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  right_left_middle::
  right_left_middle (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  right_left_middle::
  right_left_middle (const right_left_middle& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  right_left_middle& right_left_middle::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_right_left_middle_literals_[v]);

    return *this;
  }


  // start_stop_discontinue
  // 

  start_stop_discontinue::
  start_stop_discontinue (value v)
  : ::xml_schema::token (_xsd_start_stop_discontinue_literals_[v])
  {
  }

  start_stop_discontinue::
  start_stop_discontinue (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_discontinue::
  start_stop_discontinue (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_discontinue::
  start_stop_discontinue (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_discontinue::
  start_stop_discontinue (const start_stop_discontinue& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_stop_discontinue& start_stop_discontinue::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_stop_discontinue_literals_[v]);

    return *this;
  }


  // winged
  // 

  winged::
  winged (value v)
  : ::xml_schema::token (_xsd_winged_literals_[v])
  {
  }

  winged::
  winged (const char* v)
  : ::xml_schema::token (v)
  {
  }

  winged::
  winged (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  winged::
  winged (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  winged::
  winged (const winged& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  winged& winged::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_winged_literals_[v]);

    return *this;
  }


  // accordion_middle
  // 


  // beater_value
  // 

  beater_value::
  beater_value (value v)
  : ::xml_schema::string (_xsd_beater_value_literals_[v])
  {
  }

  beater_value::
  beater_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  beater_value::
  beater_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  beater_value::
  beater_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  beater_value::
  beater_value (const beater_value& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  beater_value& beater_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_beater_value_literals_[v]);

    return *this;
  }


  // degree_symbol_value
  // 

  degree_symbol_value::
  degree_symbol_value (value v)
  : ::xml_schema::token (_xsd_degree_symbol_value_literals_[v])
  {
  }

  degree_symbol_value::
  degree_symbol_value (const char* v)
  : ::xml_schema::token (v)
  {
  }

  degree_symbol_value::
  degree_symbol_value (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  degree_symbol_value::
  degree_symbol_value (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  degree_symbol_value::
  degree_symbol_value (const degree_symbol_value& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  degree_symbol_value& degree_symbol_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_degree_symbol_value_literals_[v]);

    return *this;
  }


  // degree_type_value
  // 

  degree_type_value::
  degree_type_value (value v)
  : ::xml_schema::string (_xsd_degree_type_value_literals_[v])
  {
  }

  degree_type_value::
  degree_type_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  degree_type_value::
  degree_type_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  degree_type_value::
  degree_type_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  degree_type_value::
  degree_type_value (const degree_type_value& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  degree_type_value& degree_type_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_degree_type_value_literals_[v]);

    return *this;
  }


  // effect_value
  // 

  effect_value::
  effect_value (value v)
  : ::xml_schema::string (_xsd_effect_value_literals_[v])
  {
  }

  effect_value::
  effect_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  effect_value::
  effect_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  effect_value::
  effect_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  effect_value::
  effect_value (const effect_value& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  effect_value& effect_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_effect_value_literals_[v]);

    return *this;
  }


  // glass_value
  // 

  glass_value::
  glass_value (value v)
  : ::xml_schema::string (_xsd_glass_value_literals_[v])
  {
  }

  glass_value::
  glass_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  glass_value::
  glass_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  glass_value::
  glass_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  glass_value::
  glass_value (const glass_value& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  glass_value& glass_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_glass_value_literals_[v]);

    return *this;
  }


  // harmony_arrangement
  // 

  harmony_arrangement::
  harmony_arrangement (value v)
  : ::xml_schema::token (_xsd_harmony_arrangement_literals_[v])
  {
  }

  harmony_arrangement::
  harmony_arrangement (const char* v)
  : ::xml_schema::token (v)
  {
  }

  harmony_arrangement::
  harmony_arrangement (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  harmony_arrangement::
  harmony_arrangement (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  harmony_arrangement::
  harmony_arrangement (const harmony_arrangement& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  harmony_arrangement& harmony_arrangement::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_harmony_arrangement_literals_[v]);

    return *this;
  }


  // harmony_type
  // 

  harmony_type::
  harmony_type (value v)
  : ::xml_schema::token (_xsd_harmony_type_literals_[v])
  {
  }

  harmony_type::
  harmony_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  harmony_type::
  harmony_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  harmony_type::
  harmony_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  harmony_type::
  harmony_type (const harmony_type& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  harmony_type& harmony_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_harmony_type_literals_[v]);

    return *this;
  }


  // kind_value
  // 

  kind_value::
  kind_value (value v)
  : ::xml_schema::string (_xsd_kind_value_literals_[v])
  {
  }

  kind_value::
  kind_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  kind_value::
  kind_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  kind_value::
  kind_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  kind_value::
  kind_value (const kind_value& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  kind_value& kind_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_kind_value_literals_[v]);

    return *this;
  }


  // line_end
  // 

  line_end::
  line_end (value v)
  : ::xml_schema::token (_xsd_line_end_literals_[v])
  {
  }

  line_end::
  line_end (const char* v)
  : ::xml_schema::token (v)
  {
  }

  line_end::
  line_end (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  line_end::
  line_end (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  line_end::
  line_end (const line_end& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  line_end& line_end::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_line_end_literals_[v]);

    return *this;
  }


  // measure_numbering_value
  // 

  measure_numbering_value::
  measure_numbering_value (value v)
  : ::xml_schema::token (_xsd_measure_numbering_value_literals_[v])
  {
  }

  measure_numbering_value::
  measure_numbering_value (const char* v)
  : ::xml_schema::token (v)
  {
  }

  measure_numbering_value::
  measure_numbering_value (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  measure_numbering_value::
  measure_numbering_value (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  measure_numbering_value::
  measure_numbering_value (const measure_numbering_value& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  measure_numbering_value& measure_numbering_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_measure_numbering_value_literals_[v]);

    return *this;
  }


  // membrane_value
  // 

  membrane_value::
  membrane_value (value v)
  : ::xml_schema::string (_xsd_membrane_value_literals_[v])
  {
  }

  membrane_value::
  membrane_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  membrane_value::
  membrane_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  membrane_value::
  membrane_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  membrane_value::
  membrane_value (const membrane_value& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  membrane_value& membrane_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_membrane_value_literals_[v]);

    return *this;
  }


  // metal_value
  // 

  metal_value::
  metal_value (value v)
  : ::xml_schema::string (_xsd_metal_value_literals_[v])
  {
  }

  metal_value::
  metal_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  metal_value::
  metal_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  metal_value::
  metal_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  metal_value::
  metal_value (const metal_value& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  metal_value& metal_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_metal_value_literals_[v]);

    return *this;
  }


  // milliseconds
  // 


  // numeral_mode
  // 

  numeral_mode::
  numeral_mode (value v)
  : ::xml_schema::string (_xsd_numeral_mode_literals_[v])
  {
  }

  numeral_mode::
  numeral_mode (const char* v)
  : ::xml_schema::string (v)
  {
  }

  numeral_mode::
  numeral_mode (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  numeral_mode::
  numeral_mode (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  numeral_mode::
  numeral_mode (const numeral_mode& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  numeral_mode& numeral_mode::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_numeral_mode_literals_[v]);

    return *this;
  }


  // on_off
  // 

  on_off::
  on_off (value v)
  : ::xml_schema::token (_xsd_on_off_literals_[v])
  {
  }

  on_off::
  on_off (const char* v)
  : ::xml_schema::token (v)
  {
  }

  on_off::
  on_off (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  on_off::
  on_off (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  on_off::
  on_off (const on_off& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  on_off& on_off::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_on_off_literals_[v]);

    return *this;
  }


  // pedal_type
  // 

  pedal_type::
  pedal_type (value v)
  : ::xml_schema::token (_xsd_pedal_type_literals_[v])
  {
  }

  pedal_type::
  pedal_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  pedal_type::
  pedal_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  pedal_type::
  pedal_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  pedal_type::
  pedal_type (const pedal_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  pedal_type& pedal_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_pedal_type_literals_[v]);

    return *this;
  }


  // pitched_value
  // 

  pitched_value::
  pitched_value (value v)
  : ::xml_schema::string (_xsd_pitched_value_literals_[v])
  {
  }

  pitched_value::
  pitched_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  pitched_value::
  pitched_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  pitched_value::
  pitched_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  pitched_value::
  pitched_value (const pitched_value& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  pitched_value& pitched_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_pitched_value_literals_[v]);

    return *this;
  }


  // principal_voice_symbol
  // 

  principal_voice_symbol::
  principal_voice_symbol (value v)
  : ::xml_schema::string (_xsd_principal_voice_symbol_literals_[v])
  {
  }

  principal_voice_symbol::
  principal_voice_symbol (const char* v)
  : ::xml_schema::string (v)
  {
  }

  principal_voice_symbol::
  principal_voice_symbol (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  principal_voice_symbol::
  principal_voice_symbol (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  principal_voice_symbol::
  principal_voice_symbol (const principal_voice_symbol& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  principal_voice_symbol& principal_voice_symbol::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_principal_voice_symbol_literals_[v]);

    return *this;
  }


  // staff_divide_symbol
  // 

  staff_divide_symbol::
  staff_divide_symbol (value v)
  : ::xml_schema::token (_xsd_staff_divide_symbol_literals_[v])
  {
  }

  staff_divide_symbol::
  staff_divide_symbol (const char* v)
  : ::xml_schema::token (v)
  {
  }

  staff_divide_symbol::
  staff_divide_symbol (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  staff_divide_symbol::
  staff_divide_symbol (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  staff_divide_symbol::
  staff_divide_symbol (const staff_divide_symbol& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  staff_divide_symbol& staff_divide_symbol::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_staff_divide_symbol_literals_[v]);

    return *this;
  }


  // start_stop_change_continue
  // 

  start_stop_change_continue::
  start_stop_change_continue (value v)
  : ::xml_schema::token (_xsd_start_stop_change_continue_literals_[v])
  {
  }

  start_stop_change_continue::
  start_stop_change_continue (const char* v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_change_continue::
  start_stop_change_continue (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_change_continue::
  start_stop_change_continue (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  start_stop_change_continue::
  start_stop_change_continue (const start_stop_change_continue& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  start_stop_change_continue& start_stop_change_continue::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_start_stop_change_continue_literals_[v]);

    return *this;
  }


  // sync_type
  // 

  sync_type::
  sync_type (value v)
  : ::xml_schema::token (_xsd_sync_type_literals_[v])
  {
  }

  sync_type::
  sync_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  sync_type::
  sync_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  sync_type::
  sync_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  sync_type::
  sync_type (const sync_type& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  sync_type& sync_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_sync_type_literals_[v]);

    return *this;
  }


  // system_relation_number
  // 

  system_relation_number::
  system_relation_number (value v)
  : ::xml_schema::string (_xsd_system_relation_number_literals_[v])
  {
  }

  system_relation_number::
  system_relation_number (const char* v)
  : ::xml_schema::string (v)
  {
  }

  system_relation_number::
  system_relation_number (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  system_relation_number::
  system_relation_number (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  system_relation_number::
  system_relation_number (const system_relation_number& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  system_relation_number& system_relation_number::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_system_relation_number_literals_[v]);

    return *this;
  }


  // system_relation
  // 

  system_relation::
  system_relation (value v)
  : ::musicxml::system_relation_number (v)
  {
  }

  system_relation::
  system_relation (const char* v)
  : ::musicxml::system_relation_number (v)
  {
  }

  system_relation::
  system_relation (const ::std::string& v)
  : ::musicxml::system_relation_number (v)
  {
  }

  system_relation::
  system_relation (const ::musicxml::system_relation_number& v)
  : ::musicxml::system_relation_number (v)
  {
  }

  system_relation::
  system_relation (const system_relation& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::system_relation_number (v, f, c)
  {
  }

  system_relation& system_relation::
  operator= (value v)
  {
    static_cast< ::musicxml::system_relation_number& > (*this) = v;

    return *this;
  }


  // tip_direction
  // 

  tip_direction::
  tip_direction (value v)
  : ::xml_schema::string (_xsd_tip_direction_literals_[v])
  {
  }

  tip_direction::
  tip_direction (const char* v)
  : ::xml_schema::string (v)
  {
  }

  tip_direction::
  tip_direction (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  tip_direction::
  tip_direction (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  tip_direction::
  tip_direction (const tip_direction& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  tip_direction& tip_direction::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_tip_direction_literals_[v]);

    return *this;
  }


  // stick_location
  // 

  stick_location::
  stick_location (value v)
  : ::xml_schema::string (_xsd_stick_location_literals_[v])
  {
  }

  stick_location::
  stick_location (const char* v)
  : ::xml_schema::string (v)
  {
  }

  stick_location::
  stick_location (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_location::
  stick_location (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_location::
  stick_location (const stick_location& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  stick_location& stick_location::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_stick_location_literals_[v]);

    return *this;
  }


  // stick_material
  // 

  stick_material::
  stick_material (value v)
  : ::xml_schema::string (_xsd_stick_material_literals_[v])
  {
  }

  stick_material::
  stick_material (const char* v)
  : ::xml_schema::string (v)
  {
  }

  stick_material::
  stick_material (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_material::
  stick_material (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_material::
  stick_material (const stick_material& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  stick_material& stick_material::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_stick_material_literals_[v]);

    return *this;
  }


  // stick_type
  // 

  stick_type::
  stick_type (value v)
  : ::xml_schema::string (_xsd_stick_type_literals_[v])
  {
  }

  stick_type::
  stick_type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  stick_type::
  stick_type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_type::
  stick_type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  stick_type::
  stick_type (const stick_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  stick_type& stick_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_stick_type_literals_[v]);

    return *this;
  }


  // up_down_stop_continue
  // 

  up_down_stop_continue::
  up_down_stop_continue (value v)
  : ::xml_schema::token (_xsd_up_down_stop_continue_literals_[v])
  {
  }

  up_down_stop_continue::
  up_down_stop_continue (const char* v)
  : ::xml_schema::token (v)
  {
  }

  up_down_stop_continue::
  up_down_stop_continue (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  up_down_stop_continue::
  up_down_stop_continue (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  up_down_stop_continue::
  up_down_stop_continue (const up_down_stop_continue& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  up_down_stop_continue& up_down_stop_continue::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_up_down_stop_continue_literals_[v]);

    return *this;
  }


  // wedge_type
  // 

  wedge_type::
  wedge_type (value v)
  : ::xml_schema::token (_xsd_wedge_type_literals_[v])
  {
  }

  wedge_type::
  wedge_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  wedge_type::
  wedge_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  wedge_type::
  wedge_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  wedge_type::
  wedge_type (const wedge_type& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  wedge_type& wedge_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_wedge_type_literals_[v]);

    return *this;
  }


  // wood_value
  // 

  wood_value::
  wood_value (value v)
  : ::xml_schema::string (_xsd_wood_value_literals_[v])
  {
  }

  wood_value::
  wood_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  wood_value::
  wood_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  wood_value::
  wood_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  wood_value::
  wood_value (const wood_value& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  wood_value& wood_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_wood_value_literals_[v]);

    return *this;
  }


  // distance_type
  // 


  // glyph_type
  // 


  // line_width_type
  // 


  // margin_type
  // 

  margin_type::
  margin_type (value v)
  : ::xml_schema::token (_xsd_margin_type_literals_[v])
  {
  }

  margin_type::
  margin_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  margin_type::
  margin_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  margin_type::
  margin_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  margin_type::
  margin_type (const margin_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  margin_type& margin_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_margin_type_literals_[v]);

    return *this;
  }


  // millimeters
  // 


  // note_size_type
  // 

  note_size_type::
  note_size_type (value v)
  : ::xml_schema::token (_xsd_note_size_type_literals_[v])
  {
  }

  note_size_type::
  note_size_type (const char* v)
  : ::xml_schema::token (v)
  {
  }

  note_size_type::
  note_size_type (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  note_size_type::
  note_size_type (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  note_size_type::
  note_size_type (const note_size_type& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  note_size_type& note_size_type::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_note_size_type_literals_[v]);

    return *this;
  }


  // accidental_value
  // 

  accidental_value::
  accidental_value (value v)
  : ::xml_schema::string (_xsd_accidental_value_literals_[v])
  {
  }

  accidental_value::
  accidental_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  accidental_value::
  accidental_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  accidental_value::
  accidental_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  accidental_value::
  accidental_value (const accidental_value& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  accidental_value& accidental_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_accidental_value_literals_[v]);

    return *this;
  }


  // arrow_direction
  // 

  arrow_direction::
  arrow_direction (value v)
  : ::xml_schema::string (_xsd_arrow_direction_literals_[v])
  {
  }

  arrow_direction::
  arrow_direction (const char* v)
  : ::xml_schema::string (v)
  {
  }

  arrow_direction::
  arrow_direction (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  arrow_direction::
  arrow_direction (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  arrow_direction::
  arrow_direction (const arrow_direction& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  arrow_direction& arrow_direction::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_arrow_direction_literals_[v]);

    return *this;
  }


  // arrow_style
  // 

  arrow_style::
  arrow_style (value v)
  : ::xml_schema::string (_xsd_arrow_style_literals_[v])
  {
  }

  arrow_style::
  arrow_style (const char* v)
  : ::xml_schema::string (v)
  {
  }

  arrow_style::
  arrow_style (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  arrow_style::
  arrow_style (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  arrow_style::
  arrow_style (const arrow_style& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  arrow_style& arrow_style::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_arrow_style_literals_[v]);

    return *this;
  }


  // beam_value
  // 

  beam_value::
  beam_value (value v)
  : ::xml_schema::string (_xsd_beam_value_literals_[v])
  {
  }

  beam_value::
  beam_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  beam_value::
  beam_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  beam_value::
  beam_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  beam_value::
  beam_value (const beam_value& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  beam_value& beam_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_beam_value_literals_[v]);

    return *this;
  }


  // bend_shape
  // 

  bend_shape::
  bend_shape (value v)
  : ::xml_schema::string (_xsd_bend_shape_literals_[v])
  {
  }

  bend_shape::
  bend_shape (const char* v)
  : ::xml_schema::string (v)
  {
  }

  bend_shape::
  bend_shape (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  bend_shape::
  bend_shape (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  bend_shape::
  bend_shape (const bend_shape& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  bend_shape& bend_shape::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_bend_shape_literals_[v]);

    return *this;
  }


  // breath_mark_value
  // 

  breath_mark_value::
  breath_mark_value (value v)
  : ::xml_schema::string (_xsd_breath_mark_value_literals_[v])
  {
  }

  breath_mark_value::
  breath_mark_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  breath_mark_value::
  breath_mark_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  breath_mark_value::
  breath_mark_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  breath_mark_value::
  breath_mark_value (const breath_mark_value& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  breath_mark_value& breath_mark_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_breath_mark_value_literals_[v]);

    return *this;
  }


  // caesura_value
  // 

  caesura_value::
  caesura_value (value v)
  : ::xml_schema::string (_xsd_caesura_value_literals_[v])
  {
  }

  caesura_value::
  caesura_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  caesura_value::
  caesura_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  caesura_value::
  caesura_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  caesura_value::
  caesura_value (const caesura_value& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  caesura_value& caesura_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_caesura_value_literals_[v]);

    return *this;
  }


  // circular_arrow
  // 

  circular_arrow::
  circular_arrow (value v)
  : ::xml_schema::string (_xsd_circular_arrow_literals_[v])
  {
  }

  circular_arrow::
  circular_arrow (const char* v)
  : ::xml_schema::string (v)
  {
  }

  circular_arrow::
  circular_arrow (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  circular_arrow::
  circular_arrow (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  circular_arrow::
  circular_arrow (const circular_arrow& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  circular_arrow& circular_arrow::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_circular_arrow_literals_[v]);

    return *this;
  }


  // fan
  // 

  fan::
  fan (value v)
  : ::xml_schema::token (_xsd_fan_literals_[v])
  {
  }

  fan::
  fan (const char* v)
  : ::xml_schema::token (v)
  {
  }

  fan::
  fan (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  fan::
  fan (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  fan::
  fan (const fan& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  fan& fan::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_fan_literals_[v]);

    return *this;
  }


  // handbell_value
  // 

  handbell_value::
  handbell_value (value v)
  : ::xml_schema::string (_xsd_handbell_value_literals_[v])
  {
  }

  handbell_value::
  handbell_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  handbell_value::
  handbell_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  handbell_value::
  handbell_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  handbell_value::
  handbell_value (const handbell_value& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  handbell_value& handbell_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_handbell_value_literals_[v]);

    return *this;
  }


  // harmon_closed_location
  // 

  harmon_closed_location::
  harmon_closed_location (value v)
  : ::xml_schema::string (_xsd_harmon_closed_location_literals_[v])
  {
  }

  harmon_closed_location::
  harmon_closed_location (const char* v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_location::
  harmon_closed_location (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_location::
  harmon_closed_location (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_location::
  harmon_closed_location (const harmon_closed_location& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  harmon_closed_location& harmon_closed_location::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_harmon_closed_location_literals_[v]);

    return *this;
  }


  // harmon_closed_value
  // 

  harmon_closed_value::
  harmon_closed_value (value v)
  : ::xml_schema::string (_xsd_harmon_closed_value_literals_[v])
  {
  }

  harmon_closed_value::
  harmon_closed_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_value::
  harmon_closed_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_value::
  harmon_closed_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  harmon_closed_value::
  harmon_closed_value (const harmon_closed_value& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  harmon_closed_value& harmon_closed_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_harmon_closed_value_literals_[v]);

    return *this;
  }


  // hole_closed_location
  // 

  hole_closed_location::
  hole_closed_location (value v)
  : ::xml_schema::string (_xsd_hole_closed_location_literals_[v])
  {
  }

  hole_closed_location::
  hole_closed_location (const char* v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_location::
  hole_closed_location (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_location::
  hole_closed_location (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_location::
  hole_closed_location (const hole_closed_location& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  hole_closed_location& hole_closed_location::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_hole_closed_location_literals_[v]);

    return *this;
  }


  // hole_closed_value
  // 

  hole_closed_value::
  hole_closed_value (value v)
  : ::xml_schema::string (_xsd_hole_closed_value_literals_[v])
  {
  }

  hole_closed_value::
  hole_closed_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_value::
  hole_closed_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_value::
  hole_closed_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  hole_closed_value::
  hole_closed_value (const hole_closed_value& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  hole_closed_value& hole_closed_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_hole_closed_value_literals_[v]);

    return *this;
  }


  // note_type_value
  // 

  note_type_value::
  note_type_value (value v)
  : ::xml_schema::string (_xsd_note_type_value_literals_[v])
  {
  }

  note_type_value::
  note_type_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  note_type_value::
  note_type_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  note_type_value::
  note_type_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  note_type_value::
  note_type_value (const note_type_value& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  note_type_value& note_type_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_note_type_value_literals_[v]);

    return *this;
  }


  // notehead_value
  // 

  notehead_value::
  notehead_value (value v)
  : ::xml_schema::string (_xsd_notehead_value_literals_[v])
  {
  }

  notehead_value::
  notehead_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  notehead_value::
  notehead_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  notehead_value::
  notehead_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  notehead_value::
  notehead_value (const notehead_value& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  notehead_value& notehead_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_notehead_value_literals_[v]);

    return *this;
  }


  // octave
  // 


  // semitones
  // 


  // show_tuplet
  // 

  show_tuplet::
  show_tuplet (value v)
  : ::xml_schema::token (_xsd_show_tuplet_literals_[v])
  {
  }

  show_tuplet::
  show_tuplet (const char* v)
  : ::xml_schema::token (v)
  {
  }

  show_tuplet::
  show_tuplet (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  show_tuplet::
  show_tuplet (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  show_tuplet::
  show_tuplet (const show_tuplet& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  show_tuplet& show_tuplet::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_show_tuplet_literals_[v]);

    return *this;
  }


  // stem_value
  // 

  stem_value::
  stem_value (value v)
  : ::xml_schema::string (_xsd_stem_value_literals_[v])
  {
  }

  stem_value::
  stem_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  stem_value::
  stem_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  stem_value::
  stem_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  stem_value::
  stem_value (const stem_value& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  stem_value& stem_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_stem_value_literals_[v]);

    return *this;
  }


  // step
  // 

  step::
  step (value v)
  : ::xml_schema::string (_xsd_step_literals_[v])
  {
  }

  step::
  step (const char* v)
  : ::xml_schema::string (v)
  {
  }

  step::
  step (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  step::
  step (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  step::
  step (const step& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  step& step::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_step_literals_[v]);

    return *this;
  }


  // syllabic
  // 

  syllabic::
  syllabic (value v)
  : ::xml_schema::string (_xsd_syllabic_literals_[v])
  {
  }

  syllabic::
  syllabic (const char* v)
  : ::xml_schema::string (v)
  {
  }

  syllabic::
  syllabic (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  syllabic::
  syllabic (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  syllabic::
  syllabic (const syllabic& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  syllabic& syllabic::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_syllabic_literals_[v]);

    return *this;
  }


  // tap_hand
  // 

  tap_hand::
  tap_hand (value v)
  : ::xml_schema::string (_xsd_tap_hand_literals_[v])
  {
  }

  tap_hand::
  tap_hand (const char* v)
  : ::xml_schema::string (v)
  {
  }

  tap_hand::
  tap_hand (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  tap_hand::
  tap_hand (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  tap_hand::
  tap_hand (const tap_hand& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  tap_hand& tap_hand::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_tap_hand_literals_[v]);

    return *this;
  }


  // tremolo_marks
  // 


  // group_barline_value
  // 

  group_barline_value::
  group_barline_value (value v)
  : ::xml_schema::string (_xsd_group_barline_value_literals_[v])
  {
  }

  group_barline_value::
  group_barline_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  group_barline_value::
  group_barline_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  group_barline_value::
  group_barline_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  group_barline_value::
  group_barline_value (const group_barline_value& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  group_barline_value& group_barline_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_group_barline_value_literals_[v]);

    return *this;
  }


  // group_symbol_value
  // 

  group_symbol_value::
  group_symbol_value (value v)
  : ::xml_schema::string (_xsd_group_symbol_value_literals_[v])
  {
  }

  group_symbol_value::
  group_symbol_value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  group_symbol_value::
  group_symbol_value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  group_symbol_value::
  group_symbol_value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  group_symbol_value::
  group_symbol_value (const group_symbol_value& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  group_symbol_value& group_symbol_value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_group_symbol_value_literals_[v]);

    return *this;
  }


  // measure_text
  // 


  // swing_type_value
  // 

  swing_type_value::
  swing_type_value (value v)
  : ::musicxml::note_type_value (v)
  {
  }

  swing_type_value::
  swing_type_value (const char* v)
  : ::musicxml::note_type_value (v)
  {
  }

  swing_type_value::
  swing_type_value (const ::std::string& v)
  : ::musicxml::note_type_value (v)
  {
  }

  swing_type_value::
  swing_type_value (const ::musicxml::note_type_value& v)
  : ::musicxml::note_type_value (v)
  {
  }

  swing_type_value::
  swing_type_value (const swing_type_value& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::note_type_value (v, f, c)
  {
  }

  swing_type_value& swing_type_value::
  operator= (value v)
  {
    static_cast< ::musicxml::note_type_value& > (*this) = v;

    return *this;
  }


  // accidental_text
  // 

  const accidental_text::justify_optional& accidental_text::
  justify () const
  {
    return this->justify_;
  }

  accidental_text::justify_optional& accidental_text::
  justify ()
  {
    return this->justify_;
  }

  void accidental_text::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void accidental_text::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void accidental_text::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const accidental_text::default_x_optional& accidental_text::
  default_x () const
  {
    return this->default_x_;
  }

  accidental_text::default_x_optional& accidental_text::
  default_x ()
  {
    return this->default_x_;
  }

  void accidental_text::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void accidental_text::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void accidental_text::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const accidental_text::default_y_optional& accidental_text::
  default_y () const
  {
    return this->default_y_;
  }

  accidental_text::default_y_optional& accidental_text::
  default_y ()
  {
    return this->default_y_;
  }

  void accidental_text::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void accidental_text::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void accidental_text::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const accidental_text::relative_x_optional& accidental_text::
  relative_x () const
  {
    return this->relative_x_;
  }

  accidental_text::relative_x_optional& accidental_text::
  relative_x ()
  {
    return this->relative_x_;
  }

  void accidental_text::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void accidental_text::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void accidental_text::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const accidental_text::relative_y_optional& accidental_text::
  relative_y () const
  {
    return this->relative_y_;
  }

  accidental_text::relative_y_optional& accidental_text::
  relative_y ()
  {
    return this->relative_y_;
  }

  void accidental_text::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void accidental_text::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void accidental_text::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const accidental_text::font_family_optional& accidental_text::
  font_family () const
  {
    return this->font_family_;
  }

  accidental_text::font_family_optional& accidental_text::
  font_family ()
  {
    return this->font_family_;
  }

  void accidental_text::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void accidental_text::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void accidental_text::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const accidental_text::font_style_optional& accidental_text::
  font_style () const
  {
    return this->font_style_;
  }

  accidental_text::font_style_optional& accidental_text::
  font_style ()
  {
    return this->font_style_;
  }

  void accidental_text::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void accidental_text::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void accidental_text::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const accidental_text::font_size_optional& accidental_text::
  font_size () const
  {
    return this->font_size_;
  }

  accidental_text::font_size_optional& accidental_text::
  font_size ()
  {
    return this->font_size_;
  }

  void accidental_text::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void accidental_text::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void accidental_text::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const accidental_text::font_weight_optional& accidental_text::
  font_weight () const
  {
    return this->font_weight_;
  }

  accidental_text::font_weight_optional& accidental_text::
  font_weight ()
  {
    return this->font_weight_;
  }

  void accidental_text::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void accidental_text::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void accidental_text::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const accidental_text::color_optional& accidental_text::
  color () const
  {
    return this->color_;
  }

  accidental_text::color_optional& accidental_text::
  color ()
  {
    return this->color_;
  }

  void accidental_text::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void accidental_text::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void accidental_text::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const accidental_text::halign_optional& accidental_text::
  halign () const
  {
    return this->halign_;
  }

  accidental_text::halign_optional& accidental_text::
  halign ()
  {
    return this->halign_;
  }

  void accidental_text::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void accidental_text::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void accidental_text::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const accidental_text::valign_optional& accidental_text::
  valign () const
  {
    return this->valign_;
  }

  accidental_text::valign_optional& accidental_text::
  valign ()
  {
    return this->valign_;
  }

  void accidental_text::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void accidental_text::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void accidental_text::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const accidental_text::underline_optional& accidental_text::
  underline () const
  {
    return this->underline_;
  }

  accidental_text::underline_optional& accidental_text::
  underline ()
  {
    return this->underline_;
  }

  void accidental_text::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void accidental_text::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void accidental_text::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const accidental_text::overline_optional& accidental_text::
  overline () const
  {
    return this->overline_;
  }

  accidental_text::overline_optional& accidental_text::
  overline ()
  {
    return this->overline_;
  }

  void accidental_text::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void accidental_text::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void accidental_text::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const accidental_text::line_through_optional& accidental_text::
  line_through () const
  {
    return this->line_through_;
  }

  accidental_text::line_through_optional& accidental_text::
  line_through ()
  {
    return this->line_through_;
  }

  void accidental_text::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void accidental_text::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void accidental_text::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const accidental_text::rotation_optional& accidental_text::
  rotation () const
  {
    return this->rotation_;
  }

  accidental_text::rotation_optional& accidental_text::
  rotation ()
  {
    return this->rotation_;
  }

  void accidental_text::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void accidental_text::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void accidental_text::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const accidental_text::letter_spacing_optional& accidental_text::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  accidental_text::letter_spacing_optional& accidental_text::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void accidental_text::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void accidental_text::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void accidental_text::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const accidental_text::line_height_optional& accidental_text::
  line_height () const
  {
    return this->line_height_;
  }

  accidental_text::line_height_optional& accidental_text::
  line_height ()
  {
    return this->line_height_;
  }

  void accidental_text::
  line_height (const line_height_type& x)
  {
    this->line_height_.set (x);
  }

  void accidental_text::
  line_height (const line_height_optional& x)
  {
    this->line_height_ = x;
  }

  void accidental_text::
  line_height (::std::unique_ptr< line_height_type > x)
  {
    this->line_height_.set (std::move (x));
  }

  const accidental_text::lang_optional& accidental_text::
  lang () const
  {
    return this->lang_;
  }

  accidental_text::lang_optional& accidental_text::
  lang ()
  {
    return this->lang_;
  }

  void accidental_text::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void accidental_text::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void accidental_text::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }

  const accidental_text::space_optional& accidental_text::
  space () const
  {
    return this->space_;
  }

  accidental_text::space_optional& accidental_text::
  space ()
  {
    return this->space_;
  }

  void accidental_text::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void accidental_text::
  space (const space_optional& x)
  {
    this->space_ = x;
  }

  void accidental_text::
  space (::std::unique_ptr< space_type > x)
  {
    this->space_.set (std::move (x));
  }

  const accidental_text::dir_optional& accidental_text::
  dir () const
  {
    return this->dir_;
  }

  accidental_text::dir_optional& accidental_text::
  dir ()
  {
    return this->dir_;
  }

  void accidental_text::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void accidental_text::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void accidental_text::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }

  const accidental_text::enclosure_optional& accidental_text::
  enclosure () const
  {
    return this->enclosure_;
  }

  accidental_text::enclosure_optional& accidental_text::
  enclosure ()
  {
    return this->enclosure_;
  }

  void accidental_text::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void accidental_text::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void accidental_text::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }

  const accidental_text::smufl_optional& accidental_text::
  smufl () const
  {
    return this->smufl_;
  }

  accidental_text::smufl_optional& accidental_text::
  smufl ()
  {
    return this->smufl_;
  }

  void accidental_text::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void accidental_text::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void accidental_text::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // coda
  // 

  const coda::default_x_optional& coda::
  default_x () const
  {
    return this->default_x_;
  }

  coda::default_x_optional& coda::
  default_x ()
  {
    return this->default_x_;
  }

  void coda::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void coda::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void coda::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const coda::default_y_optional& coda::
  default_y () const
  {
    return this->default_y_;
  }

  coda::default_y_optional& coda::
  default_y ()
  {
    return this->default_y_;
  }

  void coda::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void coda::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void coda::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const coda::relative_x_optional& coda::
  relative_x () const
  {
    return this->relative_x_;
  }

  coda::relative_x_optional& coda::
  relative_x ()
  {
    return this->relative_x_;
  }

  void coda::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void coda::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void coda::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const coda::relative_y_optional& coda::
  relative_y () const
  {
    return this->relative_y_;
  }

  coda::relative_y_optional& coda::
  relative_y ()
  {
    return this->relative_y_;
  }

  void coda::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void coda::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void coda::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const coda::font_family_optional& coda::
  font_family () const
  {
    return this->font_family_;
  }

  coda::font_family_optional& coda::
  font_family ()
  {
    return this->font_family_;
  }

  void coda::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void coda::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void coda::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const coda::font_style_optional& coda::
  font_style () const
  {
    return this->font_style_;
  }

  coda::font_style_optional& coda::
  font_style ()
  {
    return this->font_style_;
  }

  void coda::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void coda::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void coda::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const coda::font_size_optional& coda::
  font_size () const
  {
    return this->font_size_;
  }

  coda::font_size_optional& coda::
  font_size ()
  {
    return this->font_size_;
  }

  void coda::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void coda::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void coda::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const coda::font_weight_optional& coda::
  font_weight () const
  {
    return this->font_weight_;
  }

  coda::font_weight_optional& coda::
  font_weight ()
  {
    return this->font_weight_;
  }

  void coda::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void coda::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void coda::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const coda::color_optional& coda::
  color () const
  {
    return this->color_;
  }

  coda::color_optional& coda::
  color ()
  {
    return this->color_;
  }

  void coda::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void coda::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void coda::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const coda::halign_optional& coda::
  halign () const
  {
    return this->halign_;
  }

  coda::halign_optional& coda::
  halign ()
  {
    return this->halign_;
  }

  void coda::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void coda::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void coda::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const coda::valign_optional& coda::
  valign () const
  {
    return this->valign_;
  }

  coda::valign_optional& coda::
  valign ()
  {
    return this->valign_;
  }

  void coda::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void coda::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void coda::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const coda::id_optional& coda::
  id () const
  {
    return this->id_;
  }

  coda::id_optional& coda::
  id ()
  {
    return this->id_;
  }

  void coda::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void coda::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void coda::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const coda::smufl_optional& coda::
  smufl () const
  {
    return this->smufl_;
  }

  coda::smufl_optional& coda::
  smufl ()
  {
    return this->smufl_;
  }

  void coda::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void coda::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void coda::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // dynamics
  // 

  const dynamics::p_sequence& dynamics::
  p () const
  {
    return this->p_;
  }

  dynamics::p_sequence& dynamics::
  p ()
  {
    return this->p_;
  }

  void dynamics::
  p (const p_sequence& s)
  {
    this->p_ = s;
  }

  const dynamics::pp_sequence& dynamics::
  pp () const
  {
    return this->pp_;
  }

  dynamics::pp_sequence& dynamics::
  pp ()
  {
    return this->pp_;
  }

  void dynamics::
  pp (const pp_sequence& s)
  {
    this->pp_ = s;
  }

  const dynamics::ppp_sequence& dynamics::
  ppp () const
  {
    return this->ppp_;
  }

  dynamics::ppp_sequence& dynamics::
  ppp ()
  {
    return this->ppp_;
  }

  void dynamics::
  ppp (const ppp_sequence& s)
  {
    this->ppp_ = s;
  }

  const dynamics::pppp_sequence& dynamics::
  pppp () const
  {
    return this->pppp_;
  }

  dynamics::pppp_sequence& dynamics::
  pppp ()
  {
    return this->pppp_;
  }

  void dynamics::
  pppp (const pppp_sequence& s)
  {
    this->pppp_ = s;
  }

  const dynamics::ppppp_sequence& dynamics::
  ppppp () const
  {
    return this->ppppp_;
  }

  dynamics::ppppp_sequence& dynamics::
  ppppp ()
  {
    return this->ppppp_;
  }

  void dynamics::
  ppppp (const ppppp_sequence& s)
  {
    this->ppppp_ = s;
  }

  const dynamics::pppppp_sequence& dynamics::
  pppppp () const
  {
    return this->pppppp_;
  }

  dynamics::pppppp_sequence& dynamics::
  pppppp ()
  {
    return this->pppppp_;
  }

  void dynamics::
  pppppp (const pppppp_sequence& s)
  {
    this->pppppp_ = s;
  }

  const dynamics::f_sequence& dynamics::
  f () const
  {
    return this->f_;
  }

  dynamics::f_sequence& dynamics::
  f ()
  {
    return this->f_;
  }

  void dynamics::
  f (const f_sequence& s)
  {
    this->f_ = s;
  }

  const dynamics::ff_sequence& dynamics::
  ff () const
  {
    return this->ff_;
  }

  dynamics::ff_sequence& dynamics::
  ff ()
  {
    return this->ff_;
  }

  void dynamics::
  ff (const ff_sequence& s)
  {
    this->ff_ = s;
  }

  const dynamics::fff_sequence& dynamics::
  fff () const
  {
    return this->fff_;
  }

  dynamics::fff_sequence& dynamics::
  fff ()
  {
    return this->fff_;
  }

  void dynamics::
  fff (const fff_sequence& s)
  {
    this->fff_ = s;
  }

  const dynamics::ffff_sequence& dynamics::
  ffff () const
  {
    return this->ffff_;
  }

  dynamics::ffff_sequence& dynamics::
  ffff ()
  {
    return this->ffff_;
  }

  void dynamics::
  ffff (const ffff_sequence& s)
  {
    this->ffff_ = s;
  }

  const dynamics::fffff_sequence& dynamics::
  fffff () const
  {
    return this->fffff_;
  }

  dynamics::fffff_sequence& dynamics::
  fffff ()
  {
    return this->fffff_;
  }

  void dynamics::
  fffff (const fffff_sequence& s)
  {
    this->fffff_ = s;
  }

  const dynamics::ffffff_sequence& dynamics::
  ffffff () const
  {
    return this->ffffff_;
  }

  dynamics::ffffff_sequence& dynamics::
  ffffff ()
  {
    return this->ffffff_;
  }

  void dynamics::
  ffffff (const ffffff_sequence& s)
  {
    this->ffffff_ = s;
  }

  const dynamics::mp_sequence& dynamics::
  mp () const
  {
    return this->mp_;
  }

  dynamics::mp_sequence& dynamics::
  mp ()
  {
    return this->mp_;
  }

  void dynamics::
  mp (const mp_sequence& s)
  {
    this->mp_ = s;
  }

  const dynamics::mf_sequence& dynamics::
  mf () const
  {
    return this->mf_;
  }

  dynamics::mf_sequence& dynamics::
  mf ()
  {
    return this->mf_;
  }

  void dynamics::
  mf (const mf_sequence& s)
  {
    this->mf_ = s;
  }

  const dynamics::sf_sequence& dynamics::
  sf () const
  {
    return this->sf_;
  }

  dynamics::sf_sequence& dynamics::
  sf ()
  {
    return this->sf_;
  }

  void dynamics::
  sf (const sf_sequence& s)
  {
    this->sf_ = s;
  }

  const dynamics::sfp_sequence& dynamics::
  sfp () const
  {
    return this->sfp_;
  }

  dynamics::sfp_sequence& dynamics::
  sfp ()
  {
    return this->sfp_;
  }

  void dynamics::
  sfp (const sfp_sequence& s)
  {
    this->sfp_ = s;
  }

  const dynamics::sfpp_sequence& dynamics::
  sfpp () const
  {
    return this->sfpp_;
  }

  dynamics::sfpp_sequence& dynamics::
  sfpp ()
  {
    return this->sfpp_;
  }

  void dynamics::
  sfpp (const sfpp_sequence& s)
  {
    this->sfpp_ = s;
  }

  const dynamics::fp_sequence& dynamics::
  fp () const
  {
    return this->fp_;
  }

  dynamics::fp_sequence& dynamics::
  fp ()
  {
    return this->fp_;
  }

  void dynamics::
  fp (const fp_sequence& s)
  {
    this->fp_ = s;
  }

  const dynamics::rf_sequence& dynamics::
  rf () const
  {
    return this->rf_;
  }

  dynamics::rf_sequence& dynamics::
  rf ()
  {
    return this->rf_;
  }

  void dynamics::
  rf (const rf_sequence& s)
  {
    this->rf_ = s;
  }

  const dynamics::rfz_sequence& dynamics::
  rfz () const
  {
    return this->rfz_;
  }

  dynamics::rfz_sequence& dynamics::
  rfz ()
  {
    return this->rfz_;
  }

  void dynamics::
  rfz (const rfz_sequence& s)
  {
    this->rfz_ = s;
  }

  const dynamics::sfz_sequence& dynamics::
  sfz () const
  {
    return this->sfz_;
  }

  dynamics::sfz_sequence& dynamics::
  sfz ()
  {
    return this->sfz_;
  }

  void dynamics::
  sfz (const sfz_sequence& s)
  {
    this->sfz_ = s;
  }

  const dynamics::sffz_sequence& dynamics::
  sffz () const
  {
    return this->sffz_;
  }

  dynamics::sffz_sequence& dynamics::
  sffz ()
  {
    return this->sffz_;
  }

  void dynamics::
  sffz (const sffz_sequence& s)
  {
    this->sffz_ = s;
  }

  const dynamics::fz_sequence& dynamics::
  fz () const
  {
    return this->fz_;
  }

  dynamics::fz_sequence& dynamics::
  fz ()
  {
    return this->fz_;
  }

  void dynamics::
  fz (const fz_sequence& s)
  {
    this->fz_ = s;
  }

  const dynamics::n_sequence& dynamics::
  n () const
  {
    return this->n_;
  }

  dynamics::n_sequence& dynamics::
  n ()
  {
    return this->n_;
  }

  void dynamics::
  n (const n_sequence& s)
  {
    this->n_ = s;
  }

  const dynamics::pf_sequence& dynamics::
  pf () const
  {
    return this->pf_;
  }

  dynamics::pf_sequence& dynamics::
  pf ()
  {
    return this->pf_;
  }

  void dynamics::
  pf (const pf_sequence& s)
  {
    this->pf_ = s;
  }

  const dynamics::sfzp_sequence& dynamics::
  sfzp () const
  {
    return this->sfzp_;
  }

  dynamics::sfzp_sequence& dynamics::
  sfzp ()
  {
    return this->sfzp_;
  }

  void dynamics::
  sfzp (const sfzp_sequence& s)
  {
    this->sfzp_ = s;
  }

  const dynamics::other_dynamics_sequence& dynamics::
  other_dynamics () const
  {
    return this->other_dynamics_;
  }

  dynamics::other_dynamics_sequence& dynamics::
  other_dynamics ()
  {
    return this->other_dynamics_;
  }

  void dynamics::
  other_dynamics (const other_dynamics_sequence& s)
  {
    this->other_dynamics_ = s;
  }

  const dynamics::default_x_optional& dynamics::
  default_x () const
  {
    return this->default_x_;
  }

  dynamics::default_x_optional& dynamics::
  default_x ()
  {
    return this->default_x_;
  }

  void dynamics::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void dynamics::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void dynamics::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const dynamics::default_y_optional& dynamics::
  default_y () const
  {
    return this->default_y_;
  }

  dynamics::default_y_optional& dynamics::
  default_y ()
  {
    return this->default_y_;
  }

  void dynamics::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void dynamics::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void dynamics::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const dynamics::relative_x_optional& dynamics::
  relative_x () const
  {
    return this->relative_x_;
  }

  dynamics::relative_x_optional& dynamics::
  relative_x ()
  {
    return this->relative_x_;
  }

  void dynamics::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void dynamics::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void dynamics::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const dynamics::relative_y_optional& dynamics::
  relative_y () const
  {
    return this->relative_y_;
  }

  dynamics::relative_y_optional& dynamics::
  relative_y ()
  {
    return this->relative_y_;
  }

  void dynamics::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void dynamics::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void dynamics::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const dynamics::font_family_optional& dynamics::
  font_family () const
  {
    return this->font_family_;
  }

  dynamics::font_family_optional& dynamics::
  font_family ()
  {
    return this->font_family_;
  }

  void dynamics::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void dynamics::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void dynamics::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const dynamics::font_style_optional& dynamics::
  font_style () const
  {
    return this->font_style_;
  }

  dynamics::font_style_optional& dynamics::
  font_style ()
  {
    return this->font_style_;
  }

  void dynamics::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void dynamics::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void dynamics::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const dynamics::font_size_optional& dynamics::
  font_size () const
  {
    return this->font_size_;
  }

  dynamics::font_size_optional& dynamics::
  font_size ()
  {
    return this->font_size_;
  }

  void dynamics::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void dynamics::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void dynamics::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const dynamics::font_weight_optional& dynamics::
  font_weight () const
  {
    return this->font_weight_;
  }

  dynamics::font_weight_optional& dynamics::
  font_weight ()
  {
    return this->font_weight_;
  }

  void dynamics::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void dynamics::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void dynamics::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const dynamics::color_optional& dynamics::
  color () const
  {
    return this->color_;
  }

  dynamics::color_optional& dynamics::
  color ()
  {
    return this->color_;
  }

  void dynamics::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void dynamics::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void dynamics::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const dynamics::halign_optional& dynamics::
  halign () const
  {
    return this->halign_;
  }

  dynamics::halign_optional& dynamics::
  halign ()
  {
    return this->halign_;
  }

  void dynamics::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void dynamics::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void dynamics::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const dynamics::valign_optional& dynamics::
  valign () const
  {
    return this->valign_;
  }

  dynamics::valign_optional& dynamics::
  valign ()
  {
    return this->valign_;
  }

  void dynamics::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void dynamics::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void dynamics::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const dynamics::placement_optional& dynamics::
  placement () const
  {
    return this->placement_;
  }

  dynamics::placement_optional& dynamics::
  placement ()
  {
    return this->placement_;
  }

  void dynamics::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void dynamics::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void dynamics::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const dynamics::underline_optional& dynamics::
  underline () const
  {
    return this->underline_;
  }

  dynamics::underline_optional& dynamics::
  underline ()
  {
    return this->underline_;
  }

  void dynamics::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void dynamics::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void dynamics::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const dynamics::overline_optional& dynamics::
  overline () const
  {
    return this->overline_;
  }

  dynamics::overline_optional& dynamics::
  overline ()
  {
    return this->overline_;
  }

  void dynamics::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void dynamics::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void dynamics::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const dynamics::line_through_optional& dynamics::
  line_through () const
  {
    return this->line_through_;
  }

  dynamics::line_through_optional& dynamics::
  line_through ()
  {
    return this->line_through_;
  }

  void dynamics::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void dynamics::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void dynamics::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const dynamics::enclosure_optional& dynamics::
  enclosure () const
  {
    return this->enclosure_;
  }

  dynamics::enclosure_optional& dynamics::
  enclosure ()
  {
    return this->enclosure_;
  }

  void dynamics::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void dynamics::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void dynamics::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }

  const dynamics::id_optional& dynamics::
  id () const
  {
    return this->id_;
  }

  dynamics::id_optional& dynamics::
  id ()
  {
    return this->id_;
  }

  void dynamics::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void dynamics::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void dynamics::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // empty
  // 


  // empty_placement
  // 

  const empty_placement::default_x_optional& empty_placement::
  default_x () const
  {
    return this->default_x_;
  }

  empty_placement::default_x_optional& empty_placement::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_placement::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_placement::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_placement::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_placement::default_y_optional& empty_placement::
  default_y () const
  {
    return this->default_y_;
  }

  empty_placement::default_y_optional& empty_placement::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_placement::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_placement::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_placement::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_placement::relative_x_optional& empty_placement::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_placement::relative_x_optional& empty_placement::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_placement::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_placement::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_placement::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_placement::relative_y_optional& empty_placement::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_placement::relative_y_optional& empty_placement::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_placement::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_placement::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_placement::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_placement::font_family_optional& empty_placement::
  font_family () const
  {
    return this->font_family_;
  }

  empty_placement::font_family_optional& empty_placement::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_placement::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_placement::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_placement::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_placement::font_style_optional& empty_placement::
  font_style () const
  {
    return this->font_style_;
  }

  empty_placement::font_style_optional& empty_placement::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_placement::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_placement::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_placement::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_placement::font_size_optional& empty_placement::
  font_size () const
  {
    return this->font_size_;
  }

  empty_placement::font_size_optional& empty_placement::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_placement::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_placement::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_placement::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_placement::font_weight_optional& empty_placement::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_placement::font_weight_optional& empty_placement::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_placement::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_placement::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_placement::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_placement::color_optional& empty_placement::
  color () const
  {
    return this->color_;
  }

  empty_placement::color_optional& empty_placement::
  color ()
  {
    return this->color_;
  }

  void empty_placement::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_placement::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_placement::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_placement::placement_optional& empty_placement::
  placement () const
  {
    return this->placement_;
  }

  empty_placement::placement_optional& empty_placement::
  placement ()
  {
    return this->placement_;
  }

  void empty_placement::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void empty_placement::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void empty_placement::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // empty_placement_smufl
  // 

  const empty_placement_smufl::default_x_optional& empty_placement_smufl::
  default_x () const
  {
    return this->default_x_;
  }

  empty_placement_smufl::default_x_optional& empty_placement_smufl::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_placement_smufl::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_placement_smufl::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_placement_smufl::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_placement_smufl::default_y_optional& empty_placement_smufl::
  default_y () const
  {
    return this->default_y_;
  }

  empty_placement_smufl::default_y_optional& empty_placement_smufl::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_placement_smufl::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_placement_smufl::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_placement_smufl::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_placement_smufl::relative_x_optional& empty_placement_smufl::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_placement_smufl::relative_x_optional& empty_placement_smufl::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_placement_smufl::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_placement_smufl::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_placement_smufl::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_placement_smufl::relative_y_optional& empty_placement_smufl::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_placement_smufl::relative_y_optional& empty_placement_smufl::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_placement_smufl::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_placement_smufl::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_placement_smufl::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_placement_smufl::font_family_optional& empty_placement_smufl::
  font_family () const
  {
    return this->font_family_;
  }

  empty_placement_smufl::font_family_optional& empty_placement_smufl::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_placement_smufl::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_placement_smufl::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_placement_smufl::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_placement_smufl::font_style_optional& empty_placement_smufl::
  font_style () const
  {
    return this->font_style_;
  }

  empty_placement_smufl::font_style_optional& empty_placement_smufl::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_placement_smufl::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_placement_smufl::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_placement_smufl::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_placement_smufl::font_size_optional& empty_placement_smufl::
  font_size () const
  {
    return this->font_size_;
  }

  empty_placement_smufl::font_size_optional& empty_placement_smufl::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_placement_smufl::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_placement_smufl::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_placement_smufl::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_placement_smufl::font_weight_optional& empty_placement_smufl::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_placement_smufl::font_weight_optional& empty_placement_smufl::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_placement_smufl::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_placement_smufl::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_placement_smufl::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_placement_smufl::color_optional& empty_placement_smufl::
  color () const
  {
    return this->color_;
  }

  empty_placement_smufl::color_optional& empty_placement_smufl::
  color ()
  {
    return this->color_;
  }

  void empty_placement_smufl::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_placement_smufl::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_placement_smufl::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_placement_smufl::placement_optional& empty_placement_smufl::
  placement () const
  {
    return this->placement_;
  }

  empty_placement_smufl::placement_optional& empty_placement_smufl::
  placement ()
  {
    return this->placement_;
  }

  void empty_placement_smufl::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void empty_placement_smufl::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void empty_placement_smufl::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const empty_placement_smufl::smufl_optional& empty_placement_smufl::
  smufl () const
  {
    return this->smufl_;
  }

  empty_placement_smufl::smufl_optional& empty_placement_smufl::
  smufl ()
  {
    return this->smufl_;
  }

  void empty_placement_smufl::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void empty_placement_smufl::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void empty_placement_smufl::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // empty_print_style
  // 

  const empty_print_style::default_x_optional& empty_print_style::
  default_x () const
  {
    return this->default_x_;
  }

  empty_print_style::default_x_optional& empty_print_style::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_print_style::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_print_style::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_print_style::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_print_style::default_y_optional& empty_print_style::
  default_y () const
  {
    return this->default_y_;
  }

  empty_print_style::default_y_optional& empty_print_style::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_print_style::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_print_style::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_print_style::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_print_style::relative_x_optional& empty_print_style::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_print_style::relative_x_optional& empty_print_style::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_print_style::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_print_style::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_print_style::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_print_style::relative_y_optional& empty_print_style::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_print_style::relative_y_optional& empty_print_style::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_print_style::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_print_style::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_print_style::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_print_style::font_family_optional& empty_print_style::
  font_family () const
  {
    return this->font_family_;
  }

  empty_print_style::font_family_optional& empty_print_style::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_print_style::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_print_style::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_print_style::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_print_style::font_style_optional& empty_print_style::
  font_style () const
  {
    return this->font_style_;
  }

  empty_print_style::font_style_optional& empty_print_style::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_print_style::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_print_style::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_print_style::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_print_style::font_size_optional& empty_print_style::
  font_size () const
  {
    return this->font_size_;
  }

  empty_print_style::font_size_optional& empty_print_style::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_print_style::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_print_style::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_print_style::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_print_style::font_weight_optional& empty_print_style::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_print_style::font_weight_optional& empty_print_style::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_print_style::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_print_style::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_print_style::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_print_style::color_optional& empty_print_style::
  color () const
  {
    return this->color_;
  }

  empty_print_style::color_optional& empty_print_style::
  color ()
  {
    return this->color_;
  }

  void empty_print_style::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_print_style::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_print_style::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // empty_print_style_align
  // 

  const empty_print_style_align::default_x_optional& empty_print_style_align::
  default_x () const
  {
    return this->default_x_;
  }

  empty_print_style_align::default_x_optional& empty_print_style_align::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_print_style_align::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_print_style_align::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_print_style_align::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_print_style_align::default_y_optional& empty_print_style_align::
  default_y () const
  {
    return this->default_y_;
  }

  empty_print_style_align::default_y_optional& empty_print_style_align::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_print_style_align::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_print_style_align::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_print_style_align::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_print_style_align::relative_x_optional& empty_print_style_align::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_print_style_align::relative_x_optional& empty_print_style_align::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_print_style_align::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_print_style_align::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_print_style_align::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_print_style_align::relative_y_optional& empty_print_style_align::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_print_style_align::relative_y_optional& empty_print_style_align::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_print_style_align::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_print_style_align::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_print_style_align::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_print_style_align::font_family_optional& empty_print_style_align::
  font_family () const
  {
    return this->font_family_;
  }

  empty_print_style_align::font_family_optional& empty_print_style_align::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_print_style_align::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_print_style_align::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_print_style_align::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_print_style_align::font_style_optional& empty_print_style_align::
  font_style () const
  {
    return this->font_style_;
  }

  empty_print_style_align::font_style_optional& empty_print_style_align::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_print_style_align::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_print_style_align::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_print_style_align::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_print_style_align::font_size_optional& empty_print_style_align::
  font_size () const
  {
    return this->font_size_;
  }

  empty_print_style_align::font_size_optional& empty_print_style_align::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_print_style_align::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_print_style_align::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_print_style_align::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_print_style_align::font_weight_optional& empty_print_style_align::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_print_style_align::font_weight_optional& empty_print_style_align::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_print_style_align::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_print_style_align::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_print_style_align::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_print_style_align::color_optional& empty_print_style_align::
  color () const
  {
    return this->color_;
  }

  empty_print_style_align::color_optional& empty_print_style_align::
  color ()
  {
    return this->color_;
  }

  void empty_print_style_align::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_print_style_align::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_print_style_align::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_print_style_align::halign_optional& empty_print_style_align::
  halign () const
  {
    return this->halign_;
  }

  empty_print_style_align::halign_optional& empty_print_style_align::
  halign ()
  {
    return this->halign_;
  }

  void empty_print_style_align::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void empty_print_style_align::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void empty_print_style_align::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const empty_print_style_align::valign_optional& empty_print_style_align::
  valign () const
  {
    return this->valign_;
  }

  empty_print_style_align::valign_optional& empty_print_style_align::
  valign ()
  {
    return this->valign_;
  }

  void empty_print_style_align::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void empty_print_style_align::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void empty_print_style_align::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }


  // empty_print_style_align_id
  // 

  const empty_print_style_align_id::default_x_optional& empty_print_style_align_id::
  default_x () const
  {
    return this->default_x_;
  }

  empty_print_style_align_id::default_x_optional& empty_print_style_align_id::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_print_style_align_id::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_print_style_align_id::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_print_style_align_id::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_print_style_align_id::default_y_optional& empty_print_style_align_id::
  default_y () const
  {
    return this->default_y_;
  }

  empty_print_style_align_id::default_y_optional& empty_print_style_align_id::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_print_style_align_id::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_print_style_align_id::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_print_style_align_id::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_print_style_align_id::relative_x_optional& empty_print_style_align_id::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_print_style_align_id::relative_x_optional& empty_print_style_align_id::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_print_style_align_id::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_print_style_align_id::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_print_style_align_id::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_print_style_align_id::relative_y_optional& empty_print_style_align_id::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_print_style_align_id::relative_y_optional& empty_print_style_align_id::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_print_style_align_id::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_print_style_align_id::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_print_style_align_id::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_print_style_align_id::font_family_optional& empty_print_style_align_id::
  font_family () const
  {
    return this->font_family_;
  }

  empty_print_style_align_id::font_family_optional& empty_print_style_align_id::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_print_style_align_id::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_print_style_align_id::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_print_style_align_id::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_print_style_align_id::font_style_optional& empty_print_style_align_id::
  font_style () const
  {
    return this->font_style_;
  }

  empty_print_style_align_id::font_style_optional& empty_print_style_align_id::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_print_style_align_id::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_print_style_align_id::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_print_style_align_id::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_print_style_align_id::font_size_optional& empty_print_style_align_id::
  font_size () const
  {
    return this->font_size_;
  }

  empty_print_style_align_id::font_size_optional& empty_print_style_align_id::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_print_style_align_id::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_print_style_align_id::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_print_style_align_id::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_print_style_align_id::font_weight_optional& empty_print_style_align_id::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_print_style_align_id::font_weight_optional& empty_print_style_align_id::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_print_style_align_id::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_print_style_align_id::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_print_style_align_id::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_print_style_align_id::color_optional& empty_print_style_align_id::
  color () const
  {
    return this->color_;
  }

  empty_print_style_align_id::color_optional& empty_print_style_align_id::
  color ()
  {
    return this->color_;
  }

  void empty_print_style_align_id::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_print_style_align_id::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_print_style_align_id::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_print_style_align_id::halign_optional& empty_print_style_align_id::
  halign () const
  {
    return this->halign_;
  }

  empty_print_style_align_id::halign_optional& empty_print_style_align_id::
  halign ()
  {
    return this->halign_;
  }

  void empty_print_style_align_id::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void empty_print_style_align_id::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void empty_print_style_align_id::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const empty_print_style_align_id::valign_optional& empty_print_style_align_id::
  valign () const
  {
    return this->valign_;
  }

  empty_print_style_align_id::valign_optional& empty_print_style_align_id::
  valign ()
  {
    return this->valign_;
  }

  void empty_print_style_align_id::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void empty_print_style_align_id::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void empty_print_style_align_id::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const empty_print_style_align_id::id_optional& empty_print_style_align_id::
  id () const
  {
    return this->id_;
  }

  empty_print_style_align_id::id_optional& empty_print_style_align_id::
  id ()
  {
    return this->id_;
  }

  void empty_print_style_align_id::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void empty_print_style_align_id::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void empty_print_style_align_id::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // empty_print_object_style_align
  // 

  const empty_print_object_style_align::print_object_optional& empty_print_object_style_align::
  print_object () const
  {
    return this->print_object_;
  }

  empty_print_object_style_align::print_object_optional& empty_print_object_style_align::
  print_object ()
  {
    return this->print_object_;
  }

  void empty_print_object_style_align::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void empty_print_object_style_align::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void empty_print_object_style_align::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const empty_print_object_style_align::default_x_optional& empty_print_object_style_align::
  default_x () const
  {
    return this->default_x_;
  }

  empty_print_object_style_align::default_x_optional& empty_print_object_style_align::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_print_object_style_align::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_print_object_style_align::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_print_object_style_align::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_print_object_style_align::default_y_optional& empty_print_object_style_align::
  default_y () const
  {
    return this->default_y_;
  }

  empty_print_object_style_align::default_y_optional& empty_print_object_style_align::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_print_object_style_align::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_print_object_style_align::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_print_object_style_align::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_print_object_style_align::relative_x_optional& empty_print_object_style_align::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_print_object_style_align::relative_x_optional& empty_print_object_style_align::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_print_object_style_align::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_print_object_style_align::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_print_object_style_align::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_print_object_style_align::relative_y_optional& empty_print_object_style_align::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_print_object_style_align::relative_y_optional& empty_print_object_style_align::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_print_object_style_align::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_print_object_style_align::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_print_object_style_align::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_print_object_style_align::font_family_optional& empty_print_object_style_align::
  font_family () const
  {
    return this->font_family_;
  }

  empty_print_object_style_align::font_family_optional& empty_print_object_style_align::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_print_object_style_align::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_print_object_style_align::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_print_object_style_align::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_print_object_style_align::font_style_optional& empty_print_object_style_align::
  font_style () const
  {
    return this->font_style_;
  }

  empty_print_object_style_align::font_style_optional& empty_print_object_style_align::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_print_object_style_align::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_print_object_style_align::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_print_object_style_align::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_print_object_style_align::font_size_optional& empty_print_object_style_align::
  font_size () const
  {
    return this->font_size_;
  }

  empty_print_object_style_align::font_size_optional& empty_print_object_style_align::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_print_object_style_align::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_print_object_style_align::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_print_object_style_align::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_print_object_style_align::font_weight_optional& empty_print_object_style_align::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_print_object_style_align::font_weight_optional& empty_print_object_style_align::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_print_object_style_align::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_print_object_style_align::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_print_object_style_align::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_print_object_style_align::color_optional& empty_print_object_style_align::
  color () const
  {
    return this->color_;
  }

  empty_print_object_style_align::color_optional& empty_print_object_style_align::
  color ()
  {
    return this->color_;
  }

  void empty_print_object_style_align::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_print_object_style_align::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_print_object_style_align::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_print_object_style_align::halign_optional& empty_print_object_style_align::
  halign () const
  {
    return this->halign_;
  }

  empty_print_object_style_align::halign_optional& empty_print_object_style_align::
  halign ()
  {
    return this->halign_;
  }

  void empty_print_object_style_align::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void empty_print_object_style_align::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void empty_print_object_style_align::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const empty_print_object_style_align::valign_optional& empty_print_object_style_align::
  valign () const
  {
    return this->valign_;
  }

  empty_print_object_style_align::valign_optional& empty_print_object_style_align::
  valign ()
  {
    return this->valign_;
  }

  void empty_print_object_style_align::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void empty_print_object_style_align::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void empty_print_object_style_align::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }


  // empty_trill_sound
  // 

  const empty_trill_sound::default_x_optional& empty_trill_sound::
  default_x () const
  {
    return this->default_x_;
  }

  empty_trill_sound::default_x_optional& empty_trill_sound::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_trill_sound::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_trill_sound::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_trill_sound::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_trill_sound::default_y_optional& empty_trill_sound::
  default_y () const
  {
    return this->default_y_;
  }

  empty_trill_sound::default_y_optional& empty_trill_sound::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_trill_sound::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_trill_sound::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_trill_sound::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_trill_sound::relative_x_optional& empty_trill_sound::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_trill_sound::relative_x_optional& empty_trill_sound::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_trill_sound::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_trill_sound::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_trill_sound::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_trill_sound::relative_y_optional& empty_trill_sound::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_trill_sound::relative_y_optional& empty_trill_sound::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_trill_sound::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_trill_sound::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_trill_sound::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_trill_sound::font_family_optional& empty_trill_sound::
  font_family () const
  {
    return this->font_family_;
  }

  empty_trill_sound::font_family_optional& empty_trill_sound::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_trill_sound::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_trill_sound::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_trill_sound::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_trill_sound::font_style_optional& empty_trill_sound::
  font_style () const
  {
    return this->font_style_;
  }

  empty_trill_sound::font_style_optional& empty_trill_sound::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_trill_sound::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_trill_sound::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_trill_sound::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_trill_sound::font_size_optional& empty_trill_sound::
  font_size () const
  {
    return this->font_size_;
  }

  empty_trill_sound::font_size_optional& empty_trill_sound::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_trill_sound::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_trill_sound::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_trill_sound::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_trill_sound::font_weight_optional& empty_trill_sound::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_trill_sound::font_weight_optional& empty_trill_sound::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_trill_sound::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_trill_sound::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_trill_sound::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_trill_sound::color_optional& empty_trill_sound::
  color () const
  {
    return this->color_;
  }

  empty_trill_sound::color_optional& empty_trill_sound::
  color ()
  {
    return this->color_;
  }

  void empty_trill_sound::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_trill_sound::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_trill_sound::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_trill_sound::placement_optional& empty_trill_sound::
  placement () const
  {
    return this->placement_;
  }

  empty_trill_sound::placement_optional& empty_trill_sound::
  placement ()
  {
    return this->placement_;
  }

  void empty_trill_sound::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void empty_trill_sound::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void empty_trill_sound::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const empty_trill_sound::start_note_optional& empty_trill_sound::
  start_note () const
  {
    return this->start_note_;
  }

  empty_trill_sound::start_note_optional& empty_trill_sound::
  start_note ()
  {
    return this->start_note_;
  }

  void empty_trill_sound::
  start_note (const start_note_type& x)
  {
    this->start_note_.set (x);
  }

  void empty_trill_sound::
  start_note (const start_note_optional& x)
  {
    this->start_note_ = x;
  }

  void empty_trill_sound::
  start_note (::std::unique_ptr< start_note_type > x)
  {
    this->start_note_.set (std::move (x));
  }

  const empty_trill_sound::trill_step_optional& empty_trill_sound::
  trill_step () const
  {
    return this->trill_step_;
  }

  empty_trill_sound::trill_step_optional& empty_trill_sound::
  trill_step ()
  {
    return this->trill_step_;
  }

  void empty_trill_sound::
  trill_step (const trill_step_type& x)
  {
    this->trill_step_.set (x);
  }

  void empty_trill_sound::
  trill_step (const trill_step_optional& x)
  {
    this->trill_step_ = x;
  }

  void empty_trill_sound::
  trill_step (::std::unique_ptr< trill_step_type > x)
  {
    this->trill_step_.set (std::move (x));
  }

  const empty_trill_sound::two_note_turn_optional& empty_trill_sound::
  two_note_turn () const
  {
    return this->two_note_turn_;
  }

  empty_trill_sound::two_note_turn_optional& empty_trill_sound::
  two_note_turn ()
  {
    return this->two_note_turn_;
  }

  void empty_trill_sound::
  two_note_turn (const two_note_turn_type& x)
  {
    this->two_note_turn_.set (x);
  }

  void empty_trill_sound::
  two_note_turn (const two_note_turn_optional& x)
  {
    this->two_note_turn_ = x;
  }

  void empty_trill_sound::
  two_note_turn (::std::unique_ptr< two_note_turn_type > x)
  {
    this->two_note_turn_.set (std::move (x));
  }

  const empty_trill_sound::accelerate_optional& empty_trill_sound::
  accelerate () const
  {
    return this->accelerate_;
  }

  empty_trill_sound::accelerate_optional& empty_trill_sound::
  accelerate ()
  {
    return this->accelerate_;
  }

  void empty_trill_sound::
  accelerate (const accelerate_type& x)
  {
    this->accelerate_.set (x);
  }

  void empty_trill_sound::
  accelerate (const accelerate_optional& x)
  {
    this->accelerate_ = x;
  }

  void empty_trill_sound::
  accelerate (::std::unique_ptr< accelerate_type > x)
  {
    this->accelerate_.set (std::move (x));
  }

  const empty_trill_sound::beats_optional& empty_trill_sound::
  beats () const
  {
    return this->beats_;
  }

  empty_trill_sound::beats_optional& empty_trill_sound::
  beats ()
  {
    return this->beats_;
  }

  void empty_trill_sound::
  beats (const beats_type& x)
  {
    this->beats_.set (x);
  }

  void empty_trill_sound::
  beats (const beats_optional& x)
  {
    this->beats_ = x;
  }

  void empty_trill_sound::
  beats (::std::unique_ptr< beats_type > x)
  {
    this->beats_.set (std::move (x));
  }

  const empty_trill_sound::second_beat_optional& empty_trill_sound::
  second_beat () const
  {
    return this->second_beat_;
  }

  empty_trill_sound::second_beat_optional& empty_trill_sound::
  second_beat ()
  {
    return this->second_beat_;
  }

  void empty_trill_sound::
  second_beat (const second_beat_type& x)
  {
    this->second_beat_.set (x);
  }

  void empty_trill_sound::
  second_beat (const second_beat_optional& x)
  {
    this->second_beat_ = x;
  }

  void empty_trill_sound::
  second_beat (::std::unique_ptr< second_beat_type > x)
  {
    this->second_beat_.set (std::move (x));
  }

  const empty_trill_sound::last_beat_optional& empty_trill_sound::
  last_beat () const
  {
    return this->last_beat_;
  }

  empty_trill_sound::last_beat_optional& empty_trill_sound::
  last_beat ()
  {
    return this->last_beat_;
  }

  void empty_trill_sound::
  last_beat (const last_beat_type& x)
  {
    this->last_beat_.set (x);
  }

  void empty_trill_sound::
  last_beat (const last_beat_optional& x)
  {
    this->last_beat_ = x;
  }

  void empty_trill_sound::
  last_beat (::std::unique_ptr< last_beat_type > x)
  {
    this->last_beat_.set (std::move (x));
  }


  // horizontal_turn
  // 

  const horizontal_turn::default_x_optional& horizontal_turn::
  default_x () const
  {
    return this->default_x_;
  }

  horizontal_turn::default_x_optional& horizontal_turn::
  default_x ()
  {
    return this->default_x_;
  }

  void horizontal_turn::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void horizontal_turn::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void horizontal_turn::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const horizontal_turn::default_y_optional& horizontal_turn::
  default_y () const
  {
    return this->default_y_;
  }

  horizontal_turn::default_y_optional& horizontal_turn::
  default_y ()
  {
    return this->default_y_;
  }

  void horizontal_turn::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void horizontal_turn::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void horizontal_turn::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const horizontal_turn::relative_x_optional& horizontal_turn::
  relative_x () const
  {
    return this->relative_x_;
  }

  horizontal_turn::relative_x_optional& horizontal_turn::
  relative_x ()
  {
    return this->relative_x_;
  }

  void horizontal_turn::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void horizontal_turn::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void horizontal_turn::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const horizontal_turn::relative_y_optional& horizontal_turn::
  relative_y () const
  {
    return this->relative_y_;
  }

  horizontal_turn::relative_y_optional& horizontal_turn::
  relative_y ()
  {
    return this->relative_y_;
  }

  void horizontal_turn::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void horizontal_turn::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void horizontal_turn::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const horizontal_turn::font_family_optional& horizontal_turn::
  font_family () const
  {
    return this->font_family_;
  }

  horizontal_turn::font_family_optional& horizontal_turn::
  font_family ()
  {
    return this->font_family_;
  }

  void horizontal_turn::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void horizontal_turn::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void horizontal_turn::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const horizontal_turn::font_style_optional& horizontal_turn::
  font_style () const
  {
    return this->font_style_;
  }

  horizontal_turn::font_style_optional& horizontal_turn::
  font_style ()
  {
    return this->font_style_;
  }

  void horizontal_turn::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void horizontal_turn::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void horizontal_turn::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const horizontal_turn::font_size_optional& horizontal_turn::
  font_size () const
  {
    return this->font_size_;
  }

  horizontal_turn::font_size_optional& horizontal_turn::
  font_size ()
  {
    return this->font_size_;
  }

  void horizontal_turn::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void horizontal_turn::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void horizontal_turn::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const horizontal_turn::font_weight_optional& horizontal_turn::
  font_weight () const
  {
    return this->font_weight_;
  }

  horizontal_turn::font_weight_optional& horizontal_turn::
  font_weight ()
  {
    return this->font_weight_;
  }

  void horizontal_turn::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void horizontal_turn::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void horizontal_turn::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const horizontal_turn::color_optional& horizontal_turn::
  color () const
  {
    return this->color_;
  }

  horizontal_turn::color_optional& horizontal_turn::
  color ()
  {
    return this->color_;
  }

  void horizontal_turn::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void horizontal_turn::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void horizontal_turn::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const horizontal_turn::placement_optional& horizontal_turn::
  placement () const
  {
    return this->placement_;
  }

  horizontal_turn::placement_optional& horizontal_turn::
  placement ()
  {
    return this->placement_;
  }

  void horizontal_turn::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void horizontal_turn::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void horizontal_turn::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const horizontal_turn::start_note_optional& horizontal_turn::
  start_note () const
  {
    return this->start_note_;
  }

  horizontal_turn::start_note_optional& horizontal_turn::
  start_note ()
  {
    return this->start_note_;
  }

  void horizontal_turn::
  start_note (const start_note_type& x)
  {
    this->start_note_.set (x);
  }

  void horizontal_turn::
  start_note (const start_note_optional& x)
  {
    this->start_note_ = x;
  }

  void horizontal_turn::
  start_note (::std::unique_ptr< start_note_type > x)
  {
    this->start_note_.set (std::move (x));
  }

  const horizontal_turn::trill_step_optional& horizontal_turn::
  trill_step () const
  {
    return this->trill_step_;
  }

  horizontal_turn::trill_step_optional& horizontal_turn::
  trill_step ()
  {
    return this->trill_step_;
  }

  void horizontal_turn::
  trill_step (const trill_step_type& x)
  {
    this->trill_step_.set (x);
  }

  void horizontal_turn::
  trill_step (const trill_step_optional& x)
  {
    this->trill_step_ = x;
  }

  void horizontal_turn::
  trill_step (::std::unique_ptr< trill_step_type > x)
  {
    this->trill_step_.set (std::move (x));
  }

  const horizontal_turn::two_note_turn_optional& horizontal_turn::
  two_note_turn () const
  {
    return this->two_note_turn_;
  }

  horizontal_turn::two_note_turn_optional& horizontal_turn::
  two_note_turn ()
  {
    return this->two_note_turn_;
  }

  void horizontal_turn::
  two_note_turn (const two_note_turn_type& x)
  {
    this->two_note_turn_.set (x);
  }

  void horizontal_turn::
  two_note_turn (const two_note_turn_optional& x)
  {
    this->two_note_turn_ = x;
  }

  void horizontal_turn::
  two_note_turn (::std::unique_ptr< two_note_turn_type > x)
  {
    this->two_note_turn_.set (std::move (x));
  }

  const horizontal_turn::accelerate_optional& horizontal_turn::
  accelerate () const
  {
    return this->accelerate_;
  }

  horizontal_turn::accelerate_optional& horizontal_turn::
  accelerate ()
  {
    return this->accelerate_;
  }

  void horizontal_turn::
  accelerate (const accelerate_type& x)
  {
    this->accelerate_.set (x);
  }

  void horizontal_turn::
  accelerate (const accelerate_optional& x)
  {
    this->accelerate_ = x;
  }

  void horizontal_turn::
  accelerate (::std::unique_ptr< accelerate_type > x)
  {
    this->accelerate_.set (std::move (x));
  }

  const horizontal_turn::beats_optional& horizontal_turn::
  beats () const
  {
    return this->beats_;
  }

  horizontal_turn::beats_optional& horizontal_turn::
  beats ()
  {
    return this->beats_;
  }

  void horizontal_turn::
  beats (const beats_type& x)
  {
    this->beats_.set (x);
  }

  void horizontal_turn::
  beats (const beats_optional& x)
  {
    this->beats_ = x;
  }

  void horizontal_turn::
  beats (::std::unique_ptr< beats_type > x)
  {
    this->beats_.set (std::move (x));
  }

  const horizontal_turn::second_beat_optional& horizontal_turn::
  second_beat () const
  {
    return this->second_beat_;
  }

  horizontal_turn::second_beat_optional& horizontal_turn::
  second_beat ()
  {
    return this->second_beat_;
  }

  void horizontal_turn::
  second_beat (const second_beat_type& x)
  {
    this->second_beat_.set (x);
  }

  void horizontal_turn::
  second_beat (const second_beat_optional& x)
  {
    this->second_beat_ = x;
  }

  void horizontal_turn::
  second_beat (::std::unique_ptr< second_beat_type > x)
  {
    this->second_beat_.set (std::move (x));
  }

  const horizontal_turn::last_beat_optional& horizontal_turn::
  last_beat () const
  {
    return this->last_beat_;
  }

  horizontal_turn::last_beat_optional& horizontal_turn::
  last_beat ()
  {
    return this->last_beat_;
  }

  void horizontal_turn::
  last_beat (const last_beat_type& x)
  {
    this->last_beat_.set (x);
  }

  void horizontal_turn::
  last_beat (const last_beat_optional& x)
  {
    this->last_beat_ = x;
  }

  void horizontal_turn::
  last_beat (::std::unique_ptr< last_beat_type > x)
  {
    this->last_beat_.set (std::move (x));
  }

  const horizontal_turn::slash_optional& horizontal_turn::
  slash () const
  {
    return this->slash_;
  }

  horizontal_turn::slash_optional& horizontal_turn::
  slash ()
  {
    return this->slash_;
  }

  void horizontal_turn::
  slash (const slash_type& x)
  {
    this->slash_.set (x);
  }

  void horizontal_turn::
  slash (const slash_optional& x)
  {
    this->slash_ = x;
  }

  void horizontal_turn::
  slash (::std::unique_ptr< slash_type > x)
  {
    this->slash_.set (std::move (x));
  }


  // fermata
  // 

  const fermata::type_optional& fermata::
  type () const
  {
    return this->type_;
  }

  fermata::type_optional& fermata::
  type ()
  {
    return this->type_;
  }

  void fermata::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void fermata::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void fermata::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const fermata::default_x_optional& fermata::
  default_x () const
  {
    return this->default_x_;
  }

  fermata::default_x_optional& fermata::
  default_x ()
  {
    return this->default_x_;
  }

  void fermata::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void fermata::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void fermata::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const fermata::default_y_optional& fermata::
  default_y () const
  {
    return this->default_y_;
  }

  fermata::default_y_optional& fermata::
  default_y ()
  {
    return this->default_y_;
  }

  void fermata::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void fermata::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void fermata::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const fermata::relative_x_optional& fermata::
  relative_x () const
  {
    return this->relative_x_;
  }

  fermata::relative_x_optional& fermata::
  relative_x ()
  {
    return this->relative_x_;
  }

  void fermata::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void fermata::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void fermata::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const fermata::relative_y_optional& fermata::
  relative_y () const
  {
    return this->relative_y_;
  }

  fermata::relative_y_optional& fermata::
  relative_y ()
  {
    return this->relative_y_;
  }

  void fermata::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void fermata::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void fermata::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const fermata::font_family_optional& fermata::
  font_family () const
  {
    return this->font_family_;
  }

  fermata::font_family_optional& fermata::
  font_family ()
  {
    return this->font_family_;
  }

  void fermata::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void fermata::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void fermata::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const fermata::font_style_optional& fermata::
  font_style () const
  {
    return this->font_style_;
  }

  fermata::font_style_optional& fermata::
  font_style ()
  {
    return this->font_style_;
  }

  void fermata::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void fermata::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void fermata::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const fermata::font_size_optional& fermata::
  font_size () const
  {
    return this->font_size_;
  }

  fermata::font_size_optional& fermata::
  font_size ()
  {
    return this->font_size_;
  }

  void fermata::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void fermata::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void fermata::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const fermata::font_weight_optional& fermata::
  font_weight () const
  {
    return this->font_weight_;
  }

  fermata::font_weight_optional& fermata::
  font_weight ()
  {
    return this->font_weight_;
  }

  void fermata::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void fermata::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void fermata::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const fermata::color_optional& fermata::
  color () const
  {
    return this->color_;
  }

  fermata::color_optional& fermata::
  color ()
  {
    return this->color_;
  }

  void fermata::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void fermata::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void fermata::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const fermata::id_optional& fermata::
  id () const
  {
    return this->id_;
  }

  fermata::id_optional& fermata::
  id ()
  {
    return this->id_;
  }

  void fermata::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void fermata::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void fermata::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // fingering
  // 

  const fingering::substitution_optional& fingering::
  substitution () const
  {
    return this->substitution_;
  }

  fingering::substitution_optional& fingering::
  substitution ()
  {
    return this->substitution_;
  }

  void fingering::
  substitution (const substitution_type& x)
  {
    this->substitution_.set (x);
  }

  void fingering::
  substitution (const substitution_optional& x)
  {
    this->substitution_ = x;
  }

  void fingering::
  substitution (::std::unique_ptr< substitution_type > x)
  {
    this->substitution_.set (std::move (x));
  }

  const fingering::alternate_optional& fingering::
  alternate () const
  {
    return this->alternate_;
  }

  fingering::alternate_optional& fingering::
  alternate ()
  {
    return this->alternate_;
  }

  void fingering::
  alternate (const alternate_type& x)
  {
    this->alternate_.set (x);
  }

  void fingering::
  alternate (const alternate_optional& x)
  {
    this->alternate_ = x;
  }

  void fingering::
  alternate (::std::unique_ptr< alternate_type > x)
  {
    this->alternate_.set (std::move (x));
  }

  const fingering::default_x_optional& fingering::
  default_x () const
  {
    return this->default_x_;
  }

  fingering::default_x_optional& fingering::
  default_x ()
  {
    return this->default_x_;
  }

  void fingering::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void fingering::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void fingering::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const fingering::default_y_optional& fingering::
  default_y () const
  {
    return this->default_y_;
  }

  fingering::default_y_optional& fingering::
  default_y ()
  {
    return this->default_y_;
  }

  void fingering::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void fingering::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void fingering::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const fingering::relative_x_optional& fingering::
  relative_x () const
  {
    return this->relative_x_;
  }

  fingering::relative_x_optional& fingering::
  relative_x ()
  {
    return this->relative_x_;
  }

  void fingering::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void fingering::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void fingering::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const fingering::relative_y_optional& fingering::
  relative_y () const
  {
    return this->relative_y_;
  }

  fingering::relative_y_optional& fingering::
  relative_y ()
  {
    return this->relative_y_;
  }

  void fingering::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void fingering::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void fingering::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const fingering::font_family_optional& fingering::
  font_family () const
  {
    return this->font_family_;
  }

  fingering::font_family_optional& fingering::
  font_family ()
  {
    return this->font_family_;
  }

  void fingering::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void fingering::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void fingering::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const fingering::font_style_optional& fingering::
  font_style () const
  {
    return this->font_style_;
  }

  fingering::font_style_optional& fingering::
  font_style ()
  {
    return this->font_style_;
  }

  void fingering::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void fingering::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void fingering::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const fingering::font_size_optional& fingering::
  font_size () const
  {
    return this->font_size_;
  }

  fingering::font_size_optional& fingering::
  font_size ()
  {
    return this->font_size_;
  }

  void fingering::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void fingering::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void fingering::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const fingering::font_weight_optional& fingering::
  font_weight () const
  {
    return this->font_weight_;
  }

  fingering::font_weight_optional& fingering::
  font_weight ()
  {
    return this->font_weight_;
  }

  void fingering::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void fingering::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void fingering::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const fingering::color_optional& fingering::
  color () const
  {
    return this->color_;
  }

  fingering::color_optional& fingering::
  color ()
  {
    return this->color_;
  }

  void fingering::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void fingering::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void fingering::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const fingering::placement_optional& fingering::
  placement () const
  {
    return this->placement_;
  }

  fingering::placement_optional& fingering::
  placement ()
  {
    return this->placement_;
  }

  void fingering::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void fingering::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void fingering::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // formatted_symbol
  // 

  const formatted_symbol::justify_optional& formatted_symbol::
  justify () const
  {
    return this->justify_;
  }

  formatted_symbol::justify_optional& formatted_symbol::
  justify ()
  {
    return this->justify_;
  }

  void formatted_symbol::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void formatted_symbol::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void formatted_symbol::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const formatted_symbol::default_x_optional& formatted_symbol::
  default_x () const
  {
    return this->default_x_;
  }

  formatted_symbol::default_x_optional& formatted_symbol::
  default_x ()
  {
    return this->default_x_;
  }

  void formatted_symbol::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void formatted_symbol::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void formatted_symbol::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const formatted_symbol::default_y_optional& formatted_symbol::
  default_y () const
  {
    return this->default_y_;
  }

  formatted_symbol::default_y_optional& formatted_symbol::
  default_y ()
  {
    return this->default_y_;
  }

  void formatted_symbol::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void formatted_symbol::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void formatted_symbol::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const formatted_symbol::relative_x_optional& formatted_symbol::
  relative_x () const
  {
    return this->relative_x_;
  }

  formatted_symbol::relative_x_optional& formatted_symbol::
  relative_x ()
  {
    return this->relative_x_;
  }

  void formatted_symbol::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void formatted_symbol::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void formatted_symbol::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const formatted_symbol::relative_y_optional& formatted_symbol::
  relative_y () const
  {
    return this->relative_y_;
  }

  formatted_symbol::relative_y_optional& formatted_symbol::
  relative_y ()
  {
    return this->relative_y_;
  }

  void formatted_symbol::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void formatted_symbol::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void formatted_symbol::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const formatted_symbol::font_family_optional& formatted_symbol::
  font_family () const
  {
    return this->font_family_;
  }

  formatted_symbol::font_family_optional& formatted_symbol::
  font_family ()
  {
    return this->font_family_;
  }

  void formatted_symbol::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void formatted_symbol::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void formatted_symbol::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const formatted_symbol::font_style_optional& formatted_symbol::
  font_style () const
  {
    return this->font_style_;
  }

  formatted_symbol::font_style_optional& formatted_symbol::
  font_style ()
  {
    return this->font_style_;
  }

  void formatted_symbol::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void formatted_symbol::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void formatted_symbol::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const formatted_symbol::font_size_optional& formatted_symbol::
  font_size () const
  {
    return this->font_size_;
  }

  formatted_symbol::font_size_optional& formatted_symbol::
  font_size ()
  {
    return this->font_size_;
  }

  void formatted_symbol::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void formatted_symbol::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void formatted_symbol::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const formatted_symbol::font_weight_optional& formatted_symbol::
  font_weight () const
  {
    return this->font_weight_;
  }

  formatted_symbol::font_weight_optional& formatted_symbol::
  font_weight ()
  {
    return this->font_weight_;
  }

  void formatted_symbol::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void formatted_symbol::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void formatted_symbol::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const formatted_symbol::color_optional& formatted_symbol::
  color () const
  {
    return this->color_;
  }

  formatted_symbol::color_optional& formatted_symbol::
  color ()
  {
    return this->color_;
  }

  void formatted_symbol::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void formatted_symbol::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void formatted_symbol::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const formatted_symbol::halign_optional& formatted_symbol::
  halign () const
  {
    return this->halign_;
  }

  formatted_symbol::halign_optional& formatted_symbol::
  halign ()
  {
    return this->halign_;
  }

  void formatted_symbol::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void formatted_symbol::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void formatted_symbol::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const formatted_symbol::valign_optional& formatted_symbol::
  valign () const
  {
    return this->valign_;
  }

  formatted_symbol::valign_optional& formatted_symbol::
  valign ()
  {
    return this->valign_;
  }

  void formatted_symbol::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void formatted_symbol::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void formatted_symbol::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const formatted_symbol::underline_optional& formatted_symbol::
  underline () const
  {
    return this->underline_;
  }

  formatted_symbol::underline_optional& formatted_symbol::
  underline ()
  {
    return this->underline_;
  }

  void formatted_symbol::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void formatted_symbol::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void formatted_symbol::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const formatted_symbol::overline_optional& formatted_symbol::
  overline () const
  {
    return this->overline_;
  }

  formatted_symbol::overline_optional& formatted_symbol::
  overline ()
  {
    return this->overline_;
  }

  void formatted_symbol::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void formatted_symbol::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void formatted_symbol::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const formatted_symbol::line_through_optional& formatted_symbol::
  line_through () const
  {
    return this->line_through_;
  }

  formatted_symbol::line_through_optional& formatted_symbol::
  line_through ()
  {
    return this->line_through_;
  }

  void formatted_symbol::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void formatted_symbol::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void formatted_symbol::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const formatted_symbol::rotation_optional& formatted_symbol::
  rotation () const
  {
    return this->rotation_;
  }

  formatted_symbol::rotation_optional& formatted_symbol::
  rotation ()
  {
    return this->rotation_;
  }

  void formatted_symbol::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void formatted_symbol::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void formatted_symbol::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const formatted_symbol::letter_spacing_optional& formatted_symbol::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  formatted_symbol::letter_spacing_optional& formatted_symbol::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void formatted_symbol::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void formatted_symbol::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void formatted_symbol::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const formatted_symbol::line_height_optional& formatted_symbol::
  line_height () const
  {
    return this->line_height_;
  }

  formatted_symbol::line_height_optional& formatted_symbol::
  line_height ()
  {
    return this->line_height_;
  }

  void formatted_symbol::
  line_height (const line_height_type& x)
  {
    this->line_height_.set (x);
  }

  void formatted_symbol::
  line_height (const line_height_optional& x)
  {
    this->line_height_ = x;
  }

  void formatted_symbol::
  line_height (::std::unique_ptr< line_height_type > x)
  {
    this->line_height_.set (std::move (x));
  }

  const formatted_symbol::dir_optional& formatted_symbol::
  dir () const
  {
    return this->dir_;
  }

  formatted_symbol::dir_optional& formatted_symbol::
  dir ()
  {
    return this->dir_;
  }

  void formatted_symbol::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void formatted_symbol::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void formatted_symbol::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }

  const formatted_symbol::enclosure_optional& formatted_symbol::
  enclosure () const
  {
    return this->enclosure_;
  }

  formatted_symbol::enclosure_optional& formatted_symbol::
  enclosure ()
  {
    return this->enclosure_;
  }

  void formatted_symbol::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void formatted_symbol::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void formatted_symbol::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }


  // formatted_symbol_id
  // 

  const formatted_symbol_id::justify_optional& formatted_symbol_id::
  justify () const
  {
    return this->justify_;
  }

  formatted_symbol_id::justify_optional& formatted_symbol_id::
  justify ()
  {
    return this->justify_;
  }

  void formatted_symbol_id::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void formatted_symbol_id::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void formatted_symbol_id::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const formatted_symbol_id::default_x_optional& formatted_symbol_id::
  default_x () const
  {
    return this->default_x_;
  }

  formatted_symbol_id::default_x_optional& formatted_symbol_id::
  default_x ()
  {
    return this->default_x_;
  }

  void formatted_symbol_id::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void formatted_symbol_id::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void formatted_symbol_id::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const formatted_symbol_id::default_y_optional& formatted_symbol_id::
  default_y () const
  {
    return this->default_y_;
  }

  formatted_symbol_id::default_y_optional& formatted_symbol_id::
  default_y ()
  {
    return this->default_y_;
  }

  void formatted_symbol_id::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void formatted_symbol_id::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void formatted_symbol_id::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const formatted_symbol_id::relative_x_optional& formatted_symbol_id::
  relative_x () const
  {
    return this->relative_x_;
  }

  formatted_symbol_id::relative_x_optional& formatted_symbol_id::
  relative_x ()
  {
    return this->relative_x_;
  }

  void formatted_symbol_id::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void formatted_symbol_id::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void formatted_symbol_id::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const formatted_symbol_id::relative_y_optional& formatted_symbol_id::
  relative_y () const
  {
    return this->relative_y_;
  }

  formatted_symbol_id::relative_y_optional& formatted_symbol_id::
  relative_y ()
  {
    return this->relative_y_;
  }

  void formatted_symbol_id::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void formatted_symbol_id::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void formatted_symbol_id::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const formatted_symbol_id::font_family_optional& formatted_symbol_id::
  font_family () const
  {
    return this->font_family_;
  }

  formatted_symbol_id::font_family_optional& formatted_symbol_id::
  font_family ()
  {
    return this->font_family_;
  }

  void formatted_symbol_id::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void formatted_symbol_id::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void formatted_symbol_id::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const formatted_symbol_id::font_style_optional& formatted_symbol_id::
  font_style () const
  {
    return this->font_style_;
  }

  formatted_symbol_id::font_style_optional& formatted_symbol_id::
  font_style ()
  {
    return this->font_style_;
  }

  void formatted_symbol_id::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void formatted_symbol_id::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void formatted_symbol_id::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const formatted_symbol_id::font_size_optional& formatted_symbol_id::
  font_size () const
  {
    return this->font_size_;
  }

  formatted_symbol_id::font_size_optional& formatted_symbol_id::
  font_size ()
  {
    return this->font_size_;
  }

  void formatted_symbol_id::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void formatted_symbol_id::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void formatted_symbol_id::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const formatted_symbol_id::font_weight_optional& formatted_symbol_id::
  font_weight () const
  {
    return this->font_weight_;
  }

  formatted_symbol_id::font_weight_optional& formatted_symbol_id::
  font_weight ()
  {
    return this->font_weight_;
  }

  void formatted_symbol_id::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void formatted_symbol_id::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void formatted_symbol_id::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const formatted_symbol_id::color_optional& formatted_symbol_id::
  color () const
  {
    return this->color_;
  }

  formatted_symbol_id::color_optional& formatted_symbol_id::
  color ()
  {
    return this->color_;
  }

  void formatted_symbol_id::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void formatted_symbol_id::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void formatted_symbol_id::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const formatted_symbol_id::halign_optional& formatted_symbol_id::
  halign () const
  {
    return this->halign_;
  }

  formatted_symbol_id::halign_optional& formatted_symbol_id::
  halign ()
  {
    return this->halign_;
  }

  void formatted_symbol_id::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void formatted_symbol_id::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void formatted_symbol_id::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const formatted_symbol_id::valign_optional& formatted_symbol_id::
  valign () const
  {
    return this->valign_;
  }

  formatted_symbol_id::valign_optional& formatted_symbol_id::
  valign ()
  {
    return this->valign_;
  }

  void formatted_symbol_id::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void formatted_symbol_id::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void formatted_symbol_id::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const formatted_symbol_id::underline_optional& formatted_symbol_id::
  underline () const
  {
    return this->underline_;
  }

  formatted_symbol_id::underline_optional& formatted_symbol_id::
  underline ()
  {
    return this->underline_;
  }

  void formatted_symbol_id::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void formatted_symbol_id::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void formatted_symbol_id::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const formatted_symbol_id::overline_optional& formatted_symbol_id::
  overline () const
  {
    return this->overline_;
  }

  formatted_symbol_id::overline_optional& formatted_symbol_id::
  overline ()
  {
    return this->overline_;
  }

  void formatted_symbol_id::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void formatted_symbol_id::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void formatted_symbol_id::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const formatted_symbol_id::line_through_optional& formatted_symbol_id::
  line_through () const
  {
    return this->line_through_;
  }

  formatted_symbol_id::line_through_optional& formatted_symbol_id::
  line_through ()
  {
    return this->line_through_;
  }

  void formatted_symbol_id::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void formatted_symbol_id::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void formatted_symbol_id::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const formatted_symbol_id::rotation_optional& formatted_symbol_id::
  rotation () const
  {
    return this->rotation_;
  }

  formatted_symbol_id::rotation_optional& formatted_symbol_id::
  rotation ()
  {
    return this->rotation_;
  }

  void formatted_symbol_id::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void formatted_symbol_id::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void formatted_symbol_id::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const formatted_symbol_id::letter_spacing_optional& formatted_symbol_id::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  formatted_symbol_id::letter_spacing_optional& formatted_symbol_id::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void formatted_symbol_id::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void formatted_symbol_id::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void formatted_symbol_id::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const formatted_symbol_id::line_height_optional& formatted_symbol_id::
  line_height () const
  {
    return this->line_height_;
  }

  formatted_symbol_id::line_height_optional& formatted_symbol_id::
  line_height ()
  {
    return this->line_height_;
  }

  void formatted_symbol_id::
  line_height (const line_height_type& x)
  {
    this->line_height_.set (x);
  }

  void formatted_symbol_id::
  line_height (const line_height_optional& x)
  {
    this->line_height_ = x;
  }

  void formatted_symbol_id::
  line_height (::std::unique_ptr< line_height_type > x)
  {
    this->line_height_.set (std::move (x));
  }

  const formatted_symbol_id::dir_optional& formatted_symbol_id::
  dir () const
  {
    return this->dir_;
  }

  formatted_symbol_id::dir_optional& formatted_symbol_id::
  dir ()
  {
    return this->dir_;
  }

  void formatted_symbol_id::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void formatted_symbol_id::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void formatted_symbol_id::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }

  const formatted_symbol_id::enclosure_optional& formatted_symbol_id::
  enclosure () const
  {
    return this->enclosure_;
  }

  formatted_symbol_id::enclosure_optional& formatted_symbol_id::
  enclosure ()
  {
    return this->enclosure_;
  }

  void formatted_symbol_id::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void formatted_symbol_id::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void formatted_symbol_id::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }

  const formatted_symbol_id::id_optional& formatted_symbol_id::
  id () const
  {
    return this->id_;
  }

  formatted_symbol_id::id_optional& formatted_symbol_id::
  id ()
  {
    return this->id_;
  }

  void formatted_symbol_id::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void formatted_symbol_id::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void formatted_symbol_id::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // formatted_text
  // 

  const formatted_text::justify_optional& formatted_text::
  justify () const
  {
    return this->justify_;
  }

  formatted_text::justify_optional& formatted_text::
  justify ()
  {
    return this->justify_;
  }

  void formatted_text::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void formatted_text::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void formatted_text::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const formatted_text::default_x_optional& formatted_text::
  default_x () const
  {
    return this->default_x_;
  }

  formatted_text::default_x_optional& formatted_text::
  default_x ()
  {
    return this->default_x_;
  }

  void formatted_text::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void formatted_text::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void formatted_text::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const formatted_text::default_y_optional& formatted_text::
  default_y () const
  {
    return this->default_y_;
  }

  formatted_text::default_y_optional& formatted_text::
  default_y ()
  {
    return this->default_y_;
  }

  void formatted_text::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void formatted_text::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void formatted_text::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const formatted_text::relative_x_optional& formatted_text::
  relative_x () const
  {
    return this->relative_x_;
  }

  formatted_text::relative_x_optional& formatted_text::
  relative_x ()
  {
    return this->relative_x_;
  }

  void formatted_text::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void formatted_text::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void formatted_text::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const formatted_text::relative_y_optional& formatted_text::
  relative_y () const
  {
    return this->relative_y_;
  }

  formatted_text::relative_y_optional& formatted_text::
  relative_y ()
  {
    return this->relative_y_;
  }

  void formatted_text::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void formatted_text::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void formatted_text::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const formatted_text::font_family_optional& formatted_text::
  font_family () const
  {
    return this->font_family_;
  }

  formatted_text::font_family_optional& formatted_text::
  font_family ()
  {
    return this->font_family_;
  }

  void formatted_text::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void formatted_text::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void formatted_text::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const formatted_text::font_style_optional& formatted_text::
  font_style () const
  {
    return this->font_style_;
  }

  formatted_text::font_style_optional& formatted_text::
  font_style ()
  {
    return this->font_style_;
  }

  void formatted_text::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void formatted_text::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void formatted_text::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const formatted_text::font_size_optional& formatted_text::
  font_size () const
  {
    return this->font_size_;
  }

  formatted_text::font_size_optional& formatted_text::
  font_size ()
  {
    return this->font_size_;
  }

  void formatted_text::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void formatted_text::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void formatted_text::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const formatted_text::font_weight_optional& formatted_text::
  font_weight () const
  {
    return this->font_weight_;
  }

  formatted_text::font_weight_optional& formatted_text::
  font_weight ()
  {
    return this->font_weight_;
  }

  void formatted_text::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void formatted_text::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void formatted_text::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const formatted_text::color_optional& formatted_text::
  color () const
  {
    return this->color_;
  }

  formatted_text::color_optional& formatted_text::
  color ()
  {
    return this->color_;
  }

  void formatted_text::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void formatted_text::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void formatted_text::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const formatted_text::halign_optional& formatted_text::
  halign () const
  {
    return this->halign_;
  }

  formatted_text::halign_optional& formatted_text::
  halign ()
  {
    return this->halign_;
  }

  void formatted_text::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void formatted_text::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void formatted_text::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const formatted_text::valign_optional& formatted_text::
  valign () const
  {
    return this->valign_;
  }

  formatted_text::valign_optional& formatted_text::
  valign ()
  {
    return this->valign_;
  }

  void formatted_text::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void formatted_text::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void formatted_text::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const formatted_text::underline_optional& formatted_text::
  underline () const
  {
    return this->underline_;
  }

  formatted_text::underline_optional& formatted_text::
  underline ()
  {
    return this->underline_;
  }

  void formatted_text::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void formatted_text::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void formatted_text::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const formatted_text::overline_optional& formatted_text::
  overline () const
  {
    return this->overline_;
  }

  formatted_text::overline_optional& formatted_text::
  overline ()
  {
    return this->overline_;
  }

  void formatted_text::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void formatted_text::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void formatted_text::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const formatted_text::line_through_optional& formatted_text::
  line_through () const
  {
    return this->line_through_;
  }

  formatted_text::line_through_optional& formatted_text::
  line_through ()
  {
    return this->line_through_;
  }

  void formatted_text::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void formatted_text::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void formatted_text::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const formatted_text::rotation_optional& formatted_text::
  rotation () const
  {
    return this->rotation_;
  }

  formatted_text::rotation_optional& formatted_text::
  rotation ()
  {
    return this->rotation_;
  }

  void formatted_text::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void formatted_text::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void formatted_text::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const formatted_text::letter_spacing_optional& formatted_text::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  formatted_text::letter_spacing_optional& formatted_text::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void formatted_text::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void formatted_text::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void formatted_text::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const formatted_text::line_height_optional& formatted_text::
  line_height () const
  {
    return this->line_height_;
  }

  formatted_text::line_height_optional& formatted_text::
  line_height ()
  {
    return this->line_height_;
  }

  void formatted_text::
  line_height (const line_height_type& x)
  {
    this->line_height_.set (x);
  }

  void formatted_text::
  line_height (const line_height_optional& x)
  {
    this->line_height_ = x;
  }

  void formatted_text::
  line_height (::std::unique_ptr< line_height_type > x)
  {
    this->line_height_.set (std::move (x));
  }

  const formatted_text::lang_optional& formatted_text::
  lang () const
  {
    return this->lang_;
  }

  formatted_text::lang_optional& formatted_text::
  lang ()
  {
    return this->lang_;
  }

  void formatted_text::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void formatted_text::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void formatted_text::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }

  const formatted_text::space_optional& formatted_text::
  space () const
  {
    return this->space_;
  }

  formatted_text::space_optional& formatted_text::
  space ()
  {
    return this->space_;
  }

  void formatted_text::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void formatted_text::
  space (const space_optional& x)
  {
    this->space_ = x;
  }

  void formatted_text::
  space (::std::unique_ptr< space_type > x)
  {
    this->space_.set (std::move (x));
  }

  const formatted_text::dir_optional& formatted_text::
  dir () const
  {
    return this->dir_;
  }

  formatted_text::dir_optional& formatted_text::
  dir ()
  {
    return this->dir_;
  }

  void formatted_text::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void formatted_text::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void formatted_text::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }

  const formatted_text::enclosure_optional& formatted_text::
  enclosure () const
  {
    return this->enclosure_;
  }

  formatted_text::enclosure_optional& formatted_text::
  enclosure ()
  {
    return this->enclosure_;
  }

  void formatted_text::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void formatted_text::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void formatted_text::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }


  // formatted_text_id
  // 

  const formatted_text_id::justify_optional& formatted_text_id::
  justify () const
  {
    return this->justify_;
  }

  formatted_text_id::justify_optional& formatted_text_id::
  justify ()
  {
    return this->justify_;
  }

  void formatted_text_id::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void formatted_text_id::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void formatted_text_id::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const formatted_text_id::default_x_optional& formatted_text_id::
  default_x () const
  {
    return this->default_x_;
  }

  formatted_text_id::default_x_optional& formatted_text_id::
  default_x ()
  {
    return this->default_x_;
  }

  void formatted_text_id::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void formatted_text_id::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void formatted_text_id::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const formatted_text_id::default_y_optional& formatted_text_id::
  default_y () const
  {
    return this->default_y_;
  }

  formatted_text_id::default_y_optional& formatted_text_id::
  default_y ()
  {
    return this->default_y_;
  }

  void formatted_text_id::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void formatted_text_id::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void formatted_text_id::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const formatted_text_id::relative_x_optional& formatted_text_id::
  relative_x () const
  {
    return this->relative_x_;
  }

  formatted_text_id::relative_x_optional& formatted_text_id::
  relative_x ()
  {
    return this->relative_x_;
  }

  void formatted_text_id::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void formatted_text_id::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void formatted_text_id::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const formatted_text_id::relative_y_optional& formatted_text_id::
  relative_y () const
  {
    return this->relative_y_;
  }

  formatted_text_id::relative_y_optional& formatted_text_id::
  relative_y ()
  {
    return this->relative_y_;
  }

  void formatted_text_id::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void formatted_text_id::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void formatted_text_id::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const formatted_text_id::font_family_optional& formatted_text_id::
  font_family () const
  {
    return this->font_family_;
  }

  formatted_text_id::font_family_optional& formatted_text_id::
  font_family ()
  {
    return this->font_family_;
  }

  void formatted_text_id::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void formatted_text_id::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void formatted_text_id::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const formatted_text_id::font_style_optional& formatted_text_id::
  font_style () const
  {
    return this->font_style_;
  }

  formatted_text_id::font_style_optional& formatted_text_id::
  font_style ()
  {
    return this->font_style_;
  }

  void formatted_text_id::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void formatted_text_id::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void formatted_text_id::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const formatted_text_id::font_size_optional& formatted_text_id::
  font_size () const
  {
    return this->font_size_;
  }

  formatted_text_id::font_size_optional& formatted_text_id::
  font_size ()
  {
    return this->font_size_;
  }

  void formatted_text_id::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void formatted_text_id::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void formatted_text_id::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const formatted_text_id::font_weight_optional& formatted_text_id::
  font_weight () const
  {
    return this->font_weight_;
  }

  formatted_text_id::font_weight_optional& formatted_text_id::
  font_weight ()
  {
    return this->font_weight_;
  }

  void formatted_text_id::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void formatted_text_id::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void formatted_text_id::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const formatted_text_id::color_optional& formatted_text_id::
  color () const
  {
    return this->color_;
  }

  formatted_text_id::color_optional& formatted_text_id::
  color ()
  {
    return this->color_;
  }

  void formatted_text_id::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void formatted_text_id::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void formatted_text_id::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const formatted_text_id::halign_optional& formatted_text_id::
  halign () const
  {
    return this->halign_;
  }

  formatted_text_id::halign_optional& formatted_text_id::
  halign ()
  {
    return this->halign_;
  }

  void formatted_text_id::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void formatted_text_id::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void formatted_text_id::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const formatted_text_id::valign_optional& formatted_text_id::
  valign () const
  {
    return this->valign_;
  }

  formatted_text_id::valign_optional& formatted_text_id::
  valign ()
  {
    return this->valign_;
  }

  void formatted_text_id::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void formatted_text_id::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void formatted_text_id::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const formatted_text_id::underline_optional& formatted_text_id::
  underline () const
  {
    return this->underline_;
  }

  formatted_text_id::underline_optional& formatted_text_id::
  underline ()
  {
    return this->underline_;
  }

  void formatted_text_id::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void formatted_text_id::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void formatted_text_id::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const formatted_text_id::overline_optional& formatted_text_id::
  overline () const
  {
    return this->overline_;
  }

  formatted_text_id::overline_optional& formatted_text_id::
  overline ()
  {
    return this->overline_;
  }

  void formatted_text_id::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void formatted_text_id::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void formatted_text_id::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const formatted_text_id::line_through_optional& formatted_text_id::
  line_through () const
  {
    return this->line_through_;
  }

  formatted_text_id::line_through_optional& formatted_text_id::
  line_through ()
  {
    return this->line_through_;
  }

  void formatted_text_id::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void formatted_text_id::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void formatted_text_id::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const formatted_text_id::rotation_optional& formatted_text_id::
  rotation () const
  {
    return this->rotation_;
  }

  formatted_text_id::rotation_optional& formatted_text_id::
  rotation ()
  {
    return this->rotation_;
  }

  void formatted_text_id::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void formatted_text_id::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void formatted_text_id::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const formatted_text_id::letter_spacing_optional& formatted_text_id::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  formatted_text_id::letter_spacing_optional& formatted_text_id::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void formatted_text_id::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void formatted_text_id::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void formatted_text_id::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const formatted_text_id::line_height_optional& formatted_text_id::
  line_height () const
  {
    return this->line_height_;
  }

  formatted_text_id::line_height_optional& formatted_text_id::
  line_height ()
  {
    return this->line_height_;
  }

  void formatted_text_id::
  line_height (const line_height_type& x)
  {
    this->line_height_.set (x);
  }

  void formatted_text_id::
  line_height (const line_height_optional& x)
  {
    this->line_height_ = x;
  }

  void formatted_text_id::
  line_height (::std::unique_ptr< line_height_type > x)
  {
    this->line_height_.set (std::move (x));
  }

  const formatted_text_id::lang_optional& formatted_text_id::
  lang () const
  {
    return this->lang_;
  }

  formatted_text_id::lang_optional& formatted_text_id::
  lang ()
  {
    return this->lang_;
  }

  void formatted_text_id::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void formatted_text_id::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void formatted_text_id::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }

  const formatted_text_id::space_optional& formatted_text_id::
  space () const
  {
    return this->space_;
  }

  formatted_text_id::space_optional& formatted_text_id::
  space ()
  {
    return this->space_;
  }

  void formatted_text_id::
  space (const space_type& x)
  {
    this->space_.set (x);
  }

  void formatted_text_id::
  space (const space_optional& x)
  {
    this->space_ = x;
  }

  void formatted_text_id::
  space (::std::unique_ptr< space_type > x)
  {
    this->space_.set (std::move (x));
  }

  const formatted_text_id::dir_optional& formatted_text_id::
  dir () const
  {
    return this->dir_;
  }

  formatted_text_id::dir_optional& formatted_text_id::
  dir ()
  {
    return this->dir_;
  }

  void formatted_text_id::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void formatted_text_id::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void formatted_text_id::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }

  const formatted_text_id::enclosure_optional& formatted_text_id::
  enclosure () const
  {
    return this->enclosure_;
  }

  formatted_text_id::enclosure_optional& formatted_text_id::
  enclosure ()
  {
    return this->enclosure_;
  }

  void formatted_text_id::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void formatted_text_id::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void formatted_text_id::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }

  const formatted_text_id::id_optional& formatted_text_id::
  id () const
  {
    return this->id_;
  }

  formatted_text_id::id_optional& formatted_text_id::
  id ()
  {
    return this->id_;
  }

  void formatted_text_id::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void formatted_text_id::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void formatted_text_id::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // fret
  // 

  const fret::font_family_optional& fret::
  font_family () const
  {
    return this->font_family_;
  }

  fret::font_family_optional& fret::
  font_family ()
  {
    return this->font_family_;
  }

  void fret::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void fret::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void fret::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const fret::font_style_optional& fret::
  font_style () const
  {
    return this->font_style_;
  }

  fret::font_style_optional& fret::
  font_style ()
  {
    return this->font_style_;
  }

  void fret::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void fret::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void fret::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const fret::font_size_optional& fret::
  font_size () const
  {
    return this->font_size_;
  }

  fret::font_size_optional& fret::
  font_size ()
  {
    return this->font_size_;
  }

  void fret::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void fret::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void fret::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const fret::font_weight_optional& fret::
  font_weight () const
  {
    return this->font_weight_;
  }

  fret::font_weight_optional& fret::
  font_weight ()
  {
    return this->font_weight_;
  }

  void fret::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void fret::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void fret::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const fret::color_optional& fret::
  color () const
  {
    return this->color_;
  }

  fret::color_optional& fret::
  color ()
  {
    return this->color_;
  }

  void fret::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void fret::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void fret::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // level
  // 

  const level::reference_optional& level::
  reference () const
  {
    return this->reference_;
  }

  level::reference_optional& level::
  reference ()
  {
    return this->reference_;
  }

  void level::
  reference (const reference_type& x)
  {
    this->reference_.set (x);
  }

  void level::
  reference (const reference_optional& x)
  {
    this->reference_ = x;
  }

  void level::
  reference (::std::unique_ptr< reference_type > x)
  {
    this->reference_.set (std::move (x));
  }

  const level::type_optional& level::
  type () const
  {
    return this->type_;
  }

  level::type_optional& level::
  type ()
  {
    return this->type_;
  }

  void level::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void level::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void level::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const level::parentheses_optional& level::
  parentheses () const
  {
    return this->parentheses_;
  }

  level::parentheses_optional& level::
  parentheses ()
  {
    return this->parentheses_;
  }

  void level::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void level::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void level::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const level::bracket_optional& level::
  bracket () const
  {
    return this->bracket_;
  }

  level::bracket_optional& level::
  bracket ()
  {
    return this->bracket_;
  }

  void level::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void level::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void level::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const level::size_optional& level::
  size () const
  {
    return this->size_;
  }

  level::size_optional& level::
  size ()
  {
    return this->size_;
  }

  void level::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void level::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void level::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }


  // midi_device
  // 

  const midi_device::port_optional& midi_device::
  port () const
  {
    return this->port_;
  }

  midi_device::port_optional& midi_device::
  port ()
  {
    return this->port_;
  }

  void midi_device::
  port (const port_type& x)
  {
    this->port_.set (x);
  }

  void midi_device::
  port (const port_optional& x)
  {
    this->port_ = x;
  }

  void midi_device::
  port (::std::unique_ptr< port_type > x)
  {
    this->port_.set (std::move (x));
  }

  const midi_device::id_optional& midi_device::
  id () const
  {
    return this->id_;
  }

  midi_device::id_optional& midi_device::
  id ()
  {
    return this->id_;
  }

  void midi_device::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void midi_device::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void midi_device::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // midi_instrument
  // 

  const midi_instrument::midi_channel_optional& midi_instrument::
  midi_channel () const
  {
    return this->midi_channel_;
  }

  midi_instrument::midi_channel_optional& midi_instrument::
  midi_channel ()
  {
    return this->midi_channel_;
  }

  void midi_instrument::
  midi_channel (const midi_channel_type& x)
  {
    this->midi_channel_.set (x);
  }

  void midi_instrument::
  midi_channel (const midi_channel_optional& x)
  {
    this->midi_channel_ = x;
  }

  void midi_instrument::
  midi_channel (::std::unique_ptr< midi_channel_type > x)
  {
    this->midi_channel_.set (std::move (x));
  }

  const midi_instrument::midi_name_optional& midi_instrument::
  midi_name () const
  {
    return this->midi_name_;
  }

  midi_instrument::midi_name_optional& midi_instrument::
  midi_name ()
  {
    return this->midi_name_;
  }

  void midi_instrument::
  midi_name (const midi_name_type& x)
  {
    this->midi_name_.set (x);
  }

  void midi_instrument::
  midi_name (const midi_name_optional& x)
  {
    this->midi_name_ = x;
  }

  void midi_instrument::
  midi_name (::std::unique_ptr< midi_name_type > x)
  {
    this->midi_name_.set (std::move (x));
  }

  const midi_instrument::midi_bank_optional& midi_instrument::
  midi_bank () const
  {
    return this->midi_bank_;
  }

  midi_instrument::midi_bank_optional& midi_instrument::
  midi_bank ()
  {
    return this->midi_bank_;
  }

  void midi_instrument::
  midi_bank (const midi_bank_type& x)
  {
    this->midi_bank_.set (x);
  }

  void midi_instrument::
  midi_bank (const midi_bank_optional& x)
  {
    this->midi_bank_ = x;
  }

  void midi_instrument::
  midi_bank (::std::unique_ptr< midi_bank_type > x)
  {
    this->midi_bank_.set (std::move (x));
  }

  const midi_instrument::midi_program_optional& midi_instrument::
  midi_program () const
  {
    return this->midi_program_;
  }

  midi_instrument::midi_program_optional& midi_instrument::
  midi_program ()
  {
    return this->midi_program_;
  }

  void midi_instrument::
  midi_program (const midi_program_type& x)
  {
    this->midi_program_.set (x);
  }

  void midi_instrument::
  midi_program (const midi_program_optional& x)
  {
    this->midi_program_ = x;
  }

  void midi_instrument::
  midi_program (::std::unique_ptr< midi_program_type > x)
  {
    this->midi_program_.set (std::move (x));
  }

  const midi_instrument::midi_unpitched_optional& midi_instrument::
  midi_unpitched () const
  {
    return this->midi_unpitched_;
  }

  midi_instrument::midi_unpitched_optional& midi_instrument::
  midi_unpitched ()
  {
    return this->midi_unpitched_;
  }

  void midi_instrument::
  midi_unpitched (const midi_unpitched_type& x)
  {
    this->midi_unpitched_.set (x);
  }

  void midi_instrument::
  midi_unpitched (const midi_unpitched_optional& x)
  {
    this->midi_unpitched_ = x;
  }

  void midi_instrument::
  midi_unpitched (::std::unique_ptr< midi_unpitched_type > x)
  {
    this->midi_unpitched_.set (std::move (x));
  }

  const midi_instrument::volume_optional& midi_instrument::
  volume () const
  {
    return this->volume_;
  }

  midi_instrument::volume_optional& midi_instrument::
  volume ()
  {
    return this->volume_;
  }

  void midi_instrument::
  volume (const volume_type& x)
  {
    this->volume_.set (x);
  }

  void midi_instrument::
  volume (const volume_optional& x)
  {
    this->volume_ = x;
  }

  void midi_instrument::
  volume (::std::unique_ptr< volume_type > x)
  {
    this->volume_.set (std::move (x));
  }

  const midi_instrument::pan_optional& midi_instrument::
  pan () const
  {
    return this->pan_;
  }

  midi_instrument::pan_optional& midi_instrument::
  pan ()
  {
    return this->pan_;
  }

  void midi_instrument::
  pan (const pan_type& x)
  {
    this->pan_.set (x);
  }

  void midi_instrument::
  pan (const pan_optional& x)
  {
    this->pan_ = x;
  }

  void midi_instrument::
  pan (::std::unique_ptr< pan_type > x)
  {
    this->pan_.set (std::move (x));
  }

  const midi_instrument::elevation_optional& midi_instrument::
  elevation () const
  {
    return this->elevation_;
  }

  midi_instrument::elevation_optional& midi_instrument::
  elevation ()
  {
    return this->elevation_;
  }

  void midi_instrument::
  elevation (const elevation_type& x)
  {
    this->elevation_.set (x);
  }

  void midi_instrument::
  elevation (const elevation_optional& x)
  {
    this->elevation_ = x;
  }

  void midi_instrument::
  elevation (::std::unique_ptr< elevation_type > x)
  {
    this->elevation_.set (std::move (x));
  }

  const midi_instrument::id_type& midi_instrument::
  id () const
  {
    return this->id_.get ();
  }

  midi_instrument::id_type& midi_instrument::
  id ()
  {
    return this->id_.get ();
  }

  void midi_instrument::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void midi_instrument::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // name_display
  // 

  const name_display::display_text_sequence& name_display::
  display_text () const
  {
    return this->display_text_;
  }

  name_display::display_text_sequence& name_display::
  display_text ()
  {
    return this->display_text_;
  }

  void name_display::
  display_text (const display_text_sequence& s)
  {
    this->display_text_ = s;
  }

  const name_display::accidental_text_sequence& name_display::
  accidental_text () const
  {
    return this->accidental_text_;
  }

  name_display::accidental_text_sequence& name_display::
  accidental_text ()
  {
    return this->accidental_text_;
  }

  void name_display::
  accidental_text (const accidental_text_sequence& s)
  {
    this->accidental_text_ = s;
  }

  const name_display::print_object_optional& name_display::
  print_object () const
  {
    return this->print_object_;
  }

  name_display::print_object_optional& name_display::
  print_object ()
  {
    return this->print_object_;
  }

  void name_display::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void name_display::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void name_display::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }


  // other_play
  // 

  const other_play::type_type& other_play::
  type () const
  {
    return this->type_.get ();
  }

  other_play::type_type& other_play::
  type ()
  {
    return this->type_.get ();
  }

  void other_play::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void other_play::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // play
  // 

  const play::ipa_sequence& play::
  ipa () const
  {
    return this->ipa_;
  }

  play::ipa_sequence& play::
  ipa ()
  {
    return this->ipa_;
  }

  void play::
  ipa (const ipa_sequence& s)
  {
    this->ipa_ = s;
  }

  const play::mute_sequence& play::
  mute () const
  {
    return this->mute_;
  }

  play::mute_sequence& play::
  mute ()
  {
    return this->mute_;
  }

  void play::
  mute (const mute_sequence& s)
  {
    this->mute_ = s;
  }

  const play::semi_pitched_sequence& play::
  semi_pitched () const
  {
    return this->semi_pitched_;
  }

  play::semi_pitched_sequence& play::
  semi_pitched ()
  {
    return this->semi_pitched_;
  }

  void play::
  semi_pitched (const semi_pitched_sequence& s)
  {
    this->semi_pitched_ = s;
  }

  const play::other_play_sequence& play::
  other_play () const
  {
    return this->other_play_;
  }

  play::other_play_sequence& play::
  other_play ()
  {
    return this->other_play_;
  }

  void play::
  other_play (const other_play_sequence& s)
  {
    this->other_play_ = s;
  }

  const play::id_optional& play::
  id () const
  {
    return this->id_;
  }

  play::id_optional& play::
  id ()
  {
    return this->id_;
  }

  void play::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void play::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void play::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // segno
  // 

  const segno::default_x_optional& segno::
  default_x () const
  {
    return this->default_x_;
  }

  segno::default_x_optional& segno::
  default_x ()
  {
    return this->default_x_;
  }

  void segno::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void segno::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void segno::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const segno::default_y_optional& segno::
  default_y () const
  {
    return this->default_y_;
  }

  segno::default_y_optional& segno::
  default_y ()
  {
    return this->default_y_;
  }

  void segno::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void segno::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void segno::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const segno::relative_x_optional& segno::
  relative_x () const
  {
    return this->relative_x_;
  }

  segno::relative_x_optional& segno::
  relative_x ()
  {
    return this->relative_x_;
  }

  void segno::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void segno::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void segno::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const segno::relative_y_optional& segno::
  relative_y () const
  {
    return this->relative_y_;
  }

  segno::relative_y_optional& segno::
  relative_y ()
  {
    return this->relative_y_;
  }

  void segno::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void segno::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void segno::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const segno::font_family_optional& segno::
  font_family () const
  {
    return this->font_family_;
  }

  segno::font_family_optional& segno::
  font_family ()
  {
    return this->font_family_;
  }

  void segno::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void segno::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void segno::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const segno::font_style_optional& segno::
  font_style () const
  {
    return this->font_style_;
  }

  segno::font_style_optional& segno::
  font_style ()
  {
    return this->font_style_;
  }

  void segno::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void segno::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void segno::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const segno::font_size_optional& segno::
  font_size () const
  {
    return this->font_size_;
  }

  segno::font_size_optional& segno::
  font_size ()
  {
    return this->font_size_;
  }

  void segno::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void segno::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void segno::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const segno::font_weight_optional& segno::
  font_weight () const
  {
    return this->font_weight_;
  }

  segno::font_weight_optional& segno::
  font_weight ()
  {
    return this->font_weight_;
  }

  void segno::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void segno::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void segno::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const segno::color_optional& segno::
  color () const
  {
    return this->color_;
  }

  segno::color_optional& segno::
  color ()
  {
    return this->color_;
  }

  void segno::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void segno::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void segno::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const segno::halign_optional& segno::
  halign () const
  {
    return this->halign_;
  }

  segno::halign_optional& segno::
  halign ()
  {
    return this->halign_;
  }

  void segno::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void segno::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void segno::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const segno::valign_optional& segno::
  valign () const
  {
    return this->valign_;
  }

  segno::valign_optional& segno::
  valign ()
  {
    return this->valign_;
  }

  void segno::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void segno::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void segno::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const segno::id_optional& segno::
  id () const
  {
    return this->id_;
  }

  segno::id_optional& segno::
  id ()
  {
    return this->id_;
  }

  void segno::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void segno::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void segno::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const segno::smufl_optional& segno::
  smufl () const
  {
    return this->smufl_;
  }

  segno::smufl_optional& segno::
  smufl ()
  {
    return this->smufl_;
  }

  void segno::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void segno::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void segno::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // string
  // 

  const string::default_x_optional& string::
  default_x () const
  {
    return this->default_x_;
  }

  string::default_x_optional& string::
  default_x ()
  {
    return this->default_x_;
  }

  void string::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void string::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void string::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const string::default_y_optional& string::
  default_y () const
  {
    return this->default_y_;
  }

  string::default_y_optional& string::
  default_y ()
  {
    return this->default_y_;
  }

  void string::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void string::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void string::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const string::relative_x_optional& string::
  relative_x () const
  {
    return this->relative_x_;
  }

  string::relative_x_optional& string::
  relative_x ()
  {
    return this->relative_x_;
  }

  void string::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void string::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void string::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const string::relative_y_optional& string::
  relative_y () const
  {
    return this->relative_y_;
  }

  string::relative_y_optional& string::
  relative_y ()
  {
    return this->relative_y_;
  }

  void string::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void string::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void string::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const string::font_family_optional& string::
  font_family () const
  {
    return this->font_family_;
  }

  string::font_family_optional& string::
  font_family ()
  {
    return this->font_family_;
  }

  void string::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void string::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void string::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const string::font_style_optional& string::
  font_style () const
  {
    return this->font_style_;
  }

  string::font_style_optional& string::
  font_style ()
  {
    return this->font_style_;
  }

  void string::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void string::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void string::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const string::font_size_optional& string::
  font_size () const
  {
    return this->font_size_;
  }

  string::font_size_optional& string::
  font_size ()
  {
    return this->font_size_;
  }

  void string::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void string::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void string::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const string::font_weight_optional& string::
  font_weight () const
  {
    return this->font_weight_;
  }

  string::font_weight_optional& string::
  font_weight ()
  {
    return this->font_weight_;
  }

  void string::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void string::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void string::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const string::color_optional& string::
  color () const
  {
    return this->color_;
  }

  string::color_optional& string::
  color ()
  {
    return this->color_;
  }

  void string::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void string::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void string::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const string::placement_optional& string::
  placement () const
  {
    return this->placement_;
  }

  string::placement_optional& string::
  placement ()
  {
    return this->placement_;
  }

  void string::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void string::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void string::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // typed_text
  // 

  const typed_text::type_optional& typed_text::
  type () const
  {
    return this->type_;
  }

  typed_text::type_optional& typed_text::
  type ()
  {
    return this->type_;
  }

  void typed_text::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void typed_text::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void typed_text::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // wavy_line
  // 

  const wavy_line::type_type& wavy_line::
  type () const
  {
    return this->type_.get ();
  }

  wavy_line::type_type& wavy_line::
  type ()
  {
    return this->type_.get ();
  }

  void wavy_line::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void wavy_line::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const wavy_line::number_optional& wavy_line::
  number () const
  {
    return this->number_;
  }

  wavy_line::number_optional& wavy_line::
  number ()
  {
    return this->number_;
  }

  void wavy_line::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void wavy_line::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void wavy_line::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const wavy_line::smufl_optional& wavy_line::
  smufl () const
  {
    return this->smufl_;
  }

  wavy_line::smufl_optional& wavy_line::
  smufl ()
  {
    return this->smufl_;
  }

  void wavy_line::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void wavy_line::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void wavy_line::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }

  const wavy_line::default_x_optional& wavy_line::
  default_x () const
  {
    return this->default_x_;
  }

  wavy_line::default_x_optional& wavy_line::
  default_x ()
  {
    return this->default_x_;
  }

  void wavy_line::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void wavy_line::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void wavy_line::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const wavy_line::default_y_optional& wavy_line::
  default_y () const
  {
    return this->default_y_;
  }

  wavy_line::default_y_optional& wavy_line::
  default_y ()
  {
    return this->default_y_;
  }

  void wavy_line::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void wavy_line::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void wavy_line::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const wavy_line::relative_x_optional& wavy_line::
  relative_x () const
  {
    return this->relative_x_;
  }

  wavy_line::relative_x_optional& wavy_line::
  relative_x ()
  {
    return this->relative_x_;
  }

  void wavy_line::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void wavy_line::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void wavy_line::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const wavy_line::relative_y_optional& wavy_line::
  relative_y () const
  {
    return this->relative_y_;
  }

  wavy_line::relative_y_optional& wavy_line::
  relative_y ()
  {
    return this->relative_y_;
  }

  void wavy_line::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void wavy_line::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void wavy_line::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const wavy_line::placement_optional& wavy_line::
  placement () const
  {
    return this->placement_;
  }

  wavy_line::placement_optional& wavy_line::
  placement ()
  {
    return this->placement_;
  }

  void wavy_line::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void wavy_line::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void wavy_line::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const wavy_line::color_optional& wavy_line::
  color () const
  {
    return this->color_;
  }

  wavy_line::color_optional& wavy_line::
  color ()
  {
    return this->color_;
  }

  void wavy_line::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void wavy_line::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void wavy_line::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const wavy_line::start_note_optional& wavy_line::
  start_note () const
  {
    return this->start_note_;
  }

  wavy_line::start_note_optional& wavy_line::
  start_note ()
  {
    return this->start_note_;
  }

  void wavy_line::
  start_note (const start_note_type& x)
  {
    this->start_note_.set (x);
  }

  void wavy_line::
  start_note (const start_note_optional& x)
  {
    this->start_note_ = x;
  }

  void wavy_line::
  start_note (::std::unique_ptr< start_note_type > x)
  {
    this->start_note_.set (std::move (x));
  }

  const wavy_line::trill_step_optional& wavy_line::
  trill_step () const
  {
    return this->trill_step_;
  }

  wavy_line::trill_step_optional& wavy_line::
  trill_step ()
  {
    return this->trill_step_;
  }

  void wavy_line::
  trill_step (const trill_step_type& x)
  {
    this->trill_step_.set (x);
  }

  void wavy_line::
  trill_step (const trill_step_optional& x)
  {
    this->trill_step_ = x;
  }

  void wavy_line::
  trill_step (::std::unique_ptr< trill_step_type > x)
  {
    this->trill_step_.set (std::move (x));
  }

  const wavy_line::two_note_turn_optional& wavy_line::
  two_note_turn () const
  {
    return this->two_note_turn_;
  }

  wavy_line::two_note_turn_optional& wavy_line::
  two_note_turn ()
  {
    return this->two_note_turn_;
  }

  void wavy_line::
  two_note_turn (const two_note_turn_type& x)
  {
    this->two_note_turn_.set (x);
  }

  void wavy_line::
  two_note_turn (const two_note_turn_optional& x)
  {
    this->two_note_turn_ = x;
  }

  void wavy_line::
  two_note_turn (::std::unique_ptr< two_note_turn_type > x)
  {
    this->two_note_turn_.set (std::move (x));
  }

  const wavy_line::accelerate_optional& wavy_line::
  accelerate () const
  {
    return this->accelerate_;
  }

  wavy_line::accelerate_optional& wavy_line::
  accelerate ()
  {
    return this->accelerate_;
  }

  void wavy_line::
  accelerate (const accelerate_type& x)
  {
    this->accelerate_.set (x);
  }

  void wavy_line::
  accelerate (const accelerate_optional& x)
  {
    this->accelerate_ = x;
  }

  void wavy_line::
  accelerate (::std::unique_ptr< accelerate_type > x)
  {
    this->accelerate_.set (std::move (x));
  }

  const wavy_line::beats_optional& wavy_line::
  beats () const
  {
    return this->beats_;
  }

  wavy_line::beats_optional& wavy_line::
  beats ()
  {
    return this->beats_;
  }

  void wavy_line::
  beats (const beats_type& x)
  {
    this->beats_.set (x);
  }

  void wavy_line::
  beats (const beats_optional& x)
  {
    this->beats_ = x;
  }

  void wavy_line::
  beats (::std::unique_ptr< beats_type > x)
  {
    this->beats_.set (std::move (x));
  }

  const wavy_line::second_beat_optional& wavy_line::
  second_beat () const
  {
    return this->second_beat_;
  }

  wavy_line::second_beat_optional& wavy_line::
  second_beat ()
  {
    return this->second_beat_;
  }

  void wavy_line::
  second_beat (const second_beat_type& x)
  {
    this->second_beat_.set (x);
  }

  void wavy_line::
  second_beat (const second_beat_optional& x)
  {
    this->second_beat_ = x;
  }

  void wavy_line::
  second_beat (::std::unique_ptr< second_beat_type > x)
  {
    this->second_beat_.set (std::move (x));
  }

  const wavy_line::last_beat_optional& wavy_line::
  last_beat () const
  {
    return this->last_beat_;
  }

  wavy_line::last_beat_optional& wavy_line::
  last_beat ()
  {
    return this->last_beat_;
  }

  void wavy_line::
  last_beat (const last_beat_type& x)
  {
    this->last_beat_.set (x);
  }

  void wavy_line::
  last_beat (const last_beat_optional& x)
  {
    this->last_beat_ = x;
  }

  void wavy_line::
  last_beat (::std::unique_ptr< last_beat_type > x)
  {
    this->last_beat_.set (std::move (x));
  }


  // attributes
  // 

  const attributes::footnote_optional& attributes::
  footnote () const
  {
    return this->footnote_;
  }

  attributes::footnote_optional& attributes::
  footnote ()
  {
    return this->footnote_;
  }

  void attributes::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void attributes::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void attributes::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const attributes::level_optional& attributes::
  level () const
  {
    return this->level_;
  }

  attributes::level_optional& attributes::
  level ()
  {
    return this->level_;
  }

  void attributes::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void attributes::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void attributes::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const attributes::divisions_optional& attributes::
  divisions () const
  {
    return this->divisions_;
  }

  attributes::divisions_optional& attributes::
  divisions ()
  {
    return this->divisions_;
  }

  void attributes::
  divisions (const divisions_type& x)
  {
    this->divisions_.set (x);
  }

  void attributes::
  divisions (const divisions_optional& x)
  {
    this->divisions_ = x;
  }

  void attributes::
  divisions (::std::unique_ptr< divisions_type > x)
  {
    this->divisions_.set (std::move (x));
  }

  const attributes::key_sequence& attributes::
  key () const
  {
    return this->key_;
  }

  attributes::key_sequence& attributes::
  key ()
  {
    return this->key_;
  }

  void attributes::
  key (const key_sequence& s)
  {
    this->key_ = s;
  }

  const attributes::time_sequence& attributes::
  time () const
  {
    return this->time_;
  }

  attributes::time_sequence& attributes::
  time ()
  {
    return this->time_;
  }

  void attributes::
  time (const time_sequence& s)
  {
    this->time_ = s;
  }

  const attributes::staves_optional& attributes::
  staves () const
  {
    return this->staves_;
  }

  attributes::staves_optional& attributes::
  staves ()
  {
    return this->staves_;
  }

  void attributes::
  staves (const staves_type& x)
  {
    this->staves_.set (x);
  }

  void attributes::
  staves (const staves_optional& x)
  {
    this->staves_ = x;
  }

  const attributes::part_symbol_optional& attributes::
  part_symbol () const
  {
    return this->part_symbol_;
  }

  attributes::part_symbol_optional& attributes::
  part_symbol ()
  {
    return this->part_symbol_;
  }

  void attributes::
  part_symbol (const part_symbol_type& x)
  {
    this->part_symbol_.set (x);
  }

  void attributes::
  part_symbol (const part_symbol_optional& x)
  {
    this->part_symbol_ = x;
  }

  void attributes::
  part_symbol (::std::unique_ptr< part_symbol_type > x)
  {
    this->part_symbol_.set (std::move (x));
  }

  const attributes::instruments_optional& attributes::
  instruments () const
  {
    return this->instruments_;
  }

  attributes::instruments_optional& attributes::
  instruments ()
  {
    return this->instruments_;
  }

  void attributes::
  instruments (const instruments_type& x)
  {
    this->instruments_.set (x);
  }

  void attributes::
  instruments (const instruments_optional& x)
  {
    this->instruments_ = x;
  }

  const attributes::clef_sequence& attributes::
  clef () const
  {
    return this->clef_;
  }

  attributes::clef_sequence& attributes::
  clef ()
  {
    return this->clef_;
  }

  void attributes::
  clef (const clef_sequence& s)
  {
    this->clef_ = s;
  }

  const attributes::staff_details_sequence& attributes::
  staff_details () const
  {
    return this->staff_details_;
  }

  attributes::staff_details_sequence& attributes::
  staff_details ()
  {
    return this->staff_details_;
  }

  void attributes::
  staff_details (const staff_details_sequence& s)
  {
    this->staff_details_ = s;
  }

  const attributes::transpose_sequence& attributes::
  transpose () const
  {
    return this->transpose_;
  }

  attributes::transpose_sequence& attributes::
  transpose ()
  {
    return this->transpose_;
  }

  void attributes::
  transpose (const transpose_sequence& s)
  {
    this->transpose_ = s;
  }

  const attributes::for_part_sequence& attributes::
  for_part () const
  {
    return this->for_part_;
  }

  attributes::for_part_sequence& attributes::
  for_part ()
  {
    return this->for_part_;
  }

  void attributes::
  for_part (const for_part_sequence& s)
  {
    this->for_part_ = s;
  }

  const attributes::directive_sequence& attributes::
  directive () const
  {
    return this->directive_;
  }

  attributes::directive_sequence& attributes::
  directive ()
  {
    return this->directive_;
  }

  void attributes::
  directive (const directive_sequence& s)
  {
    this->directive_ = s;
  }

  const attributes::measure_style_sequence& attributes::
  measure_style () const
  {
    return this->measure_style_;
  }

  attributes::measure_style_sequence& attributes::
  measure_style ()
  {
    return this->measure_style_;
  }

  void attributes::
  measure_style (const measure_style_sequence& s)
  {
    this->measure_style_ = s;
  }


  // beat_repeat
  // 

  const beat_repeat::slash_type_optional& beat_repeat::
  slash_type () const
  {
    return this->slash_type_;
  }

  beat_repeat::slash_type_optional& beat_repeat::
  slash_type ()
  {
    return this->slash_type_;
  }

  void beat_repeat::
  slash_type (const slash_type_type& x)
  {
    this->slash_type_.set (x);
  }

  void beat_repeat::
  slash_type (const slash_type_optional& x)
  {
    this->slash_type_ = x;
  }

  void beat_repeat::
  slash_type (::std::unique_ptr< slash_type_type > x)
  {
    this->slash_type_.set (std::move (x));
  }

  const beat_repeat::slash_dot_sequence& beat_repeat::
  slash_dot () const
  {
    return this->slash_dot_;
  }

  beat_repeat::slash_dot_sequence& beat_repeat::
  slash_dot ()
  {
    return this->slash_dot_;
  }

  void beat_repeat::
  slash_dot (const slash_dot_sequence& s)
  {
    this->slash_dot_ = s;
  }

  const beat_repeat::except_voice_sequence& beat_repeat::
  except_voice () const
  {
    return this->except_voice_;
  }

  beat_repeat::except_voice_sequence& beat_repeat::
  except_voice ()
  {
    return this->except_voice_;
  }

  void beat_repeat::
  except_voice (const except_voice_sequence& s)
  {
    this->except_voice_ = s;
  }

  const beat_repeat::type_type& beat_repeat::
  type () const
  {
    return this->type_.get ();
  }

  beat_repeat::type_type& beat_repeat::
  type ()
  {
    return this->type_.get ();
  }

  void beat_repeat::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void beat_repeat::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const beat_repeat::slashes_optional& beat_repeat::
  slashes () const
  {
    return this->slashes_;
  }

  beat_repeat::slashes_optional& beat_repeat::
  slashes ()
  {
    return this->slashes_;
  }

  void beat_repeat::
  slashes (const slashes_type& x)
  {
    this->slashes_.set (x);
  }

  void beat_repeat::
  slashes (const slashes_optional& x)
  {
    this->slashes_ = x;
  }

  const beat_repeat::use_dots_optional& beat_repeat::
  use_dots () const
  {
    return this->use_dots_;
  }

  beat_repeat::use_dots_optional& beat_repeat::
  use_dots ()
  {
    return this->use_dots_;
  }

  void beat_repeat::
  use_dots (const use_dots_type& x)
  {
    this->use_dots_.set (x);
  }

  void beat_repeat::
  use_dots (const use_dots_optional& x)
  {
    this->use_dots_ = x;
  }

  void beat_repeat::
  use_dots (::std::unique_ptr< use_dots_type > x)
  {
    this->use_dots_.set (std::move (x));
  }


  // cancel
  // 

  const cancel::location_optional& cancel::
  location () const
  {
    return this->location_;
  }

  cancel::location_optional& cancel::
  location ()
  {
    return this->location_;
  }

  void cancel::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void cancel::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void cancel::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // clef
  // 

  const clef::sign_type& clef::
  sign () const
  {
    return this->sign_.get ();
  }

  clef::sign_type& clef::
  sign ()
  {
    return this->sign_.get ();
  }

  void clef::
  sign (const sign_type& x)
  {
    this->sign_.set (x);
  }

  void clef::
  sign (::std::unique_ptr< sign_type > x)
  {
    this->sign_.set (std::move (x));
  }

  const clef::line_optional& clef::
  line () const
  {
    return this->line_;
  }

  clef::line_optional& clef::
  line ()
  {
    return this->line_;
  }

  void clef::
  line (const line_type& x)
  {
    this->line_.set (x);
  }

  void clef::
  line (const line_optional& x)
  {
    this->line_ = x;
  }

  void clef::
  line (::std::unique_ptr< line_type > x)
  {
    this->line_.set (std::move (x));
  }

  const clef::clef_octave_change_optional& clef::
  clef_octave_change () const
  {
    return this->clef_octave_change_;
  }

  clef::clef_octave_change_optional& clef::
  clef_octave_change ()
  {
    return this->clef_octave_change_;
  }

  void clef::
  clef_octave_change (const clef_octave_change_type& x)
  {
    this->clef_octave_change_.set (x);
  }

  void clef::
  clef_octave_change (const clef_octave_change_optional& x)
  {
    this->clef_octave_change_ = x;
  }

  const clef::number_optional& clef::
  number () const
  {
    return this->number_;
  }

  clef::number_optional& clef::
  number ()
  {
    return this->number_;
  }

  void clef::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void clef::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void clef::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const clef::additional_optional& clef::
  additional () const
  {
    return this->additional_;
  }

  clef::additional_optional& clef::
  additional ()
  {
    return this->additional_;
  }

  void clef::
  additional (const additional_type& x)
  {
    this->additional_.set (x);
  }

  void clef::
  additional (const additional_optional& x)
  {
    this->additional_ = x;
  }

  void clef::
  additional (::std::unique_ptr< additional_type > x)
  {
    this->additional_.set (std::move (x));
  }

  const clef::size_optional& clef::
  size () const
  {
    return this->size_;
  }

  clef::size_optional& clef::
  size ()
  {
    return this->size_;
  }

  void clef::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void clef::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void clef::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }

  const clef::after_barline_optional& clef::
  after_barline () const
  {
    return this->after_barline_;
  }

  clef::after_barline_optional& clef::
  after_barline ()
  {
    return this->after_barline_;
  }

  void clef::
  after_barline (const after_barline_type& x)
  {
    this->after_barline_.set (x);
  }

  void clef::
  after_barline (const after_barline_optional& x)
  {
    this->after_barline_ = x;
  }

  void clef::
  after_barline (::std::unique_ptr< after_barline_type > x)
  {
    this->after_barline_.set (std::move (x));
  }

  const clef::default_x_optional& clef::
  default_x () const
  {
    return this->default_x_;
  }

  clef::default_x_optional& clef::
  default_x ()
  {
    return this->default_x_;
  }

  void clef::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void clef::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void clef::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const clef::default_y_optional& clef::
  default_y () const
  {
    return this->default_y_;
  }

  clef::default_y_optional& clef::
  default_y ()
  {
    return this->default_y_;
  }

  void clef::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void clef::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void clef::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const clef::relative_x_optional& clef::
  relative_x () const
  {
    return this->relative_x_;
  }

  clef::relative_x_optional& clef::
  relative_x ()
  {
    return this->relative_x_;
  }

  void clef::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void clef::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void clef::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const clef::relative_y_optional& clef::
  relative_y () const
  {
    return this->relative_y_;
  }

  clef::relative_y_optional& clef::
  relative_y ()
  {
    return this->relative_y_;
  }

  void clef::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void clef::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void clef::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const clef::font_family_optional& clef::
  font_family () const
  {
    return this->font_family_;
  }

  clef::font_family_optional& clef::
  font_family ()
  {
    return this->font_family_;
  }

  void clef::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void clef::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void clef::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const clef::font_style_optional& clef::
  font_style () const
  {
    return this->font_style_;
  }

  clef::font_style_optional& clef::
  font_style ()
  {
    return this->font_style_;
  }

  void clef::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void clef::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void clef::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const clef::font_size_optional& clef::
  font_size () const
  {
    return this->font_size_;
  }

  clef::font_size_optional& clef::
  font_size ()
  {
    return this->font_size_;
  }

  void clef::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void clef::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void clef::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const clef::font_weight_optional& clef::
  font_weight () const
  {
    return this->font_weight_;
  }

  clef::font_weight_optional& clef::
  font_weight ()
  {
    return this->font_weight_;
  }

  void clef::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void clef::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void clef::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const clef::color_optional& clef::
  color () const
  {
    return this->color_;
  }

  clef::color_optional& clef::
  color ()
  {
    return this->color_;
  }

  void clef::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void clef::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void clef::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const clef::print_object_optional& clef::
  print_object () const
  {
    return this->print_object_;
  }

  clef::print_object_optional& clef::
  print_object ()
  {
    return this->print_object_;
  }

  void clef::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void clef::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void clef::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const clef::id_optional& clef::
  id () const
  {
    return this->id_;
  }

  clef::id_optional& clef::
  id ()
  {
    return this->id_;
  }

  void clef::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void clef::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void clef::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // double_
  // 

  const double_::above_optional& double_::
  above () const
  {
    return this->above_;
  }

  double_::above_optional& double_::
  above ()
  {
    return this->above_;
  }

  void double_::
  above (const above_type& x)
  {
    this->above_.set (x);
  }

  void double_::
  above (const above_optional& x)
  {
    this->above_ = x;
  }

  void double_::
  above (::std::unique_ptr< above_type > x)
  {
    this->above_.set (std::move (x));
  }


  // for_part
  // 

  const for_part::part_clef_optional& for_part::
  part_clef () const
  {
    return this->part_clef_;
  }

  for_part::part_clef_optional& for_part::
  part_clef ()
  {
    return this->part_clef_;
  }

  void for_part::
  part_clef (const part_clef_type& x)
  {
    this->part_clef_.set (x);
  }

  void for_part::
  part_clef (const part_clef_optional& x)
  {
    this->part_clef_ = x;
  }

  void for_part::
  part_clef (::std::unique_ptr< part_clef_type > x)
  {
    this->part_clef_.set (std::move (x));
  }

  const for_part::part_transpose_type& for_part::
  part_transpose () const
  {
    return this->part_transpose_.get ();
  }

  for_part::part_transpose_type& for_part::
  part_transpose ()
  {
    return this->part_transpose_.get ();
  }

  void for_part::
  part_transpose (const part_transpose_type& x)
  {
    this->part_transpose_.set (x);
  }

  void for_part::
  part_transpose (::std::unique_ptr< part_transpose_type > x)
  {
    this->part_transpose_.set (std::move (x));
  }

  const for_part::number_optional& for_part::
  number () const
  {
    return this->number_;
  }

  for_part::number_optional& for_part::
  number ()
  {
    return this->number_;
  }

  void for_part::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void for_part::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void for_part::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const for_part::id_optional& for_part::
  id () const
  {
    return this->id_;
  }

  for_part::id_optional& for_part::
  id ()
  {
    return this->id_;
  }

  void for_part::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void for_part::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void for_part::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // interchangeable
  // 

  const interchangeable::time_relation_optional& interchangeable::
  time_relation () const
  {
    return this->time_relation_;
  }

  interchangeable::time_relation_optional& interchangeable::
  time_relation ()
  {
    return this->time_relation_;
  }

  void interchangeable::
  time_relation (const time_relation_type& x)
  {
    this->time_relation_.set (x);
  }

  void interchangeable::
  time_relation (const time_relation_optional& x)
  {
    this->time_relation_ = x;
  }

  void interchangeable::
  time_relation (::std::unique_ptr< time_relation_type > x)
  {
    this->time_relation_.set (std::move (x));
  }

  const interchangeable::beats_sequence& interchangeable::
  beats () const
  {
    return this->beats_;
  }

  interchangeable::beats_sequence& interchangeable::
  beats ()
  {
    return this->beats_;
  }

  void interchangeable::
  beats (const beats_sequence& s)
  {
    this->beats_ = s;
  }

  const interchangeable::beat_type_sequence& interchangeable::
  beat_type () const
  {
    return this->beat_type_;
  }

  interchangeable::beat_type_sequence& interchangeable::
  beat_type ()
  {
    return this->beat_type_;
  }

  void interchangeable::
  beat_type (const beat_type_sequence& s)
  {
    this->beat_type_ = s;
  }

  const interchangeable::symbol_optional& interchangeable::
  symbol () const
  {
    return this->symbol_;
  }

  interchangeable::symbol_optional& interchangeable::
  symbol ()
  {
    return this->symbol_;
  }

  void interchangeable::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void interchangeable::
  symbol (const symbol_optional& x)
  {
    this->symbol_ = x;
  }

  void interchangeable::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const interchangeable::separator_optional& interchangeable::
  separator () const
  {
    return this->separator_;
  }

  interchangeable::separator_optional& interchangeable::
  separator ()
  {
    return this->separator_;
  }

  void interchangeable::
  separator (const separator_type& x)
  {
    this->separator_.set (x);
  }

  void interchangeable::
  separator (const separator_optional& x)
  {
    this->separator_ = x;
  }

  void interchangeable::
  separator (::std::unique_ptr< separator_type > x)
  {
    this->separator_.set (std::move (x));
  }


  // key
  // 

  const key::cancel_optional& key::
  cancel () const
  {
    return this->cancel_;
  }

  key::cancel_optional& key::
  cancel ()
  {
    return this->cancel_;
  }

  void key::
  cancel (const cancel_type& x)
  {
    this->cancel_.set (x);
  }

  void key::
  cancel (const cancel_optional& x)
  {
    this->cancel_ = x;
  }

  void key::
  cancel (::std::unique_ptr< cancel_type > x)
  {
    this->cancel_.set (std::move (x));
  }

  const key::fifths_optional& key::
  fifths () const
  {
    return this->fifths_;
  }

  key::fifths_optional& key::
  fifths ()
  {
    return this->fifths_;
  }

  void key::
  fifths (const fifths_type& x)
  {
    this->fifths_.set (x);
  }

  void key::
  fifths (const fifths_optional& x)
  {
    this->fifths_ = x;
  }

  void key::
  fifths (::std::unique_ptr< fifths_type > x)
  {
    this->fifths_.set (std::move (x));
  }

  const key::mode_optional& key::
  mode () const
  {
    return this->mode_;
  }

  key::mode_optional& key::
  mode ()
  {
    return this->mode_;
  }

  void key::
  mode (const mode_type& x)
  {
    this->mode_.set (x);
  }

  void key::
  mode (const mode_optional& x)
  {
    this->mode_ = x;
  }

  void key::
  mode (::std::unique_ptr< mode_type > x)
  {
    this->mode_.set (std::move (x));
  }

  const key::key_step_sequence& key::
  key_step () const
  {
    return this->key_step_;
  }

  key::key_step_sequence& key::
  key_step ()
  {
    return this->key_step_;
  }

  void key::
  key_step (const key_step_sequence& s)
  {
    this->key_step_ = s;
  }

  const key::key_alter_sequence& key::
  key_alter () const
  {
    return this->key_alter_;
  }

  key::key_alter_sequence& key::
  key_alter ()
  {
    return this->key_alter_;
  }

  void key::
  key_alter (const key_alter_sequence& s)
  {
    this->key_alter_ = s;
  }

  const key::key_accidental_sequence& key::
  key_accidental () const
  {
    return this->key_accidental_;
  }

  key::key_accidental_sequence& key::
  key_accidental ()
  {
    return this->key_accidental_;
  }

  void key::
  key_accidental (const key_accidental_sequence& s)
  {
    this->key_accidental_ = s;
  }

  const key::key_octave_sequence& key::
  key_octave () const
  {
    return this->key_octave_;
  }

  key::key_octave_sequence& key::
  key_octave ()
  {
    return this->key_octave_;
  }

  void key::
  key_octave (const key_octave_sequence& s)
  {
    this->key_octave_ = s;
  }

  const key::number_optional& key::
  number () const
  {
    return this->number_;
  }

  key::number_optional& key::
  number ()
  {
    return this->number_;
  }

  void key::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void key::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void key::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const key::default_x_optional& key::
  default_x () const
  {
    return this->default_x_;
  }

  key::default_x_optional& key::
  default_x ()
  {
    return this->default_x_;
  }

  void key::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void key::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void key::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const key::default_y_optional& key::
  default_y () const
  {
    return this->default_y_;
  }

  key::default_y_optional& key::
  default_y ()
  {
    return this->default_y_;
  }

  void key::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void key::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void key::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const key::relative_x_optional& key::
  relative_x () const
  {
    return this->relative_x_;
  }

  key::relative_x_optional& key::
  relative_x ()
  {
    return this->relative_x_;
  }

  void key::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void key::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void key::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const key::relative_y_optional& key::
  relative_y () const
  {
    return this->relative_y_;
  }

  key::relative_y_optional& key::
  relative_y ()
  {
    return this->relative_y_;
  }

  void key::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void key::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void key::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const key::font_family_optional& key::
  font_family () const
  {
    return this->font_family_;
  }

  key::font_family_optional& key::
  font_family ()
  {
    return this->font_family_;
  }

  void key::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void key::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void key::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const key::font_style_optional& key::
  font_style () const
  {
    return this->font_style_;
  }

  key::font_style_optional& key::
  font_style ()
  {
    return this->font_style_;
  }

  void key::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void key::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void key::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const key::font_size_optional& key::
  font_size () const
  {
    return this->font_size_;
  }

  key::font_size_optional& key::
  font_size ()
  {
    return this->font_size_;
  }

  void key::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void key::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void key::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const key::font_weight_optional& key::
  font_weight () const
  {
    return this->font_weight_;
  }

  key::font_weight_optional& key::
  font_weight ()
  {
    return this->font_weight_;
  }

  void key::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void key::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void key::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const key::color_optional& key::
  color () const
  {
    return this->color_;
  }

  key::color_optional& key::
  color ()
  {
    return this->color_;
  }

  void key::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void key::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void key::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const key::print_object_optional& key::
  print_object () const
  {
    return this->print_object_;
  }

  key::print_object_optional& key::
  print_object ()
  {
    return this->print_object_;
  }

  void key::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void key::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void key::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const key::id_optional& key::
  id () const
  {
    return this->id_;
  }

  key::id_optional& key::
  id ()
  {
    return this->id_;
  }

  void key::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void key::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void key::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // key_accidental
  // 

  const key_accidental::smufl_optional& key_accidental::
  smufl () const
  {
    return this->smufl_;
  }

  key_accidental::smufl_optional& key_accidental::
  smufl ()
  {
    return this->smufl_;
  }

  void key_accidental::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void key_accidental::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void key_accidental::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // key_octave
  // 

  const key_octave::number_type& key_octave::
  number () const
  {
    return this->number_.get ();
  }

  key_octave::number_type& key_octave::
  number ()
  {
    return this->number_.get ();
  }

  void key_octave::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  const key_octave::cancel_optional& key_octave::
  cancel () const
  {
    return this->cancel_;
  }

  key_octave::cancel_optional& key_octave::
  cancel ()
  {
    return this->cancel_;
  }

  void key_octave::
  cancel (const cancel_type& x)
  {
    this->cancel_.set (x);
  }

  void key_octave::
  cancel (const cancel_optional& x)
  {
    this->cancel_ = x;
  }

  void key_octave::
  cancel (::std::unique_ptr< cancel_type > x)
  {
    this->cancel_.set (std::move (x));
  }


  // line_detail
  // 

  const line_detail::line_type& line_detail::
  line () const
  {
    return this->line_.get ();
  }

  line_detail::line_type& line_detail::
  line ()
  {
    return this->line_.get ();
  }

  void line_detail::
  line (const line_type& x)
  {
    this->line_.set (x);
  }

  void line_detail::
  line (::std::unique_ptr< line_type > x)
  {
    this->line_.set (std::move (x));
  }

  const line_detail::width_optional& line_detail::
  width () const
  {
    return this->width_;
  }

  line_detail::width_optional& line_detail::
  width ()
  {
    return this->width_;
  }

  void line_detail::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void line_detail::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void line_detail::
  width (::std::unique_ptr< width_type > x)
  {
    this->width_.set (std::move (x));
  }

  const line_detail::color_optional& line_detail::
  color () const
  {
    return this->color_;
  }

  line_detail::color_optional& line_detail::
  color ()
  {
    return this->color_;
  }

  void line_detail::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void line_detail::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void line_detail::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const line_detail::line_type_optional& line_detail::
  line_type1 () const
  {
    return this->line_type_;
  }

  line_detail::line_type_optional& line_detail::
  line_type1 ()
  {
    return this->line_type_;
  }

  void line_detail::
  line_type1 (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void line_detail::
  line_type1 (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void line_detail::
  line_type1 (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const line_detail::print_object_optional& line_detail::
  print_object () const
  {
    return this->print_object_;
  }

  line_detail::print_object_optional& line_detail::
  print_object ()
  {
    return this->print_object_;
  }

  void line_detail::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void line_detail::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void line_detail::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }


  // measure_repeat
  // 

  const measure_repeat::type_type& measure_repeat::
  type () const
  {
    return this->type_.get ();
  }

  measure_repeat::type_type& measure_repeat::
  type ()
  {
    return this->type_.get ();
  }

  void measure_repeat::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void measure_repeat::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const measure_repeat::slashes_optional& measure_repeat::
  slashes () const
  {
    return this->slashes_;
  }

  measure_repeat::slashes_optional& measure_repeat::
  slashes ()
  {
    return this->slashes_;
  }

  void measure_repeat::
  slashes (const slashes_type& x)
  {
    this->slashes_.set (x);
  }

  void measure_repeat::
  slashes (const slashes_optional& x)
  {
    this->slashes_ = x;
  }


  // measure_style
  // 

  const measure_style::multiple_rest_optional& measure_style::
  multiple_rest () const
  {
    return this->multiple_rest_;
  }

  measure_style::multiple_rest_optional& measure_style::
  multiple_rest ()
  {
    return this->multiple_rest_;
  }

  void measure_style::
  multiple_rest (const multiple_rest_type& x)
  {
    this->multiple_rest_.set (x);
  }

  void measure_style::
  multiple_rest (const multiple_rest_optional& x)
  {
    this->multiple_rest_ = x;
  }

  void measure_style::
  multiple_rest (::std::unique_ptr< multiple_rest_type > x)
  {
    this->multiple_rest_.set (std::move (x));
  }

  const measure_style::measure_repeat_optional& measure_style::
  measure_repeat () const
  {
    return this->measure_repeat_;
  }

  measure_style::measure_repeat_optional& measure_style::
  measure_repeat ()
  {
    return this->measure_repeat_;
  }

  void measure_style::
  measure_repeat (const measure_repeat_type& x)
  {
    this->measure_repeat_.set (x);
  }

  void measure_style::
  measure_repeat (const measure_repeat_optional& x)
  {
    this->measure_repeat_ = x;
  }

  void measure_style::
  measure_repeat (::std::unique_ptr< measure_repeat_type > x)
  {
    this->measure_repeat_.set (std::move (x));
  }

  const measure_style::beat_repeat_optional& measure_style::
  beat_repeat () const
  {
    return this->beat_repeat_;
  }

  measure_style::beat_repeat_optional& measure_style::
  beat_repeat ()
  {
    return this->beat_repeat_;
  }

  void measure_style::
  beat_repeat (const beat_repeat_type& x)
  {
    this->beat_repeat_.set (x);
  }

  void measure_style::
  beat_repeat (const beat_repeat_optional& x)
  {
    this->beat_repeat_ = x;
  }

  void measure_style::
  beat_repeat (::std::unique_ptr< beat_repeat_type > x)
  {
    this->beat_repeat_.set (std::move (x));
  }

  const measure_style::slash_optional& measure_style::
  slash () const
  {
    return this->slash_;
  }

  measure_style::slash_optional& measure_style::
  slash ()
  {
    return this->slash_;
  }

  void measure_style::
  slash (const slash_type& x)
  {
    this->slash_.set (x);
  }

  void measure_style::
  slash (const slash_optional& x)
  {
    this->slash_ = x;
  }

  void measure_style::
  slash (::std::unique_ptr< slash_type > x)
  {
    this->slash_.set (std::move (x));
  }

  const measure_style::number_optional& measure_style::
  number () const
  {
    return this->number_;
  }

  measure_style::number_optional& measure_style::
  number ()
  {
    return this->number_;
  }

  void measure_style::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void measure_style::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void measure_style::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const measure_style::font_family_optional& measure_style::
  font_family () const
  {
    return this->font_family_;
  }

  measure_style::font_family_optional& measure_style::
  font_family ()
  {
    return this->font_family_;
  }

  void measure_style::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void measure_style::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void measure_style::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const measure_style::font_style_optional& measure_style::
  font_style () const
  {
    return this->font_style_;
  }

  measure_style::font_style_optional& measure_style::
  font_style ()
  {
    return this->font_style_;
  }

  void measure_style::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void measure_style::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void measure_style::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const measure_style::font_size_optional& measure_style::
  font_size () const
  {
    return this->font_size_;
  }

  measure_style::font_size_optional& measure_style::
  font_size ()
  {
    return this->font_size_;
  }

  void measure_style::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void measure_style::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void measure_style::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const measure_style::font_weight_optional& measure_style::
  font_weight () const
  {
    return this->font_weight_;
  }

  measure_style::font_weight_optional& measure_style::
  font_weight ()
  {
    return this->font_weight_;
  }

  void measure_style::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void measure_style::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void measure_style::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const measure_style::color_optional& measure_style::
  color () const
  {
    return this->color_;
  }

  measure_style::color_optional& measure_style::
  color ()
  {
    return this->color_;
  }

  void measure_style::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void measure_style::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void measure_style::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const measure_style::id_optional& measure_style::
  id () const
  {
    return this->id_;
  }

  measure_style::id_optional& measure_style::
  id ()
  {
    return this->id_;
  }

  void measure_style::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void measure_style::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void measure_style::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // multiple_rest
  // 

  const multiple_rest::use_symbols_optional& multiple_rest::
  use_symbols () const
  {
    return this->use_symbols_;
  }

  multiple_rest::use_symbols_optional& multiple_rest::
  use_symbols ()
  {
    return this->use_symbols_;
  }

  void multiple_rest::
  use_symbols (const use_symbols_type& x)
  {
    this->use_symbols_.set (x);
  }

  void multiple_rest::
  use_symbols (const use_symbols_optional& x)
  {
    this->use_symbols_ = x;
  }

  void multiple_rest::
  use_symbols (::std::unique_ptr< use_symbols_type > x)
  {
    this->use_symbols_.set (std::move (x));
  }


  // part_clef
  // 

  const part_clef::sign_type& part_clef::
  sign () const
  {
    return this->sign_.get ();
  }

  part_clef::sign_type& part_clef::
  sign ()
  {
    return this->sign_.get ();
  }

  void part_clef::
  sign (const sign_type& x)
  {
    this->sign_.set (x);
  }

  void part_clef::
  sign (::std::unique_ptr< sign_type > x)
  {
    this->sign_.set (std::move (x));
  }

  const part_clef::line_optional& part_clef::
  line () const
  {
    return this->line_;
  }

  part_clef::line_optional& part_clef::
  line ()
  {
    return this->line_;
  }

  void part_clef::
  line (const line_type& x)
  {
    this->line_.set (x);
  }

  void part_clef::
  line (const line_optional& x)
  {
    this->line_ = x;
  }

  void part_clef::
  line (::std::unique_ptr< line_type > x)
  {
    this->line_.set (std::move (x));
  }

  const part_clef::clef_octave_change_optional& part_clef::
  clef_octave_change () const
  {
    return this->clef_octave_change_;
  }

  part_clef::clef_octave_change_optional& part_clef::
  clef_octave_change ()
  {
    return this->clef_octave_change_;
  }

  void part_clef::
  clef_octave_change (const clef_octave_change_type& x)
  {
    this->clef_octave_change_.set (x);
  }

  void part_clef::
  clef_octave_change (const clef_octave_change_optional& x)
  {
    this->clef_octave_change_ = x;
  }


  // part_symbol
  // 

  const part_symbol::top_staff_optional& part_symbol::
  top_staff () const
  {
    return this->top_staff_;
  }

  part_symbol::top_staff_optional& part_symbol::
  top_staff ()
  {
    return this->top_staff_;
  }

  void part_symbol::
  top_staff (const top_staff_type& x)
  {
    this->top_staff_.set (x);
  }

  void part_symbol::
  top_staff (const top_staff_optional& x)
  {
    this->top_staff_ = x;
  }

  void part_symbol::
  top_staff (::std::unique_ptr< top_staff_type > x)
  {
    this->top_staff_.set (std::move (x));
  }

  const part_symbol::bottom_staff_optional& part_symbol::
  bottom_staff () const
  {
    return this->bottom_staff_;
  }

  part_symbol::bottom_staff_optional& part_symbol::
  bottom_staff ()
  {
    return this->bottom_staff_;
  }

  void part_symbol::
  bottom_staff (const bottom_staff_type& x)
  {
    this->bottom_staff_.set (x);
  }

  void part_symbol::
  bottom_staff (const bottom_staff_optional& x)
  {
    this->bottom_staff_ = x;
  }

  void part_symbol::
  bottom_staff (::std::unique_ptr< bottom_staff_type > x)
  {
    this->bottom_staff_.set (std::move (x));
  }

  const part_symbol::default_x_optional& part_symbol::
  default_x () const
  {
    return this->default_x_;
  }

  part_symbol::default_x_optional& part_symbol::
  default_x ()
  {
    return this->default_x_;
  }

  void part_symbol::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void part_symbol::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void part_symbol::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const part_symbol::default_y_optional& part_symbol::
  default_y () const
  {
    return this->default_y_;
  }

  part_symbol::default_y_optional& part_symbol::
  default_y ()
  {
    return this->default_y_;
  }

  void part_symbol::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void part_symbol::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void part_symbol::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const part_symbol::relative_x_optional& part_symbol::
  relative_x () const
  {
    return this->relative_x_;
  }

  part_symbol::relative_x_optional& part_symbol::
  relative_x ()
  {
    return this->relative_x_;
  }

  void part_symbol::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void part_symbol::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void part_symbol::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const part_symbol::relative_y_optional& part_symbol::
  relative_y () const
  {
    return this->relative_y_;
  }

  part_symbol::relative_y_optional& part_symbol::
  relative_y ()
  {
    return this->relative_y_;
  }

  void part_symbol::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void part_symbol::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void part_symbol::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const part_symbol::color_optional& part_symbol::
  color () const
  {
    return this->color_;
  }

  part_symbol::color_optional& part_symbol::
  color ()
  {
    return this->color_;
  }

  void part_symbol::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void part_symbol::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void part_symbol::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // part_transpose
  // 

  const part_transpose::diatonic_optional& part_transpose::
  diatonic () const
  {
    return this->diatonic_;
  }

  part_transpose::diatonic_optional& part_transpose::
  diatonic ()
  {
    return this->diatonic_;
  }

  void part_transpose::
  diatonic (const diatonic_type& x)
  {
    this->diatonic_.set (x);
  }

  void part_transpose::
  diatonic (const diatonic_optional& x)
  {
    this->diatonic_ = x;
  }

  const part_transpose::chromatic_type& part_transpose::
  chromatic () const
  {
    return this->chromatic_.get ();
  }

  part_transpose::chromatic_type& part_transpose::
  chromatic ()
  {
    return this->chromatic_.get ();
  }

  void part_transpose::
  chromatic (const chromatic_type& x)
  {
    this->chromatic_.set (x);
  }

  void part_transpose::
  chromatic (::std::unique_ptr< chromatic_type > x)
  {
    this->chromatic_.set (std::move (x));
  }

  const part_transpose::octave_change_optional& part_transpose::
  octave_change () const
  {
    return this->octave_change_;
  }

  part_transpose::octave_change_optional& part_transpose::
  octave_change ()
  {
    return this->octave_change_;
  }

  void part_transpose::
  octave_change (const octave_change_type& x)
  {
    this->octave_change_.set (x);
  }

  void part_transpose::
  octave_change (const octave_change_optional& x)
  {
    this->octave_change_ = x;
  }

  const part_transpose::double_optional& part_transpose::
  double_ () const
  {
    return this->double__;
  }

  part_transpose::double_optional& part_transpose::
  double_ ()
  {
    return this->double__;
  }

  void part_transpose::
  double_ (const double_type& x)
  {
    this->double__.set (x);
  }

  void part_transpose::
  double_ (const double_optional& x)
  {
    this->double__ = x;
  }

  void part_transpose::
  double_ (::std::unique_ptr< double_type > x)
  {
    this->double__.set (std::move (x));
  }


  // slash
  // 

  const slash::slash_type_optional& slash::
  slash_type () const
  {
    return this->slash_type_;
  }

  slash::slash_type_optional& slash::
  slash_type ()
  {
    return this->slash_type_;
  }

  void slash::
  slash_type (const slash_type_type& x)
  {
    this->slash_type_.set (x);
  }

  void slash::
  slash_type (const slash_type_optional& x)
  {
    this->slash_type_ = x;
  }

  void slash::
  slash_type (::std::unique_ptr< slash_type_type > x)
  {
    this->slash_type_.set (std::move (x));
  }

  const slash::slash_dot_sequence& slash::
  slash_dot () const
  {
    return this->slash_dot_;
  }

  slash::slash_dot_sequence& slash::
  slash_dot ()
  {
    return this->slash_dot_;
  }

  void slash::
  slash_dot (const slash_dot_sequence& s)
  {
    this->slash_dot_ = s;
  }

  const slash::except_voice_sequence& slash::
  except_voice () const
  {
    return this->except_voice_;
  }

  slash::except_voice_sequence& slash::
  except_voice ()
  {
    return this->except_voice_;
  }

  void slash::
  except_voice (const except_voice_sequence& s)
  {
    this->except_voice_ = s;
  }

  const slash::type_type& slash::
  type () const
  {
    return this->type_.get ();
  }

  slash::type_type& slash::
  type ()
  {
    return this->type_.get ();
  }

  void slash::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void slash::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const slash::use_dots_optional& slash::
  use_dots () const
  {
    return this->use_dots_;
  }

  slash::use_dots_optional& slash::
  use_dots ()
  {
    return this->use_dots_;
  }

  void slash::
  use_dots (const use_dots_type& x)
  {
    this->use_dots_.set (x);
  }

  void slash::
  use_dots (const use_dots_optional& x)
  {
    this->use_dots_ = x;
  }

  void slash::
  use_dots (::std::unique_ptr< use_dots_type > x)
  {
    this->use_dots_.set (std::move (x));
  }

  const slash::use_stems_optional& slash::
  use_stems () const
  {
    return this->use_stems_;
  }

  slash::use_stems_optional& slash::
  use_stems ()
  {
    return this->use_stems_;
  }

  void slash::
  use_stems (const use_stems_type& x)
  {
    this->use_stems_.set (x);
  }

  void slash::
  use_stems (const use_stems_optional& x)
  {
    this->use_stems_ = x;
  }

  void slash::
  use_stems (::std::unique_ptr< use_stems_type > x)
  {
    this->use_stems_.set (std::move (x));
  }


  // staff_details
  // 

  const staff_details::staff_type_optional& staff_details::
  staff_type () const
  {
    return this->staff_type_;
  }

  staff_details::staff_type_optional& staff_details::
  staff_type ()
  {
    return this->staff_type_;
  }

  void staff_details::
  staff_type (const staff_type_type& x)
  {
    this->staff_type_.set (x);
  }

  void staff_details::
  staff_type (const staff_type_optional& x)
  {
    this->staff_type_ = x;
  }

  void staff_details::
  staff_type (::std::unique_ptr< staff_type_type > x)
  {
    this->staff_type_.set (std::move (x));
  }

  const staff_details::staff_lines_optional& staff_details::
  staff_lines () const
  {
    return this->staff_lines_;
  }

  staff_details::staff_lines_optional& staff_details::
  staff_lines ()
  {
    return this->staff_lines_;
  }

  void staff_details::
  staff_lines (const staff_lines_type& x)
  {
    this->staff_lines_.set (x);
  }

  void staff_details::
  staff_lines (const staff_lines_optional& x)
  {
    this->staff_lines_ = x;
  }

  const staff_details::line_detail_sequence& staff_details::
  line_detail () const
  {
    return this->line_detail_;
  }

  staff_details::line_detail_sequence& staff_details::
  line_detail ()
  {
    return this->line_detail_;
  }

  void staff_details::
  line_detail (const line_detail_sequence& s)
  {
    this->line_detail_ = s;
  }

  const staff_details::staff_tuning_sequence& staff_details::
  staff_tuning () const
  {
    return this->staff_tuning_;
  }

  staff_details::staff_tuning_sequence& staff_details::
  staff_tuning ()
  {
    return this->staff_tuning_;
  }

  void staff_details::
  staff_tuning (const staff_tuning_sequence& s)
  {
    this->staff_tuning_ = s;
  }

  const staff_details::capo_optional& staff_details::
  capo () const
  {
    return this->capo_;
  }

  staff_details::capo_optional& staff_details::
  capo ()
  {
    return this->capo_;
  }

  void staff_details::
  capo (const capo_type& x)
  {
    this->capo_.set (x);
  }

  void staff_details::
  capo (const capo_optional& x)
  {
    this->capo_ = x;
  }

  const staff_details::staff_size_optional& staff_details::
  staff_size () const
  {
    return this->staff_size_;
  }

  staff_details::staff_size_optional& staff_details::
  staff_size ()
  {
    return this->staff_size_;
  }

  void staff_details::
  staff_size (const staff_size_type& x)
  {
    this->staff_size_.set (x);
  }

  void staff_details::
  staff_size (const staff_size_optional& x)
  {
    this->staff_size_ = x;
  }

  void staff_details::
  staff_size (::std::unique_ptr< staff_size_type > x)
  {
    this->staff_size_.set (std::move (x));
  }

  const staff_details::number_optional& staff_details::
  number () const
  {
    return this->number_;
  }

  staff_details::number_optional& staff_details::
  number ()
  {
    return this->number_;
  }

  void staff_details::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void staff_details::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void staff_details::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const staff_details::show_frets_optional& staff_details::
  show_frets () const
  {
    return this->show_frets_;
  }

  staff_details::show_frets_optional& staff_details::
  show_frets ()
  {
    return this->show_frets_;
  }

  void staff_details::
  show_frets (const show_frets_type& x)
  {
    this->show_frets_.set (x);
  }

  void staff_details::
  show_frets (const show_frets_optional& x)
  {
    this->show_frets_ = x;
  }

  void staff_details::
  show_frets (::std::unique_ptr< show_frets_type > x)
  {
    this->show_frets_.set (std::move (x));
  }

  const staff_details::print_object_optional& staff_details::
  print_object () const
  {
    return this->print_object_;
  }

  staff_details::print_object_optional& staff_details::
  print_object ()
  {
    return this->print_object_;
  }

  void staff_details::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void staff_details::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void staff_details::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const staff_details::print_spacing_optional& staff_details::
  print_spacing () const
  {
    return this->print_spacing_;
  }

  staff_details::print_spacing_optional& staff_details::
  print_spacing ()
  {
    return this->print_spacing_;
  }

  void staff_details::
  print_spacing (const print_spacing_type& x)
  {
    this->print_spacing_.set (x);
  }

  void staff_details::
  print_spacing (const print_spacing_optional& x)
  {
    this->print_spacing_ = x;
  }

  void staff_details::
  print_spacing (::std::unique_ptr< print_spacing_type > x)
  {
    this->print_spacing_.set (std::move (x));
  }


  // staff_size
  // 

  const staff_size::scaling_optional& staff_size::
  scaling () const
  {
    return this->scaling_;
  }

  staff_size::scaling_optional& staff_size::
  scaling ()
  {
    return this->scaling_;
  }

  void staff_size::
  scaling (const scaling_type& x)
  {
    this->scaling_.set (x);
  }

  void staff_size::
  scaling (const scaling_optional& x)
  {
    this->scaling_ = x;
  }

  void staff_size::
  scaling (::std::unique_ptr< scaling_type > x)
  {
    this->scaling_.set (std::move (x));
  }


  // staff_tuning
  // 

  const staff_tuning::tuning_step_type& staff_tuning::
  tuning_step () const
  {
    return this->tuning_step_.get ();
  }

  staff_tuning::tuning_step_type& staff_tuning::
  tuning_step ()
  {
    return this->tuning_step_.get ();
  }

  void staff_tuning::
  tuning_step (const tuning_step_type& x)
  {
    this->tuning_step_.set (x);
  }

  void staff_tuning::
  tuning_step (::std::unique_ptr< tuning_step_type > x)
  {
    this->tuning_step_.set (std::move (x));
  }

  const staff_tuning::tuning_alter_optional& staff_tuning::
  tuning_alter () const
  {
    return this->tuning_alter_;
  }

  staff_tuning::tuning_alter_optional& staff_tuning::
  tuning_alter ()
  {
    return this->tuning_alter_;
  }

  void staff_tuning::
  tuning_alter (const tuning_alter_type& x)
  {
    this->tuning_alter_.set (x);
  }

  void staff_tuning::
  tuning_alter (const tuning_alter_optional& x)
  {
    this->tuning_alter_ = x;
  }

  void staff_tuning::
  tuning_alter (::std::unique_ptr< tuning_alter_type > x)
  {
    this->tuning_alter_.set (std::move (x));
  }

  const staff_tuning::tuning_octave_type& staff_tuning::
  tuning_octave () const
  {
    return this->tuning_octave_.get ();
  }

  staff_tuning::tuning_octave_type& staff_tuning::
  tuning_octave ()
  {
    return this->tuning_octave_.get ();
  }

  void staff_tuning::
  tuning_octave (const tuning_octave_type& x)
  {
    this->tuning_octave_.set (x);
  }

  void staff_tuning::
  tuning_octave (::std::unique_ptr< tuning_octave_type > x)
  {
    this->tuning_octave_.set (std::move (x));
  }

  const staff_tuning::line_type& staff_tuning::
  line () const
  {
    return this->line_.get ();
  }

  staff_tuning::line_type& staff_tuning::
  line ()
  {
    return this->line_.get ();
  }

  void staff_tuning::
  line (const line_type& x)
  {
    this->line_.set (x);
  }

  void staff_tuning::
  line (::std::unique_ptr< line_type > x)
  {
    this->line_.set (std::move (x));
  }


  // time
  // 

  const time::beats_sequence& time::
  beats () const
  {
    return this->beats_;
  }

  time::beats_sequence& time::
  beats ()
  {
    return this->beats_;
  }

  void time::
  beats (const beats_sequence& s)
  {
    this->beats_ = s;
  }

  const time::beat_type_sequence& time::
  beat_type () const
  {
    return this->beat_type_;
  }

  time::beat_type_sequence& time::
  beat_type ()
  {
    return this->beat_type_;
  }

  void time::
  beat_type (const beat_type_sequence& s)
  {
    this->beat_type_ = s;
  }

  const time::interchangeable_optional& time::
  interchangeable () const
  {
    return this->interchangeable_;
  }

  time::interchangeable_optional& time::
  interchangeable ()
  {
    return this->interchangeable_;
  }

  void time::
  interchangeable (const interchangeable_type& x)
  {
    this->interchangeable_.set (x);
  }

  void time::
  interchangeable (const interchangeable_optional& x)
  {
    this->interchangeable_ = x;
  }

  void time::
  interchangeable (::std::unique_ptr< interchangeable_type > x)
  {
    this->interchangeable_.set (std::move (x));
  }

  const time::senza_misura_optional& time::
  senza_misura () const
  {
    return this->senza_misura_;
  }

  time::senza_misura_optional& time::
  senza_misura ()
  {
    return this->senza_misura_;
  }

  void time::
  senza_misura (const senza_misura_type& x)
  {
    this->senza_misura_.set (x);
  }

  void time::
  senza_misura (const senza_misura_optional& x)
  {
    this->senza_misura_ = x;
  }

  void time::
  senza_misura (::std::unique_ptr< senza_misura_type > x)
  {
    this->senza_misura_.set (std::move (x));
  }

  const time::number_optional& time::
  number () const
  {
    return this->number_;
  }

  time::number_optional& time::
  number ()
  {
    return this->number_;
  }

  void time::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void time::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void time::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const time::symbol_optional& time::
  symbol () const
  {
    return this->symbol_;
  }

  time::symbol_optional& time::
  symbol ()
  {
    return this->symbol_;
  }

  void time::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void time::
  symbol (const symbol_optional& x)
  {
    this->symbol_ = x;
  }

  void time::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const time::separator_optional& time::
  separator () const
  {
    return this->separator_;
  }

  time::separator_optional& time::
  separator ()
  {
    return this->separator_;
  }

  void time::
  separator (const separator_type& x)
  {
    this->separator_.set (x);
  }

  void time::
  separator (const separator_optional& x)
  {
    this->separator_ = x;
  }

  void time::
  separator (::std::unique_ptr< separator_type > x)
  {
    this->separator_.set (std::move (x));
  }

  const time::default_x_optional& time::
  default_x () const
  {
    return this->default_x_;
  }

  time::default_x_optional& time::
  default_x ()
  {
    return this->default_x_;
  }

  void time::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void time::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void time::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const time::default_y_optional& time::
  default_y () const
  {
    return this->default_y_;
  }

  time::default_y_optional& time::
  default_y ()
  {
    return this->default_y_;
  }

  void time::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void time::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void time::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const time::relative_x_optional& time::
  relative_x () const
  {
    return this->relative_x_;
  }

  time::relative_x_optional& time::
  relative_x ()
  {
    return this->relative_x_;
  }

  void time::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void time::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void time::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const time::relative_y_optional& time::
  relative_y () const
  {
    return this->relative_y_;
  }

  time::relative_y_optional& time::
  relative_y ()
  {
    return this->relative_y_;
  }

  void time::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void time::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void time::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const time::font_family_optional& time::
  font_family () const
  {
    return this->font_family_;
  }

  time::font_family_optional& time::
  font_family ()
  {
    return this->font_family_;
  }

  void time::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void time::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void time::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const time::font_style_optional& time::
  font_style () const
  {
    return this->font_style_;
  }

  time::font_style_optional& time::
  font_style ()
  {
    return this->font_style_;
  }

  void time::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void time::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void time::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const time::font_size_optional& time::
  font_size () const
  {
    return this->font_size_;
  }

  time::font_size_optional& time::
  font_size ()
  {
    return this->font_size_;
  }

  void time::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void time::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void time::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const time::font_weight_optional& time::
  font_weight () const
  {
    return this->font_weight_;
  }

  time::font_weight_optional& time::
  font_weight ()
  {
    return this->font_weight_;
  }

  void time::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void time::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void time::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const time::color_optional& time::
  color () const
  {
    return this->color_;
  }

  time::color_optional& time::
  color ()
  {
    return this->color_;
  }

  void time::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void time::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void time::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const time::halign_optional& time::
  halign () const
  {
    return this->halign_;
  }

  time::halign_optional& time::
  halign ()
  {
    return this->halign_;
  }

  void time::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void time::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void time::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const time::valign_optional& time::
  valign () const
  {
    return this->valign_;
  }

  time::valign_optional& time::
  valign ()
  {
    return this->valign_;
  }

  void time::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void time::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void time::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const time::print_object_optional& time::
  print_object () const
  {
    return this->print_object_;
  }

  time::print_object_optional& time::
  print_object ()
  {
    return this->print_object_;
  }

  void time::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void time::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void time::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const time::id_optional& time::
  id () const
  {
    return this->id_;
  }

  time::id_optional& time::
  id ()
  {
    return this->id_;
  }

  void time::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void time::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void time::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // transpose
  // 

  const transpose::diatonic_optional& transpose::
  diatonic () const
  {
    return this->diatonic_;
  }

  transpose::diatonic_optional& transpose::
  diatonic ()
  {
    return this->diatonic_;
  }

  void transpose::
  diatonic (const diatonic_type& x)
  {
    this->diatonic_.set (x);
  }

  void transpose::
  diatonic (const diatonic_optional& x)
  {
    this->diatonic_ = x;
  }

  const transpose::chromatic_type& transpose::
  chromatic () const
  {
    return this->chromatic_.get ();
  }

  transpose::chromatic_type& transpose::
  chromatic ()
  {
    return this->chromatic_.get ();
  }

  void transpose::
  chromatic (const chromatic_type& x)
  {
    this->chromatic_.set (x);
  }

  void transpose::
  chromatic (::std::unique_ptr< chromatic_type > x)
  {
    this->chromatic_.set (std::move (x));
  }

  const transpose::octave_change_optional& transpose::
  octave_change () const
  {
    return this->octave_change_;
  }

  transpose::octave_change_optional& transpose::
  octave_change ()
  {
    return this->octave_change_;
  }

  void transpose::
  octave_change (const octave_change_type& x)
  {
    this->octave_change_.set (x);
  }

  void transpose::
  octave_change (const octave_change_optional& x)
  {
    this->octave_change_ = x;
  }

  const transpose::double_optional& transpose::
  double_ () const
  {
    return this->double__;
  }

  transpose::double_optional& transpose::
  double_ ()
  {
    return this->double__;
  }

  void transpose::
  double_ (const double_type& x)
  {
    this->double__.set (x);
  }

  void transpose::
  double_ (const double_optional& x)
  {
    this->double__ = x;
  }

  void transpose::
  double_ (::std::unique_ptr< double_type > x)
  {
    this->double__.set (std::move (x));
  }

  const transpose::number_optional& transpose::
  number () const
  {
    return this->number_;
  }

  transpose::number_optional& transpose::
  number ()
  {
    return this->number_;
  }

  void transpose::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void transpose::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void transpose::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const transpose::id_optional& transpose::
  id () const
  {
    return this->id_;
  }

  transpose::id_optional& transpose::
  id ()
  {
    return this->id_;
  }

  void transpose::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void transpose::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void transpose::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // bar_style_color
  // 

  const bar_style_color::color_optional& bar_style_color::
  color () const
  {
    return this->color_;
  }

  bar_style_color::color_optional& bar_style_color::
  color ()
  {
    return this->color_;
  }

  void bar_style_color::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void bar_style_color::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void bar_style_color::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // barline
  // 

  const barline::bar_style_optional& barline::
  bar_style () const
  {
    return this->bar_style_;
  }

  barline::bar_style_optional& barline::
  bar_style ()
  {
    return this->bar_style_;
  }

  void barline::
  bar_style (const bar_style_type& x)
  {
    this->bar_style_.set (x);
  }

  void barline::
  bar_style (const bar_style_optional& x)
  {
    this->bar_style_ = x;
  }

  void barline::
  bar_style (::std::unique_ptr< bar_style_type > x)
  {
    this->bar_style_.set (std::move (x));
  }

  const barline::footnote_optional& barline::
  footnote () const
  {
    return this->footnote_;
  }

  barline::footnote_optional& barline::
  footnote ()
  {
    return this->footnote_;
  }

  void barline::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void barline::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void barline::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const barline::level_optional& barline::
  level () const
  {
    return this->level_;
  }

  barline::level_optional& barline::
  level ()
  {
    return this->level_;
  }

  void barline::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void barline::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void barline::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const barline::wavy_line_optional& barline::
  wavy_line () const
  {
    return this->wavy_line_;
  }

  barline::wavy_line_optional& barline::
  wavy_line ()
  {
    return this->wavy_line_;
  }

  void barline::
  wavy_line (const wavy_line_type& x)
  {
    this->wavy_line_.set (x);
  }

  void barline::
  wavy_line (const wavy_line_optional& x)
  {
    this->wavy_line_ = x;
  }

  void barline::
  wavy_line (::std::unique_ptr< wavy_line_type > x)
  {
    this->wavy_line_.set (std::move (x));
  }

  const barline::segno_optional& barline::
  segno () const
  {
    return this->segno_;
  }

  barline::segno_optional& barline::
  segno ()
  {
    return this->segno_;
  }

  void barline::
  segno (const segno_type& x)
  {
    this->segno_.set (x);
  }

  void barline::
  segno (const segno_optional& x)
  {
    this->segno_ = x;
  }

  void barline::
  segno (::std::unique_ptr< segno_type > x)
  {
    this->segno_.set (std::move (x));
  }

  const barline::coda_optional& barline::
  coda () const
  {
    return this->coda_;
  }

  barline::coda_optional& barline::
  coda ()
  {
    return this->coda_;
  }

  void barline::
  coda (const coda_type& x)
  {
    this->coda_.set (x);
  }

  void barline::
  coda (const coda_optional& x)
  {
    this->coda_ = x;
  }

  void barline::
  coda (::std::unique_ptr< coda_type > x)
  {
    this->coda_.set (std::move (x));
  }

  const barline::fermata_sequence& barline::
  fermata () const
  {
    return this->fermata_;
  }

  barline::fermata_sequence& barline::
  fermata ()
  {
    return this->fermata_;
  }

  void barline::
  fermata (const fermata_sequence& s)
  {
    this->fermata_ = s;
  }

  const barline::ending_optional& barline::
  ending () const
  {
    return this->ending_;
  }

  barline::ending_optional& barline::
  ending ()
  {
    return this->ending_;
  }

  void barline::
  ending (const ending_type& x)
  {
    this->ending_.set (x);
  }

  void barline::
  ending (const ending_optional& x)
  {
    this->ending_ = x;
  }

  void barline::
  ending (::std::unique_ptr< ending_type > x)
  {
    this->ending_.set (std::move (x));
  }

  const barline::repeat_optional& barline::
  repeat () const
  {
    return this->repeat_;
  }

  barline::repeat_optional& barline::
  repeat ()
  {
    return this->repeat_;
  }

  void barline::
  repeat (const repeat_type& x)
  {
    this->repeat_.set (x);
  }

  void barline::
  repeat (const repeat_optional& x)
  {
    this->repeat_ = x;
  }

  void barline::
  repeat (::std::unique_ptr< repeat_type > x)
  {
    this->repeat_.set (std::move (x));
  }

  const barline::location_type& barline::
  location () const
  {
    return this->location_.get ();
  }

  barline::location_type& barline::
  location ()
  {
    return this->location_.get ();
  }

  void barline::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void barline::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }

  const barline::location_type& barline::
  location_default_value ()
  {
    return location_default_value_;
  }

  const barline::segno1_optional& barline::
  segno1 () const
  {
    return this->segno1_;
  }

  barline::segno1_optional& barline::
  segno1 ()
  {
    return this->segno1_;
  }

  void barline::
  segno1 (const segno1_type& x)
  {
    this->segno1_.set (x);
  }

  void barline::
  segno1 (const segno1_optional& x)
  {
    this->segno1_ = x;
  }

  void barline::
  segno1 (::std::unique_ptr< segno1_type > x)
  {
    this->segno1_.set (std::move (x));
  }

  const barline::coda1_optional& barline::
  coda1 () const
  {
    return this->coda1_;
  }

  barline::coda1_optional& barline::
  coda1 ()
  {
    return this->coda1_;
  }

  void barline::
  coda1 (const coda1_type& x)
  {
    this->coda1_.set (x);
  }

  void barline::
  coda1 (const coda1_optional& x)
  {
    this->coda1_ = x;
  }

  void barline::
  coda1 (::std::unique_ptr< coda1_type > x)
  {
    this->coda1_.set (std::move (x));
  }

  const barline::divisions_optional& barline::
  divisions () const
  {
    return this->divisions_;
  }

  barline::divisions_optional& barline::
  divisions ()
  {
    return this->divisions_;
  }

  void barline::
  divisions (const divisions_type& x)
  {
    this->divisions_.set (x);
  }

  void barline::
  divisions (const divisions_optional& x)
  {
    this->divisions_ = x;
  }

  void barline::
  divisions (::std::unique_ptr< divisions_type > x)
  {
    this->divisions_.set (std::move (x));
  }

  const barline::id_optional& barline::
  id () const
  {
    return this->id_;
  }

  barline::id_optional& barline::
  id ()
  {
    return this->id_;
  }

  void barline::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void barline::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void barline::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // ending
  // 

  const ending::number_type& ending::
  number () const
  {
    return this->number_.get ();
  }

  ending::number_type& ending::
  number ()
  {
    return this->number_.get ();
  }

  void ending::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void ending::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const ending::type_type& ending::
  type () const
  {
    return this->type_.get ();
  }

  ending::type_type& ending::
  type ()
  {
    return this->type_.get ();
  }

  void ending::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void ending::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const ending::print_object_optional& ending::
  print_object () const
  {
    return this->print_object_;
  }

  ending::print_object_optional& ending::
  print_object ()
  {
    return this->print_object_;
  }

  void ending::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void ending::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void ending::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const ending::default_x_optional& ending::
  default_x () const
  {
    return this->default_x_;
  }

  ending::default_x_optional& ending::
  default_x ()
  {
    return this->default_x_;
  }

  void ending::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void ending::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void ending::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const ending::default_y_optional& ending::
  default_y () const
  {
    return this->default_y_;
  }

  ending::default_y_optional& ending::
  default_y ()
  {
    return this->default_y_;
  }

  void ending::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void ending::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void ending::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const ending::relative_x_optional& ending::
  relative_x () const
  {
    return this->relative_x_;
  }

  ending::relative_x_optional& ending::
  relative_x ()
  {
    return this->relative_x_;
  }

  void ending::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void ending::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void ending::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const ending::relative_y_optional& ending::
  relative_y () const
  {
    return this->relative_y_;
  }

  ending::relative_y_optional& ending::
  relative_y ()
  {
    return this->relative_y_;
  }

  void ending::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void ending::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void ending::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const ending::font_family_optional& ending::
  font_family () const
  {
    return this->font_family_;
  }

  ending::font_family_optional& ending::
  font_family ()
  {
    return this->font_family_;
  }

  void ending::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void ending::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void ending::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const ending::font_style_optional& ending::
  font_style () const
  {
    return this->font_style_;
  }

  ending::font_style_optional& ending::
  font_style ()
  {
    return this->font_style_;
  }

  void ending::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void ending::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void ending::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const ending::font_size_optional& ending::
  font_size () const
  {
    return this->font_size_;
  }

  ending::font_size_optional& ending::
  font_size ()
  {
    return this->font_size_;
  }

  void ending::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void ending::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void ending::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const ending::font_weight_optional& ending::
  font_weight () const
  {
    return this->font_weight_;
  }

  ending::font_weight_optional& ending::
  font_weight ()
  {
    return this->font_weight_;
  }

  void ending::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void ending::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void ending::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const ending::color_optional& ending::
  color () const
  {
    return this->color_;
  }

  ending::color_optional& ending::
  color ()
  {
    return this->color_;
  }

  void ending::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void ending::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void ending::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const ending::system_optional& ending::
  system () const
  {
    return this->system_;
  }

  ending::system_optional& ending::
  system ()
  {
    return this->system_;
  }

  void ending::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void ending::
  system (const system_optional& x)
  {
    this->system_ = x;
  }

  void ending::
  system (::std::unique_ptr< system_type > x)
  {
    this->system_.set (std::move (x));
  }

  const ending::end_length_optional& ending::
  end_length () const
  {
    return this->end_length_;
  }

  ending::end_length_optional& ending::
  end_length ()
  {
    return this->end_length_;
  }

  void ending::
  end_length (const end_length_type& x)
  {
    this->end_length_.set (x);
  }

  void ending::
  end_length (const end_length_optional& x)
  {
    this->end_length_ = x;
  }

  void ending::
  end_length (::std::unique_ptr< end_length_type > x)
  {
    this->end_length_.set (std::move (x));
  }

  const ending::text_x_optional& ending::
  text_x () const
  {
    return this->text_x_;
  }

  ending::text_x_optional& ending::
  text_x ()
  {
    return this->text_x_;
  }

  void ending::
  text_x (const text_x_type& x)
  {
    this->text_x_.set (x);
  }

  void ending::
  text_x (const text_x_optional& x)
  {
    this->text_x_ = x;
  }

  void ending::
  text_x (::std::unique_ptr< text_x_type > x)
  {
    this->text_x_.set (std::move (x));
  }

  const ending::text_y_optional& ending::
  text_y () const
  {
    return this->text_y_;
  }

  ending::text_y_optional& ending::
  text_y ()
  {
    return this->text_y_;
  }

  void ending::
  text_y (const text_y_type& x)
  {
    this->text_y_.set (x);
  }

  void ending::
  text_y (const text_y_optional& x)
  {
    this->text_y_ = x;
  }

  void ending::
  text_y (::std::unique_ptr< text_y_type > x)
  {
    this->text_y_.set (std::move (x));
  }


  // repeat
  // 

  const repeat::direction_type& repeat::
  direction () const
  {
    return this->direction_.get ();
  }

  repeat::direction_type& repeat::
  direction ()
  {
    return this->direction_.get ();
  }

  void repeat::
  direction (const direction_type& x)
  {
    this->direction_.set (x);
  }

  void repeat::
  direction (::std::unique_ptr< direction_type > x)
  {
    this->direction_.set (std::move (x));
  }

  const repeat::times_optional& repeat::
  times () const
  {
    return this->times_;
  }

  repeat::times_optional& repeat::
  times ()
  {
    return this->times_;
  }

  void repeat::
  times (const times_type& x)
  {
    this->times_.set (x);
  }

  void repeat::
  times (const times_optional& x)
  {
    this->times_ = x;
  }

  const repeat::after_jump_optional& repeat::
  after_jump () const
  {
    return this->after_jump_;
  }

  repeat::after_jump_optional& repeat::
  after_jump ()
  {
    return this->after_jump_;
  }

  void repeat::
  after_jump (const after_jump_type& x)
  {
    this->after_jump_.set (x);
  }

  void repeat::
  after_jump (const after_jump_optional& x)
  {
    this->after_jump_ = x;
  }

  void repeat::
  after_jump (::std::unique_ptr< after_jump_type > x)
  {
    this->after_jump_.set (std::move (x));
  }

  const repeat::winged_optional& repeat::
  winged () const
  {
    return this->winged_;
  }

  repeat::winged_optional& repeat::
  winged ()
  {
    return this->winged_;
  }

  void repeat::
  winged (const winged_type& x)
  {
    this->winged_.set (x);
  }

  void repeat::
  winged (const winged_optional& x)
  {
    this->winged_ = x;
  }

  void repeat::
  winged (::std::unique_ptr< winged_type > x)
  {
    this->winged_.set (std::move (x));
  }


  // accord
  // 

  const accord::tuning_step_type& accord::
  tuning_step () const
  {
    return this->tuning_step_.get ();
  }

  accord::tuning_step_type& accord::
  tuning_step ()
  {
    return this->tuning_step_.get ();
  }

  void accord::
  tuning_step (const tuning_step_type& x)
  {
    this->tuning_step_.set (x);
  }

  void accord::
  tuning_step (::std::unique_ptr< tuning_step_type > x)
  {
    this->tuning_step_.set (std::move (x));
  }

  const accord::tuning_alter_optional& accord::
  tuning_alter () const
  {
    return this->tuning_alter_;
  }

  accord::tuning_alter_optional& accord::
  tuning_alter ()
  {
    return this->tuning_alter_;
  }

  void accord::
  tuning_alter (const tuning_alter_type& x)
  {
    this->tuning_alter_.set (x);
  }

  void accord::
  tuning_alter (const tuning_alter_optional& x)
  {
    this->tuning_alter_ = x;
  }

  void accord::
  tuning_alter (::std::unique_ptr< tuning_alter_type > x)
  {
    this->tuning_alter_.set (std::move (x));
  }

  const accord::tuning_octave_type& accord::
  tuning_octave () const
  {
    return this->tuning_octave_.get ();
  }

  accord::tuning_octave_type& accord::
  tuning_octave ()
  {
    return this->tuning_octave_.get ();
  }

  void accord::
  tuning_octave (const tuning_octave_type& x)
  {
    this->tuning_octave_.set (x);
  }

  void accord::
  tuning_octave (::std::unique_ptr< tuning_octave_type > x)
  {
    this->tuning_octave_.set (std::move (x));
  }

  const accord::string_optional& accord::
  string () const
  {
    return this->string_;
  }

  accord::string_optional& accord::
  string ()
  {
    return this->string_;
  }

  void accord::
  string (const string_type& x)
  {
    this->string_.set (x);
  }

  void accord::
  string (const string_optional& x)
  {
    this->string_ = x;
  }

  void accord::
  string (::std::unique_ptr< string_type > x)
  {
    this->string_.set (std::move (x));
  }


  // accordion_registration
  // 

  const accordion_registration::accordion_high_optional& accordion_registration::
  accordion_high () const
  {
    return this->accordion_high_;
  }

  accordion_registration::accordion_high_optional& accordion_registration::
  accordion_high ()
  {
    return this->accordion_high_;
  }

  void accordion_registration::
  accordion_high (const accordion_high_type& x)
  {
    this->accordion_high_.set (x);
  }

  void accordion_registration::
  accordion_high (const accordion_high_optional& x)
  {
    this->accordion_high_ = x;
  }

  void accordion_registration::
  accordion_high (::std::unique_ptr< accordion_high_type > x)
  {
    this->accordion_high_.set (std::move (x));
  }

  const accordion_registration::accordion_middle_optional& accordion_registration::
  accordion_middle () const
  {
    return this->accordion_middle_;
  }

  accordion_registration::accordion_middle_optional& accordion_registration::
  accordion_middle ()
  {
    return this->accordion_middle_;
  }

  void accordion_registration::
  accordion_middle (const accordion_middle_type& x)
  {
    this->accordion_middle_.set (x);
  }

  void accordion_registration::
  accordion_middle (const accordion_middle_optional& x)
  {
    this->accordion_middle_ = x;
  }

  void accordion_registration::
  accordion_middle (::std::unique_ptr< accordion_middle_type > x)
  {
    this->accordion_middle_.set (std::move (x));
  }

  const accordion_registration::accordion_low_optional& accordion_registration::
  accordion_low () const
  {
    return this->accordion_low_;
  }

  accordion_registration::accordion_low_optional& accordion_registration::
  accordion_low ()
  {
    return this->accordion_low_;
  }

  void accordion_registration::
  accordion_low (const accordion_low_type& x)
  {
    this->accordion_low_.set (x);
  }

  void accordion_registration::
  accordion_low (const accordion_low_optional& x)
  {
    this->accordion_low_ = x;
  }

  void accordion_registration::
  accordion_low (::std::unique_ptr< accordion_low_type > x)
  {
    this->accordion_low_.set (std::move (x));
  }

  const accordion_registration::default_x_optional& accordion_registration::
  default_x () const
  {
    return this->default_x_;
  }

  accordion_registration::default_x_optional& accordion_registration::
  default_x ()
  {
    return this->default_x_;
  }

  void accordion_registration::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void accordion_registration::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void accordion_registration::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const accordion_registration::default_y_optional& accordion_registration::
  default_y () const
  {
    return this->default_y_;
  }

  accordion_registration::default_y_optional& accordion_registration::
  default_y ()
  {
    return this->default_y_;
  }

  void accordion_registration::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void accordion_registration::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void accordion_registration::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const accordion_registration::relative_x_optional& accordion_registration::
  relative_x () const
  {
    return this->relative_x_;
  }

  accordion_registration::relative_x_optional& accordion_registration::
  relative_x ()
  {
    return this->relative_x_;
  }

  void accordion_registration::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void accordion_registration::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void accordion_registration::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const accordion_registration::relative_y_optional& accordion_registration::
  relative_y () const
  {
    return this->relative_y_;
  }

  accordion_registration::relative_y_optional& accordion_registration::
  relative_y ()
  {
    return this->relative_y_;
  }

  void accordion_registration::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void accordion_registration::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void accordion_registration::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const accordion_registration::font_family_optional& accordion_registration::
  font_family () const
  {
    return this->font_family_;
  }

  accordion_registration::font_family_optional& accordion_registration::
  font_family ()
  {
    return this->font_family_;
  }

  void accordion_registration::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void accordion_registration::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void accordion_registration::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const accordion_registration::font_style_optional& accordion_registration::
  font_style () const
  {
    return this->font_style_;
  }

  accordion_registration::font_style_optional& accordion_registration::
  font_style ()
  {
    return this->font_style_;
  }

  void accordion_registration::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void accordion_registration::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void accordion_registration::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const accordion_registration::font_size_optional& accordion_registration::
  font_size () const
  {
    return this->font_size_;
  }

  accordion_registration::font_size_optional& accordion_registration::
  font_size ()
  {
    return this->font_size_;
  }

  void accordion_registration::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void accordion_registration::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void accordion_registration::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const accordion_registration::font_weight_optional& accordion_registration::
  font_weight () const
  {
    return this->font_weight_;
  }

  accordion_registration::font_weight_optional& accordion_registration::
  font_weight ()
  {
    return this->font_weight_;
  }

  void accordion_registration::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void accordion_registration::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void accordion_registration::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const accordion_registration::color_optional& accordion_registration::
  color () const
  {
    return this->color_;
  }

  accordion_registration::color_optional& accordion_registration::
  color ()
  {
    return this->color_;
  }

  void accordion_registration::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void accordion_registration::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void accordion_registration::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const accordion_registration::halign_optional& accordion_registration::
  halign () const
  {
    return this->halign_;
  }

  accordion_registration::halign_optional& accordion_registration::
  halign ()
  {
    return this->halign_;
  }

  void accordion_registration::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void accordion_registration::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void accordion_registration::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const accordion_registration::valign_optional& accordion_registration::
  valign () const
  {
    return this->valign_;
  }

  accordion_registration::valign_optional& accordion_registration::
  valign ()
  {
    return this->valign_;
  }

  void accordion_registration::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void accordion_registration::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void accordion_registration::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const accordion_registration::id_optional& accordion_registration::
  id () const
  {
    return this->id_;
  }

  accordion_registration::id_optional& accordion_registration::
  id ()
  {
    return this->id_;
  }

  void accordion_registration::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void accordion_registration::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void accordion_registration::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // barre
  // 

  const barre::type_type& barre::
  type () const
  {
    return this->type_.get ();
  }

  barre::type_type& barre::
  type ()
  {
    return this->type_.get ();
  }

  void barre::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void barre::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const barre::color_optional& barre::
  color () const
  {
    return this->color_;
  }

  barre::color_optional& barre::
  color ()
  {
    return this->color_;
  }

  void barre::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void barre::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void barre::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // bass
  // 

  const bass::bass_separator_optional& bass::
  bass_separator () const
  {
    return this->bass_separator_;
  }

  bass::bass_separator_optional& bass::
  bass_separator ()
  {
    return this->bass_separator_;
  }

  void bass::
  bass_separator (const bass_separator_type& x)
  {
    this->bass_separator_.set (x);
  }

  void bass::
  bass_separator (const bass_separator_optional& x)
  {
    this->bass_separator_ = x;
  }

  void bass::
  bass_separator (::std::unique_ptr< bass_separator_type > x)
  {
    this->bass_separator_.set (std::move (x));
  }

  const bass::bass_step_type& bass::
  bass_step () const
  {
    return this->bass_step_.get ();
  }

  bass::bass_step_type& bass::
  bass_step ()
  {
    return this->bass_step_.get ();
  }

  void bass::
  bass_step (const bass_step_type& x)
  {
    this->bass_step_.set (x);
  }

  void bass::
  bass_step (::std::unique_ptr< bass_step_type > x)
  {
    this->bass_step_.set (std::move (x));
  }

  const bass::bass_alter_optional& bass::
  bass_alter () const
  {
    return this->bass_alter_;
  }

  bass::bass_alter_optional& bass::
  bass_alter ()
  {
    return this->bass_alter_;
  }

  void bass::
  bass_alter (const bass_alter_type& x)
  {
    this->bass_alter_.set (x);
  }

  void bass::
  bass_alter (const bass_alter_optional& x)
  {
    this->bass_alter_ = x;
  }

  void bass::
  bass_alter (::std::unique_ptr< bass_alter_type > x)
  {
    this->bass_alter_.set (std::move (x));
  }

  const bass::arrangement_optional& bass::
  arrangement () const
  {
    return this->arrangement_;
  }

  bass::arrangement_optional& bass::
  arrangement ()
  {
    return this->arrangement_;
  }

  void bass::
  arrangement (const arrangement_type& x)
  {
    this->arrangement_.set (x);
  }

  void bass::
  arrangement (const arrangement_optional& x)
  {
    this->arrangement_ = x;
  }

  void bass::
  arrangement (::std::unique_ptr< arrangement_type > x)
  {
    this->arrangement_.set (std::move (x));
  }


  // harmony_alter
  // 

  const harmony_alter::print_object_optional& harmony_alter::
  print_object () const
  {
    return this->print_object_;
  }

  harmony_alter::print_object_optional& harmony_alter::
  print_object ()
  {
    return this->print_object_;
  }

  void harmony_alter::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void harmony_alter::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void harmony_alter::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const harmony_alter::default_x_optional& harmony_alter::
  default_x () const
  {
    return this->default_x_;
  }

  harmony_alter::default_x_optional& harmony_alter::
  default_x ()
  {
    return this->default_x_;
  }

  void harmony_alter::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void harmony_alter::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void harmony_alter::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const harmony_alter::default_y_optional& harmony_alter::
  default_y () const
  {
    return this->default_y_;
  }

  harmony_alter::default_y_optional& harmony_alter::
  default_y ()
  {
    return this->default_y_;
  }

  void harmony_alter::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void harmony_alter::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void harmony_alter::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const harmony_alter::relative_x_optional& harmony_alter::
  relative_x () const
  {
    return this->relative_x_;
  }

  harmony_alter::relative_x_optional& harmony_alter::
  relative_x ()
  {
    return this->relative_x_;
  }

  void harmony_alter::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void harmony_alter::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void harmony_alter::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const harmony_alter::relative_y_optional& harmony_alter::
  relative_y () const
  {
    return this->relative_y_;
  }

  harmony_alter::relative_y_optional& harmony_alter::
  relative_y ()
  {
    return this->relative_y_;
  }

  void harmony_alter::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void harmony_alter::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void harmony_alter::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const harmony_alter::font_family_optional& harmony_alter::
  font_family () const
  {
    return this->font_family_;
  }

  harmony_alter::font_family_optional& harmony_alter::
  font_family ()
  {
    return this->font_family_;
  }

  void harmony_alter::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void harmony_alter::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void harmony_alter::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const harmony_alter::font_style_optional& harmony_alter::
  font_style () const
  {
    return this->font_style_;
  }

  harmony_alter::font_style_optional& harmony_alter::
  font_style ()
  {
    return this->font_style_;
  }

  void harmony_alter::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void harmony_alter::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void harmony_alter::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const harmony_alter::font_size_optional& harmony_alter::
  font_size () const
  {
    return this->font_size_;
  }

  harmony_alter::font_size_optional& harmony_alter::
  font_size ()
  {
    return this->font_size_;
  }

  void harmony_alter::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void harmony_alter::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void harmony_alter::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const harmony_alter::font_weight_optional& harmony_alter::
  font_weight () const
  {
    return this->font_weight_;
  }

  harmony_alter::font_weight_optional& harmony_alter::
  font_weight ()
  {
    return this->font_weight_;
  }

  void harmony_alter::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void harmony_alter::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void harmony_alter::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const harmony_alter::color_optional& harmony_alter::
  color () const
  {
    return this->color_;
  }

  harmony_alter::color_optional& harmony_alter::
  color ()
  {
    return this->color_;
  }

  void harmony_alter::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void harmony_alter::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void harmony_alter::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const harmony_alter::location_optional& harmony_alter::
  location () const
  {
    return this->location_;
  }

  harmony_alter::location_optional& harmony_alter::
  location ()
  {
    return this->location_;
  }

  void harmony_alter::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void harmony_alter::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void harmony_alter::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // bass_step
  // 

  const bass_step::text_optional& bass_step::
  text () const
  {
    return this->text_;
  }

  bass_step::text_optional& bass_step::
  text ()
  {
    return this->text_;
  }

  void bass_step::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void bass_step::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void bass_step::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const bass_step::default_x_optional& bass_step::
  default_x () const
  {
    return this->default_x_;
  }

  bass_step::default_x_optional& bass_step::
  default_x ()
  {
    return this->default_x_;
  }

  void bass_step::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void bass_step::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void bass_step::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const bass_step::default_y_optional& bass_step::
  default_y () const
  {
    return this->default_y_;
  }

  bass_step::default_y_optional& bass_step::
  default_y ()
  {
    return this->default_y_;
  }

  void bass_step::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void bass_step::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void bass_step::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const bass_step::relative_x_optional& bass_step::
  relative_x () const
  {
    return this->relative_x_;
  }

  bass_step::relative_x_optional& bass_step::
  relative_x ()
  {
    return this->relative_x_;
  }

  void bass_step::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void bass_step::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void bass_step::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const bass_step::relative_y_optional& bass_step::
  relative_y () const
  {
    return this->relative_y_;
  }

  bass_step::relative_y_optional& bass_step::
  relative_y ()
  {
    return this->relative_y_;
  }

  void bass_step::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void bass_step::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void bass_step::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const bass_step::font_family_optional& bass_step::
  font_family () const
  {
    return this->font_family_;
  }

  bass_step::font_family_optional& bass_step::
  font_family ()
  {
    return this->font_family_;
  }

  void bass_step::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void bass_step::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void bass_step::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const bass_step::font_style_optional& bass_step::
  font_style () const
  {
    return this->font_style_;
  }

  bass_step::font_style_optional& bass_step::
  font_style ()
  {
    return this->font_style_;
  }

  void bass_step::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void bass_step::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void bass_step::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const bass_step::font_size_optional& bass_step::
  font_size () const
  {
    return this->font_size_;
  }

  bass_step::font_size_optional& bass_step::
  font_size ()
  {
    return this->font_size_;
  }

  void bass_step::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void bass_step::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void bass_step::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const bass_step::font_weight_optional& bass_step::
  font_weight () const
  {
    return this->font_weight_;
  }

  bass_step::font_weight_optional& bass_step::
  font_weight ()
  {
    return this->font_weight_;
  }

  void bass_step::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void bass_step::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void bass_step::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const bass_step::color_optional& bass_step::
  color () const
  {
    return this->color_;
  }

  bass_step::color_optional& bass_step::
  color ()
  {
    return this->color_;
  }

  void bass_step::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void bass_step::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void bass_step::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // beater
  // 

  const beater::tip_optional& beater::
  tip () const
  {
    return this->tip_;
  }

  beater::tip_optional& beater::
  tip ()
  {
    return this->tip_;
  }

  void beater::
  tip (const tip_type& x)
  {
    this->tip_.set (x);
  }

  void beater::
  tip (const tip_optional& x)
  {
    this->tip_ = x;
  }

  void beater::
  tip (::std::unique_ptr< tip_type > x)
  {
    this->tip_.set (std::move (x));
  }


  // beat_unit_tied
  // 

  const beat_unit_tied::beat_unit_type& beat_unit_tied::
  beat_unit () const
  {
    return this->beat_unit_.get ();
  }

  beat_unit_tied::beat_unit_type& beat_unit_tied::
  beat_unit ()
  {
    return this->beat_unit_.get ();
  }

  void beat_unit_tied::
  beat_unit (const beat_unit_type& x)
  {
    this->beat_unit_.set (x);
  }

  void beat_unit_tied::
  beat_unit (::std::unique_ptr< beat_unit_type > x)
  {
    this->beat_unit_.set (std::move (x));
  }

  const beat_unit_tied::beat_unit_dot_sequence& beat_unit_tied::
  beat_unit_dot () const
  {
    return this->beat_unit_dot_;
  }

  beat_unit_tied::beat_unit_dot_sequence& beat_unit_tied::
  beat_unit_dot ()
  {
    return this->beat_unit_dot_;
  }

  void beat_unit_tied::
  beat_unit_dot (const beat_unit_dot_sequence& s)
  {
    this->beat_unit_dot_ = s;
  }


  // bracket
  // 

  const bracket::type_type& bracket::
  type () const
  {
    return this->type_.get ();
  }

  bracket::type_type& bracket::
  type ()
  {
    return this->type_.get ();
  }

  void bracket::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void bracket::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const bracket::number_optional& bracket::
  number () const
  {
    return this->number_;
  }

  bracket::number_optional& bracket::
  number ()
  {
    return this->number_;
  }

  void bracket::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void bracket::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void bracket::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const bracket::line_end_type& bracket::
  line_end () const
  {
    return this->line_end_.get ();
  }

  bracket::line_end_type& bracket::
  line_end ()
  {
    return this->line_end_.get ();
  }

  void bracket::
  line_end (const line_end_type& x)
  {
    this->line_end_.set (x);
  }

  void bracket::
  line_end (::std::unique_ptr< line_end_type > x)
  {
    this->line_end_.set (std::move (x));
  }

  const bracket::end_length_optional& bracket::
  end_length () const
  {
    return this->end_length_;
  }

  bracket::end_length_optional& bracket::
  end_length ()
  {
    return this->end_length_;
  }

  void bracket::
  end_length (const end_length_type& x)
  {
    this->end_length_.set (x);
  }

  void bracket::
  end_length (const end_length_optional& x)
  {
    this->end_length_ = x;
  }

  void bracket::
  end_length (::std::unique_ptr< end_length_type > x)
  {
    this->end_length_.set (std::move (x));
  }

  const bracket::line_type_optional& bracket::
  line_type () const
  {
    return this->line_type_;
  }

  bracket::line_type_optional& bracket::
  line_type ()
  {
    return this->line_type_;
  }

  void bracket::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void bracket::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void bracket::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const bracket::dash_length_optional& bracket::
  dash_length () const
  {
    return this->dash_length_;
  }

  bracket::dash_length_optional& bracket::
  dash_length ()
  {
    return this->dash_length_;
  }

  void bracket::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void bracket::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void bracket::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const bracket::space_length_optional& bracket::
  space_length () const
  {
    return this->space_length_;
  }

  bracket::space_length_optional& bracket::
  space_length ()
  {
    return this->space_length_;
  }

  void bracket::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void bracket::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void bracket::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const bracket::default_x_optional& bracket::
  default_x () const
  {
    return this->default_x_;
  }

  bracket::default_x_optional& bracket::
  default_x ()
  {
    return this->default_x_;
  }

  void bracket::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void bracket::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void bracket::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const bracket::default_y_optional& bracket::
  default_y () const
  {
    return this->default_y_;
  }

  bracket::default_y_optional& bracket::
  default_y ()
  {
    return this->default_y_;
  }

  void bracket::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void bracket::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void bracket::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const bracket::relative_x_optional& bracket::
  relative_x () const
  {
    return this->relative_x_;
  }

  bracket::relative_x_optional& bracket::
  relative_x ()
  {
    return this->relative_x_;
  }

  void bracket::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void bracket::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void bracket::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const bracket::relative_y_optional& bracket::
  relative_y () const
  {
    return this->relative_y_;
  }

  bracket::relative_y_optional& bracket::
  relative_y ()
  {
    return this->relative_y_;
  }

  void bracket::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void bracket::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void bracket::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const bracket::color_optional& bracket::
  color () const
  {
    return this->color_;
  }

  bracket::color_optional& bracket::
  color ()
  {
    return this->color_;
  }

  void bracket::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void bracket::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void bracket::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const bracket::id_optional& bracket::
  id () const
  {
    return this->id_;
  }

  bracket::id_optional& bracket::
  id ()
  {
    return this->id_;
  }

  void bracket::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void bracket::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void bracket::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // dashes
  // 

  const dashes::type_type& dashes::
  type () const
  {
    return this->type_.get ();
  }

  dashes::type_type& dashes::
  type ()
  {
    return this->type_.get ();
  }

  void dashes::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void dashes::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const dashes::number_optional& dashes::
  number () const
  {
    return this->number_;
  }

  dashes::number_optional& dashes::
  number ()
  {
    return this->number_;
  }

  void dashes::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void dashes::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void dashes::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const dashes::dash_length_optional& dashes::
  dash_length () const
  {
    return this->dash_length_;
  }

  dashes::dash_length_optional& dashes::
  dash_length ()
  {
    return this->dash_length_;
  }

  void dashes::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void dashes::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void dashes::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const dashes::space_length_optional& dashes::
  space_length () const
  {
    return this->space_length_;
  }

  dashes::space_length_optional& dashes::
  space_length ()
  {
    return this->space_length_;
  }

  void dashes::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void dashes::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void dashes::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const dashes::default_x_optional& dashes::
  default_x () const
  {
    return this->default_x_;
  }

  dashes::default_x_optional& dashes::
  default_x ()
  {
    return this->default_x_;
  }

  void dashes::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void dashes::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void dashes::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const dashes::default_y_optional& dashes::
  default_y () const
  {
    return this->default_y_;
  }

  dashes::default_y_optional& dashes::
  default_y ()
  {
    return this->default_y_;
  }

  void dashes::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void dashes::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void dashes::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const dashes::relative_x_optional& dashes::
  relative_x () const
  {
    return this->relative_x_;
  }

  dashes::relative_x_optional& dashes::
  relative_x ()
  {
    return this->relative_x_;
  }

  void dashes::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void dashes::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void dashes::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const dashes::relative_y_optional& dashes::
  relative_y () const
  {
    return this->relative_y_;
  }

  dashes::relative_y_optional& dashes::
  relative_y ()
  {
    return this->relative_y_;
  }

  void dashes::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void dashes::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void dashes::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const dashes::color_optional& dashes::
  color () const
  {
    return this->color_;
  }

  dashes::color_optional& dashes::
  color ()
  {
    return this->color_;
  }

  void dashes::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void dashes::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void dashes::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const dashes::id_optional& dashes::
  id () const
  {
    return this->id_;
  }

  dashes::id_optional& dashes::
  id ()
  {
    return this->id_;
  }

  void dashes::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void dashes::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void dashes::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // degree
  // 

  const degree::degree_value_type& degree::
  degree_value () const
  {
    return this->degree_value_.get ();
  }

  degree::degree_value_type& degree::
  degree_value ()
  {
    return this->degree_value_.get ();
  }

  void degree::
  degree_value (const degree_value_type& x)
  {
    this->degree_value_.set (x);
  }

  void degree::
  degree_value (::std::unique_ptr< degree_value_type > x)
  {
    this->degree_value_.set (std::move (x));
  }

  const degree::degree_alter_type& degree::
  degree_alter () const
  {
    return this->degree_alter_.get ();
  }

  degree::degree_alter_type& degree::
  degree_alter ()
  {
    return this->degree_alter_.get ();
  }

  void degree::
  degree_alter (const degree_alter_type& x)
  {
    this->degree_alter_.set (x);
  }

  void degree::
  degree_alter (::std::unique_ptr< degree_alter_type > x)
  {
    this->degree_alter_.set (std::move (x));
  }

  const degree::degree_type_type& degree::
  degree_type () const
  {
    return this->degree_type_.get ();
  }

  degree::degree_type_type& degree::
  degree_type ()
  {
    return this->degree_type_.get ();
  }

  void degree::
  degree_type (const degree_type_type& x)
  {
    this->degree_type_.set (x);
  }

  void degree::
  degree_type (::std::unique_ptr< degree_type_type > x)
  {
    this->degree_type_.set (std::move (x));
  }

  const degree::print_object_optional& degree::
  print_object () const
  {
    return this->print_object_;
  }

  degree::print_object_optional& degree::
  print_object ()
  {
    return this->print_object_;
  }

  void degree::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void degree::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void degree::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }


  // degree_alter
  // 

  const degree_alter::default_x_optional& degree_alter::
  default_x () const
  {
    return this->default_x_;
  }

  degree_alter::default_x_optional& degree_alter::
  default_x ()
  {
    return this->default_x_;
  }

  void degree_alter::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void degree_alter::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void degree_alter::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const degree_alter::default_y_optional& degree_alter::
  default_y () const
  {
    return this->default_y_;
  }

  degree_alter::default_y_optional& degree_alter::
  default_y ()
  {
    return this->default_y_;
  }

  void degree_alter::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void degree_alter::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void degree_alter::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const degree_alter::relative_x_optional& degree_alter::
  relative_x () const
  {
    return this->relative_x_;
  }

  degree_alter::relative_x_optional& degree_alter::
  relative_x ()
  {
    return this->relative_x_;
  }

  void degree_alter::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void degree_alter::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void degree_alter::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const degree_alter::relative_y_optional& degree_alter::
  relative_y () const
  {
    return this->relative_y_;
  }

  degree_alter::relative_y_optional& degree_alter::
  relative_y ()
  {
    return this->relative_y_;
  }

  void degree_alter::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void degree_alter::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void degree_alter::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const degree_alter::font_family_optional& degree_alter::
  font_family () const
  {
    return this->font_family_;
  }

  degree_alter::font_family_optional& degree_alter::
  font_family ()
  {
    return this->font_family_;
  }

  void degree_alter::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void degree_alter::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void degree_alter::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const degree_alter::font_style_optional& degree_alter::
  font_style () const
  {
    return this->font_style_;
  }

  degree_alter::font_style_optional& degree_alter::
  font_style ()
  {
    return this->font_style_;
  }

  void degree_alter::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void degree_alter::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void degree_alter::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const degree_alter::font_size_optional& degree_alter::
  font_size () const
  {
    return this->font_size_;
  }

  degree_alter::font_size_optional& degree_alter::
  font_size ()
  {
    return this->font_size_;
  }

  void degree_alter::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void degree_alter::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void degree_alter::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const degree_alter::font_weight_optional& degree_alter::
  font_weight () const
  {
    return this->font_weight_;
  }

  degree_alter::font_weight_optional& degree_alter::
  font_weight ()
  {
    return this->font_weight_;
  }

  void degree_alter::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void degree_alter::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void degree_alter::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const degree_alter::color_optional& degree_alter::
  color () const
  {
    return this->color_;
  }

  degree_alter::color_optional& degree_alter::
  color ()
  {
    return this->color_;
  }

  void degree_alter::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void degree_alter::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void degree_alter::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const degree_alter::plus_minus_optional& degree_alter::
  plus_minus () const
  {
    return this->plus_minus_;
  }

  degree_alter::plus_minus_optional& degree_alter::
  plus_minus ()
  {
    return this->plus_minus_;
  }

  void degree_alter::
  plus_minus (const plus_minus_type& x)
  {
    this->plus_minus_.set (x);
  }

  void degree_alter::
  plus_minus (const plus_minus_optional& x)
  {
    this->plus_minus_ = x;
  }

  void degree_alter::
  plus_minus (::std::unique_ptr< plus_minus_type > x)
  {
    this->plus_minus_.set (std::move (x));
  }


  // degree_type
  // 

  const degree_type::text_optional& degree_type::
  text () const
  {
    return this->text_;
  }

  degree_type::text_optional& degree_type::
  text ()
  {
    return this->text_;
  }

  void degree_type::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void degree_type::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void degree_type::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const degree_type::default_x_optional& degree_type::
  default_x () const
  {
    return this->default_x_;
  }

  degree_type::default_x_optional& degree_type::
  default_x ()
  {
    return this->default_x_;
  }

  void degree_type::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void degree_type::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void degree_type::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const degree_type::default_y_optional& degree_type::
  default_y () const
  {
    return this->default_y_;
  }

  degree_type::default_y_optional& degree_type::
  default_y ()
  {
    return this->default_y_;
  }

  void degree_type::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void degree_type::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void degree_type::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const degree_type::relative_x_optional& degree_type::
  relative_x () const
  {
    return this->relative_x_;
  }

  degree_type::relative_x_optional& degree_type::
  relative_x ()
  {
    return this->relative_x_;
  }

  void degree_type::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void degree_type::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void degree_type::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const degree_type::relative_y_optional& degree_type::
  relative_y () const
  {
    return this->relative_y_;
  }

  degree_type::relative_y_optional& degree_type::
  relative_y ()
  {
    return this->relative_y_;
  }

  void degree_type::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void degree_type::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void degree_type::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const degree_type::font_family_optional& degree_type::
  font_family () const
  {
    return this->font_family_;
  }

  degree_type::font_family_optional& degree_type::
  font_family ()
  {
    return this->font_family_;
  }

  void degree_type::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void degree_type::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void degree_type::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const degree_type::font_style_optional& degree_type::
  font_style () const
  {
    return this->font_style_;
  }

  degree_type::font_style_optional& degree_type::
  font_style ()
  {
    return this->font_style_;
  }

  void degree_type::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void degree_type::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void degree_type::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const degree_type::font_size_optional& degree_type::
  font_size () const
  {
    return this->font_size_;
  }

  degree_type::font_size_optional& degree_type::
  font_size ()
  {
    return this->font_size_;
  }

  void degree_type::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void degree_type::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void degree_type::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const degree_type::font_weight_optional& degree_type::
  font_weight () const
  {
    return this->font_weight_;
  }

  degree_type::font_weight_optional& degree_type::
  font_weight ()
  {
    return this->font_weight_;
  }

  void degree_type::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void degree_type::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void degree_type::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const degree_type::color_optional& degree_type::
  color () const
  {
    return this->color_;
  }

  degree_type::color_optional& degree_type::
  color ()
  {
    return this->color_;
  }

  void degree_type::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void degree_type::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void degree_type::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // degree_value
  // 

  const degree_value::symbol_optional& degree_value::
  symbol () const
  {
    return this->symbol_;
  }

  degree_value::symbol_optional& degree_value::
  symbol ()
  {
    return this->symbol_;
  }

  void degree_value::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void degree_value::
  symbol (const symbol_optional& x)
  {
    this->symbol_ = x;
  }

  void degree_value::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const degree_value::text_optional& degree_value::
  text () const
  {
    return this->text_;
  }

  degree_value::text_optional& degree_value::
  text ()
  {
    return this->text_;
  }

  void degree_value::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void degree_value::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void degree_value::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const degree_value::default_x_optional& degree_value::
  default_x () const
  {
    return this->default_x_;
  }

  degree_value::default_x_optional& degree_value::
  default_x ()
  {
    return this->default_x_;
  }

  void degree_value::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void degree_value::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void degree_value::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const degree_value::default_y_optional& degree_value::
  default_y () const
  {
    return this->default_y_;
  }

  degree_value::default_y_optional& degree_value::
  default_y ()
  {
    return this->default_y_;
  }

  void degree_value::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void degree_value::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void degree_value::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const degree_value::relative_x_optional& degree_value::
  relative_x () const
  {
    return this->relative_x_;
  }

  degree_value::relative_x_optional& degree_value::
  relative_x ()
  {
    return this->relative_x_;
  }

  void degree_value::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void degree_value::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void degree_value::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const degree_value::relative_y_optional& degree_value::
  relative_y () const
  {
    return this->relative_y_;
  }

  degree_value::relative_y_optional& degree_value::
  relative_y ()
  {
    return this->relative_y_;
  }

  void degree_value::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void degree_value::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void degree_value::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const degree_value::font_family_optional& degree_value::
  font_family () const
  {
    return this->font_family_;
  }

  degree_value::font_family_optional& degree_value::
  font_family ()
  {
    return this->font_family_;
  }

  void degree_value::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void degree_value::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void degree_value::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const degree_value::font_style_optional& degree_value::
  font_style () const
  {
    return this->font_style_;
  }

  degree_value::font_style_optional& degree_value::
  font_style ()
  {
    return this->font_style_;
  }

  void degree_value::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void degree_value::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void degree_value::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const degree_value::font_size_optional& degree_value::
  font_size () const
  {
    return this->font_size_;
  }

  degree_value::font_size_optional& degree_value::
  font_size ()
  {
    return this->font_size_;
  }

  void degree_value::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void degree_value::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void degree_value::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const degree_value::font_weight_optional& degree_value::
  font_weight () const
  {
    return this->font_weight_;
  }

  degree_value::font_weight_optional& degree_value::
  font_weight ()
  {
    return this->font_weight_;
  }

  void degree_value::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void degree_value::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void degree_value::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const degree_value::color_optional& degree_value::
  color () const
  {
    return this->color_;
  }

  degree_value::color_optional& degree_value::
  color ()
  {
    return this->color_;
  }

  void degree_value::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void degree_value::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void degree_value::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // direction
  // 

  const direction::direction_type_sequence& direction::
  direction_type () const
  {
    return this->direction_type_;
  }

  direction::direction_type_sequence& direction::
  direction_type ()
  {
    return this->direction_type_;
  }

  void direction::
  direction_type (const direction_type_sequence& s)
  {
    this->direction_type_ = s;
  }

  const direction::offset_optional& direction::
  offset () const
  {
    return this->offset_;
  }

  direction::offset_optional& direction::
  offset ()
  {
    return this->offset_;
  }

  void direction::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void direction::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void direction::
  offset (::std::unique_ptr< offset_type > x)
  {
    this->offset_.set (std::move (x));
  }

  const direction::footnote_optional& direction::
  footnote () const
  {
    return this->footnote_;
  }

  direction::footnote_optional& direction::
  footnote ()
  {
    return this->footnote_;
  }

  void direction::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void direction::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void direction::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const direction::level_optional& direction::
  level () const
  {
    return this->level_;
  }

  direction::level_optional& direction::
  level ()
  {
    return this->level_;
  }

  void direction::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void direction::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void direction::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const direction::voice_optional& direction::
  voice () const
  {
    return this->voice_;
  }

  direction::voice_optional& direction::
  voice ()
  {
    return this->voice_;
  }

  void direction::
  voice (const voice_type& x)
  {
    this->voice_.set (x);
  }

  void direction::
  voice (const voice_optional& x)
  {
    this->voice_ = x;
  }

  void direction::
  voice (::std::unique_ptr< voice_type > x)
  {
    this->voice_.set (std::move (x));
  }

  const direction::staff_optional& direction::
  staff () const
  {
    return this->staff_;
  }

  direction::staff_optional& direction::
  staff ()
  {
    return this->staff_;
  }

  void direction::
  staff (const staff_type& x)
  {
    this->staff_.set (x);
  }

  void direction::
  staff (const staff_optional& x)
  {
    this->staff_ = x;
  }

  const direction::sound_optional& direction::
  sound () const
  {
    return this->sound_;
  }

  direction::sound_optional& direction::
  sound ()
  {
    return this->sound_;
  }

  void direction::
  sound (const sound_type& x)
  {
    this->sound_.set (x);
  }

  void direction::
  sound (const sound_optional& x)
  {
    this->sound_ = x;
  }

  void direction::
  sound (::std::unique_ptr< sound_type > x)
  {
    this->sound_.set (std::move (x));
  }

  const direction::listening_optional& direction::
  listening () const
  {
    return this->listening_;
  }

  direction::listening_optional& direction::
  listening ()
  {
    return this->listening_;
  }

  void direction::
  listening (const listening_type& x)
  {
    this->listening_.set (x);
  }

  void direction::
  listening (const listening_optional& x)
  {
    this->listening_ = x;
  }

  void direction::
  listening (::std::unique_ptr< listening_type > x)
  {
    this->listening_.set (std::move (x));
  }

  const direction::placement_optional& direction::
  placement () const
  {
    return this->placement_;
  }

  direction::placement_optional& direction::
  placement ()
  {
    return this->placement_;
  }

  void direction::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void direction::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void direction::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const direction::directive_optional& direction::
  directive () const
  {
    return this->directive_;
  }

  direction::directive_optional& direction::
  directive ()
  {
    return this->directive_;
  }

  void direction::
  directive (const directive_type& x)
  {
    this->directive_.set (x);
  }

  void direction::
  directive (const directive_optional& x)
  {
    this->directive_ = x;
  }

  void direction::
  directive (::std::unique_ptr< directive_type > x)
  {
    this->directive_.set (std::move (x));
  }

  const direction::system_optional& direction::
  system () const
  {
    return this->system_;
  }

  direction::system_optional& direction::
  system ()
  {
    return this->system_;
  }

  void direction::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void direction::
  system (const system_optional& x)
  {
    this->system_ = x;
  }

  void direction::
  system (::std::unique_ptr< system_type > x)
  {
    this->system_.set (std::move (x));
  }

  const direction::id_optional& direction::
  id () const
  {
    return this->id_;
  }

  direction::id_optional& direction::
  id ()
  {
    return this->id_;
  }

  void direction::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void direction::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void direction::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // direction_type
  // 

  const direction_type::rehearsal_sequence& direction_type::
  rehearsal () const
  {
    return this->rehearsal_;
  }

  direction_type::rehearsal_sequence& direction_type::
  rehearsal ()
  {
    return this->rehearsal_;
  }

  void direction_type::
  rehearsal (const rehearsal_sequence& s)
  {
    this->rehearsal_ = s;
  }

  const direction_type::segno_sequence& direction_type::
  segno () const
  {
    return this->segno_;
  }

  direction_type::segno_sequence& direction_type::
  segno ()
  {
    return this->segno_;
  }

  void direction_type::
  segno (const segno_sequence& s)
  {
    this->segno_ = s;
  }

  const direction_type::coda_sequence& direction_type::
  coda () const
  {
    return this->coda_;
  }

  direction_type::coda_sequence& direction_type::
  coda ()
  {
    return this->coda_;
  }

  void direction_type::
  coda (const coda_sequence& s)
  {
    this->coda_ = s;
  }

  const direction_type::words_sequence& direction_type::
  words () const
  {
    return this->words_;
  }

  direction_type::words_sequence& direction_type::
  words ()
  {
    return this->words_;
  }

  void direction_type::
  words (const words_sequence& s)
  {
    this->words_ = s;
  }

  const direction_type::symbol_sequence& direction_type::
  symbol () const
  {
    return this->symbol_;
  }

  direction_type::symbol_sequence& direction_type::
  symbol ()
  {
    return this->symbol_;
  }

  void direction_type::
  symbol (const symbol_sequence& s)
  {
    this->symbol_ = s;
  }

  const direction_type::wedge_optional& direction_type::
  wedge () const
  {
    return this->wedge_;
  }

  direction_type::wedge_optional& direction_type::
  wedge ()
  {
    return this->wedge_;
  }

  void direction_type::
  wedge (const wedge_type& x)
  {
    this->wedge_.set (x);
  }

  void direction_type::
  wedge (const wedge_optional& x)
  {
    this->wedge_ = x;
  }

  void direction_type::
  wedge (::std::unique_ptr< wedge_type > x)
  {
    this->wedge_.set (std::move (x));
  }

  const direction_type::dynamics_sequence& direction_type::
  dynamics () const
  {
    return this->dynamics_;
  }

  direction_type::dynamics_sequence& direction_type::
  dynamics ()
  {
    return this->dynamics_;
  }

  void direction_type::
  dynamics (const dynamics_sequence& s)
  {
    this->dynamics_ = s;
  }

  const direction_type::dashes_optional& direction_type::
  dashes () const
  {
    return this->dashes_;
  }

  direction_type::dashes_optional& direction_type::
  dashes ()
  {
    return this->dashes_;
  }

  void direction_type::
  dashes (const dashes_type& x)
  {
    this->dashes_.set (x);
  }

  void direction_type::
  dashes (const dashes_optional& x)
  {
    this->dashes_ = x;
  }

  void direction_type::
  dashes (::std::unique_ptr< dashes_type > x)
  {
    this->dashes_.set (std::move (x));
  }

  const direction_type::bracket_optional& direction_type::
  bracket () const
  {
    return this->bracket_;
  }

  direction_type::bracket_optional& direction_type::
  bracket ()
  {
    return this->bracket_;
  }

  void direction_type::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void direction_type::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void direction_type::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const direction_type::pedal_optional& direction_type::
  pedal () const
  {
    return this->pedal_;
  }

  direction_type::pedal_optional& direction_type::
  pedal ()
  {
    return this->pedal_;
  }

  void direction_type::
  pedal (const pedal_type& x)
  {
    this->pedal_.set (x);
  }

  void direction_type::
  pedal (const pedal_optional& x)
  {
    this->pedal_ = x;
  }

  void direction_type::
  pedal (::std::unique_ptr< pedal_type > x)
  {
    this->pedal_.set (std::move (x));
  }

  const direction_type::metronome_optional& direction_type::
  metronome () const
  {
    return this->metronome_;
  }

  direction_type::metronome_optional& direction_type::
  metronome ()
  {
    return this->metronome_;
  }

  void direction_type::
  metronome (const metronome_type& x)
  {
    this->metronome_.set (x);
  }

  void direction_type::
  metronome (const metronome_optional& x)
  {
    this->metronome_ = x;
  }

  void direction_type::
  metronome (::std::unique_ptr< metronome_type > x)
  {
    this->metronome_.set (std::move (x));
  }

  const direction_type::octave_shift_optional& direction_type::
  octave_shift () const
  {
    return this->octave_shift_;
  }

  direction_type::octave_shift_optional& direction_type::
  octave_shift ()
  {
    return this->octave_shift_;
  }

  void direction_type::
  octave_shift (const octave_shift_type& x)
  {
    this->octave_shift_.set (x);
  }

  void direction_type::
  octave_shift (const octave_shift_optional& x)
  {
    this->octave_shift_ = x;
  }

  void direction_type::
  octave_shift (::std::unique_ptr< octave_shift_type > x)
  {
    this->octave_shift_.set (std::move (x));
  }

  const direction_type::harp_pedals_optional& direction_type::
  harp_pedals () const
  {
    return this->harp_pedals_;
  }

  direction_type::harp_pedals_optional& direction_type::
  harp_pedals ()
  {
    return this->harp_pedals_;
  }

  void direction_type::
  harp_pedals (const harp_pedals_type& x)
  {
    this->harp_pedals_.set (x);
  }

  void direction_type::
  harp_pedals (const harp_pedals_optional& x)
  {
    this->harp_pedals_ = x;
  }

  void direction_type::
  harp_pedals (::std::unique_ptr< harp_pedals_type > x)
  {
    this->harp_pedals_.set (std::move (x));
  }

  const direction_type::damp_optional& direction_type::
  damp () const
  {
    return this->damp_;
  }

  direction_type::damp_optional& direction_type::
  damp ()
  {
    return this->damp_;
  }

  void direction_type::
  damp (const damp_type& x)
  {
    this->damp_.set (x);
  }

  void direction_type::
  damp (const damp_optional& x)
  {
    this->damp_ = x;
  }

  void direction_type::
  damp (::std::unique_ptr< damp_type > x)
  {
    this->damp_.set (std::move (x));
  }

  const direction_type::damp_all_optional& direction_type::
  damp_all () const
  {
    return this->damp_all_;
  }

  direction_type::damp_all_optional& direction_type::
  damp_all ()
  {
    return this->damp_all_;
  }

  void direction_type::
  damp_all (const damp_all_type& x)
  {
    this->damp_all_.set (x);
  }

  void direction_type::
  damp_all (const damp_all_optional& x)
  {
    this->damp_all_ = x;
  }

  void direction_type::
  damp_all (::std::unique_ptr< damp_all_type > x)
  {
    this->damp_all_.set (std::move (x));
  }

  const direction_type::eyeglasses_optional& direction_type::
  eyeglasses () const
  {
    return this->eyeglasses_;
  }

  direction_type::eyeglasses_optional& direction_type::
  eyeglasses ()
  {
    return this->eyeglasses_;
  }

  void direction_type::
  eyeglasses (const eyeglasses_type& x)
  {
    this->eyeglasses_.set (x);
  }

  void direction_type::
  eyeglasses (const eyeglasses_optional& x)
  {
    this->eyeglasses_ = x;
  }

  void direction_type::
  eyeglasses (::std::unique_ptr< eyeglasses_type > x)
  {
    this->eyeglasses_.set (std::move (x));
  }

  const direction_type::string_mute_optional& direction_type::
  string_mute () const
  {
    return this->string_mute_;
  }

  direction_type::string_mute_optional& direction_type::
  string_mute ()
  {
    return this->string_mute_;
  }

  void direction_type::
  string_mute (const string_mute_type& x)
  {
    this->string_mute_.set (x);
  }

  void direction_type::
  string_mute (const string_mute_optional& x)
  {
    this->string_mute_ = x;
  }

  void direction_type::
  string_mute (::std::unique_ptr< string_mute_type > x)
  {
    this->string_mute_.set (std::move (x));
  }

  const direction_type::scordatura_optional& direction_type::
  scordatura () const
  {
    return this->scordatura_;
  }

  direction_type::scordatura_optional& direction_type::
  scordatura ()
  {
    return this->scordatura_;
  }

  void direction_type::
  scordatura (const scordatura_type& x)
  {
    this->scordatura_.set (x);
  }

  void direction_type::
  scordatura (const scordatura_optional& x)
  {
    this->scordatura_ = x;
  }

  void direction_type::
  scordatura (::std::unique_ptr< scordatura_type > x)
  {
    this->scordatura_.set (std::move (x));
  }

  const direction_type::image_optional& direction_type::
  image () const
  {
    return this->image_;
  }

  direction_type::image_optional& direction_type::
  image ()
  {
    return this->image_;
  }

  void direction_type::
  image (const image_type& x)
  {
    this->image_.set (x);
  }

  void direction_type::
  image (const image_optional& x)
  {
    this->image_ = x;
  }

  void direction_type::
  image (::std::unique_ptr< image_type > x)
  {
    this->image_.set (std::move (x));
  }

  const direction_type::principal_voice_optional& direction_type::
  principal_voice () const
  {
    return this->principal_voice_;
  }

  direction_type::principal_voice_optional& direction_type::
  principal_voice ()
  {
    return this->principal_voice_;
  }

  void direction_type::
  principal_voice (const principal_voice_type& x)
  {
    this->principal_voice_.set (x);
  }

  void direction_type::
  principal_voice (const principal_voice_optional& x)
  {
    this->principal_voice_ = x;
  }

  void direction_type::
  principal_voice (::std::unique_ptr< principal_voice_type > x)
  {
    this->principal_voice_.set (std::move (x));
  }

  const direction_type::percussion_sequence& direction_type::
  percussion () const
  {
    return this->percussion_;
  }

  direction_type::percussion_sequence& direction_type::
  percussion ()
  {
    return this->percussion_;
  }

  void direction_type::
  percussion (const percussion_sequence& s)
  {
    this->percussion_ = s;
  }

  const direction_type::accordion_registration_optional& direction_type::
  accordion_registration () const
  {
    return this->accordion_registration_;
  }

  direction_type::accordion_registration_optional& direction_type::
  accordion_registration ()
  {
    return this->accordion_registration_;
  }

  void direction_type::
  accordion_registration (const accordion_registration_type& x)
  {
    this->accordion_registration_.set (x);
  }

  void direction_type::
  accordion_registration (const accordion_registration_optional& x)
  {
    this->accordion_registration_ = x;
  }

  void direction_type::
  accordion_registration (::std::unique_ptr< accordion_registration_type > x)
  {
    this->accordion_registration_.set (std::move (x));
  }

  const direction_type::staff_divide_optional& direction_type::
  staff_divide () const
  {
    return this->staff_divide_;
  }

  direction_type::staff_divide_optional& direction_type::
  staff_divide ()
  {
    return this->staff_divide_;
  }

  void direction_type::
  staff_divide (const staff_divide_type& x)
  {
    this->staff_divide_.set (x);
  }

  void direction_type::
  staff_divide (const staff_divide_optional& x)
  {
    this->staff_divide_ = x;
  }

  void direction_type::
  staff_divide (::std::unique_ptr< staff_divide_type > x)
  {
    this->staff_divide_.set (std::move (x));
  }

  const direction_type::other_direction_optional& direction_type::
  other_direction () const
  {
    return this->other_direction_;
  }

  direction_type::other_direction_optional& direction_type::
  other_direction ()
  {
    return this->other_direction_;
  }

  void direction_type::
  other_direction (const other_direction_type& x)
  {
    this->other_direction_.set (x);
  }

  void direction_type::
  other_direction (const other_direction_optional& x)
  {
    this->other_direction_ = x;
  }

  void direction_type::
  other_direction (::std::unique_ptr< other_direction_type > x)
  {
    this->other_direction_.set (std::move (x));
  }

  const direction_type::id_optional& direction_type::
  id () const
  {
    return this->id_;
  }

  direction_type::id_optional& direction_type::
  id ()
  {
    return this->id_;
  }

  void direction_type::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void direction_type::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void direction_type::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // effect
  // 

  const effect::smufl_optional& effect::
  smufl () const
  {
    return this->smufl_;
  }

  effect::smufl_optional& effect::
  smufl ()
  {
    return this->smufl_;
  }

  void effect::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void effect::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void effect::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // feature
  // 

  const feature::type_optional& feature::
  type () const
  {
    return this->type_;
  }

  feature::type_optional& feature::
  type ()
  {
    return this->type_;
  }

  void feature::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void feature::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void feature::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // first_fret
  // 

  const first_fret::text_optional& first_fret::
  text () const
  {
    return this->text_;
  }

  first_fret::text_optional& first_fret::
  text ()
  {
    return this->text_;
  }

  void first_fret::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void first_fret::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void first_fret::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const first_fret::location_optional& first_fret::
  location () const
  {
    return this->location_;
  }

  first_fret::location_optional& first_fret::
  location ()
  {
    return this->location_;
  }

  void first_fret::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void first_fret::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void first_fret::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // frame
  // 

  const frame::frame_strings_type& frame::
  frame_strings () const
  {
    return this->frame_strings_.get ();
  }

  frame::frame_strings_type& frame::
  frame_strings ()
  {
    return this->frame_strings_.get ();
  }

  void frame::
  frame_strings (const frame_strings_type& x)
  {
    this->frame_strings_.set (x);
  }

  const frame::frame_frets_type& frame::
  frame_frets () const
  {
    return this->frame_frets_.get ();
  }

  frame::frame_frets_type& frame::
  frame_frets ()
  {
    return this->frame_frets_.get ();
  }

  void frame::
  frame_frets (const frame_frets_type& x)
  {
    this->frame_frets_.set (x);
  }

  const frame::first_fret_optional& frame::
  first_fret () const
  {
    return this->first_fret_;
  }

  frame::first_fret_optional& frame::
  first_fret ()
  {
    return this->first_fret_;
  }

  void frame::
  first_fret (const first_fret_type& x)
  {
    this->first_fret_.set (x);
  }

  void frame::
  first_fret (const first_fret_optional& x)
  {
    this->first_fret_ = x;
  }

  void frame::
  first_fret (::std::unique_ptr< first_fret_type > x)
  {
    this->first_fret_.set (std::move (x));
  }

  const frame::frame_note_sequence& frame::
  frame_note () const
  {
    return this->frame_note_;
  }

  frame::frame_note_sequence& frame::
  frame_note ()
  {
    return this->frame_note_;
  }

  void frame::
  frame_note (const frame_note_sequence& s)
  {
    this->frame_note_ = s;
  }

  const frame::default_x_optional& frame::
  default_x () const
  {
    return this->default_x_;
  }

  frame::default_x_optional& frame::
  default_x ()
  {
    return this->default_x_;
  }

  void frame::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void frame::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void frame::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const frame::default_y_optional& frame::
  default_y () const
  {
    return this->default_y_;
  }

  frame::default_y_optional& frame::
  default_y ()
  {
    return this->default_y_;
  }

  void frame::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void frame::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void frame::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const frame::relative_x_optional& frame::
  relative_x () const
  {
    return this->relative_x_;
  }

  frame::relative_x_optional& frame::
  relative_x ()
  {
    return this->relative_x_;
  }

  void frame::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void frame::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void frame::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const frame::relative_y_optional& frame::
  relative_y () const
  {
    return this->relative_y_;
  }

  frame::relative_y_optional& frame::
  relative_y ()
  {
    return this->relative_y_;
  }

  void frame::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void frame::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void frame::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const frame::color_optional& frame::
  color () const
  {
    return this->color_;
  }

  frame::color_optional& frame::
  color ()
  {
    return this->color_;
  }

  void frame::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void frame::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void frame::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const frame::halign_optional& frame::
  halign () const
  {
    return this->halign_;
  }

  frame::halign_optional& frame::
  halign ()
  {
    return this->halign_;
  }

  void frame::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void frame::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void frame::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const frame::valign_optional& frame::
  valign () const
  {
    return this->valign_;
  }

  frame::valign_optional& frame::
  valign ()
  {
    return this->valign_;
  }

  void frame::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void frame::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void frame::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const frame::height_optional& frame::
  height () const
  {
    return this->height_;
  }

  frame::height_optional& frame::
  height ()
  {
    return this->height_;
  }

  void frame::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void frame::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void frame::
  height (::std::unique_ptr< height_type > x)
  {
    this->height_.set (std::move (x));
  }

  const frame::width_optional& frame::
  width () const
  {
    return this->width_;
  }

  frame::width_optional& frame::
  width ()
  {
    return this->width_;
  }

  void frame::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void frame::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void frame::
  width (::std::unique_ptr< width_type > x)
  {
    this->width_.set (std::move (x));
  }

  const frame::unplayed_optional& frame::
  unplayed () const
  {
    return this->unplayed_;
  }

  frame::unplayed_optional& frame::
  unplayed ()
  {
    return this->unplayed_;
  }

  void frame::
  unplayed (const unplayed_type& x)
  {
    this->unplayed_.set (x);
  }

  void frame::
  unplayed (const unplayed_optional& x)
  {
    this->unplayed_ = x;
  }

  void frame::
  unplayed (::std::unique_ptr< unplayed_type > x)
  {
    this->unplayed_.set (std::move (x));
  }

  const frame::id_optional& frame::
  id () const
  {
    return this->id_;
  }

  frame::id_optional& frame::
  id ()
  {
    return this->id_;
  }

  void frame::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void frame::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void frame::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // frame_note
  // 

  const frame_note::string_type& frame_note::
  string () const
  {
    return this->string_.get ();
  }

  frame_note::string_type& frame_note::
  string ()
  {
    return this->string_.get ();
  }

  void frame_note::
  string (const string_type& x)
  {
    this->string_.set (x);
  }

  void frame_note::
  string (::std::unique_ptr< string_type > x)
  {
    this->string_.set (std::move (x));
  }

  const frame_note::fret_type& frame_note::
  fret () const
  {
    return this->fret_.get ();
  }

  frame_note::fret_type& frame_note::
  fret ()
  {
    return this->fret_.get ();
  }

  void frame_note::
  fret (const fret_type& x)
  {
    this->fret_.set (x);
  }

  void frame_note::
  fret (::std::unique_ptr< fret_type > x)
  {
    this->fret_.set (std::move (x));
  }

  const frame_note::fingering_optional& frame_note::
  fingering () const
  {
    return this->fingering_;
  }

  frame_note::fingering_optional& frame_note::
  fingering ()
  {
    return this->fingering_;
  }

  void frame_note::
  fingering (const fingering_type& x)
  {
    this->fingering_.set (x);
  }

  void frame_note::
  fingering (const fingering_optional& x)
  {
    this->fingering_ = x;
  }

  void frame_note::
  fingering (::std::unique_ptr< fingering_type > x)
  {
    this->fingering_.set (std::move (x));
  }

  const frame_note::barre_optional& frame_note::
  barre () const
  {
    return this->barre_;
  }

  frame_note::barre_optional& frame_note::
  barre ()
  {
    return this->barre_;
  }

  void frame_note::
  barre (const barre_type& x)
  {
    this->barre_.set (x);
  }

  void frame_note::
  barre (const barre_optional& x)
  {
    this->barre_ = x;
  }

  void frame_note::
  barre (::std::unique_ptr< barre_type > x)
  {
    this->barre_.set (std::move (x));
  }


  // glass
  // 

  const glass::smufl_optional& glass::
  smufl () const
  {
    return this->smufl_;
  }

  glass::smufl_optional& glass::
  smufl ()
  {
    return this->smufl_;
  }

  void glass::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void glass::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void glass::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // grouping
  // 

  const grouping::feature_sequence& grouping::
  feature () const
  {
    return this->feature_;
  }

  grouping::feature_sequence& grouping::
  feature ()
  {
    return this->feature_;
  }

  void grouping::
  feature (const feature_sequence& s)
  {
    this->feature_ = s;
  }

  const grouping::type_type& grouping::
  type () const
  {
    return this->type_.get ();
  }

  grouping::type_type& grouping::
  type ()
  {
    return this->type_.get ();
  }

  void grouping::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void grouping::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const grouping::number_type& grouping::
  number () const
  {
    return this->number_.get ();
  }

  grouping::number_type& grouping::
  number ()
  {
    return this->number_.get ();
  }

  void grouping::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void grouping::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const grouping::number_type& grouping::
  number_default_value ()
  {
    return number_default_value_;
  }

  const grouping::member_of_optional& grouping::
  member_of () const
  {
    return this->member_of_;
  }

  grouping::member_of_optional& grouping::
  member_of ()
  {
    return this->member_of_;
  }

  void grouping::
  member_of (const member_of_type& x)
  {
    this->member_of_.set (x);
  }

  void grouping::
  member_of (const member_of_optional& x)
  {
    this->member_of_ = x;
  }

  void grouping::
  member_of (::std::unique_ptr< member_of_type > x)
  {
    this->member_of_.set (std::move (x));
  }

  const grouping::id_optional& grouping::
  id () const
  {
    return this->id_;
  }

  grouping::id_optional& grouping::
  id ()
  {
    return this->id_;
  }

  void grouping::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void grouping::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void grouping::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // harmony
  // 

  const harmony::root_sequence& harmony::
  root () const
  {
    return this->root_;
  }

  harmony::root_sequence& harmony::
  root ()
  {
    return this->root_;
  }

  void harmony::
  root (const root_sequence& s)
  {
    this->root_ = s;
  }

  const harmony::numeral_sequence& harmony::
  numeral () const
  {
    return this->numeral_;
  }

  harmony::numeral_sequence& harmony::
  numeral ()
  {
    return this->numeral_;
  }

  void harmony::
  numeral (const numeral_sequence& s)
  {
    this->numeral_ = s;
  }

  const harmony::function_sequence& harmony::
  function () const
  {
    return this->function_;
  }

  harmony::function_sequence& harmony::
  function ()
  {
    return this->function_;
  }

  void harmony::
  function (const function_sequence& s)
  {
    this->function_ = s;
  }

  const harmony::kind_sequence& harmony::
  kind () const
  {
    return this->kind_;
  }

  harmony::kind_sequence& harmony::
  kind ()
  {
    return this->kind_;
  }

  void harmony::
  kind (const kind_sequence& s)
  {
    this->kind_ = s;
  }

  const harmony::inversion_sequence& harmony::
  inversion () const
  {
    return this->inversion_;
  }

  harmony::inversion_sequence& harmony::
  inversion ()
  {
    return this->inversion_;
  }

  void harmony::
  inversion (const inversion_sequence& s)
  {
    this->inversion_ = s;
  }

  const harmony::bass_sequence& harmony::
  bass () const
  {
    return this->bass_;
  }

  harmony::bass_sequence& harmony::
  bass ()
  {
    return this->bass_;
  }

  void harmony::
  bass (const bass_sequence& s)
  {
    this->bass_ = s;
  }

  const harmony::degree_sequence& harmony::
  degree () const
  {
    return this->degree_;
  }

  harmony::degree_sequence& harmony::
  degree ()
  {
    return this->degree_;
  }

  void harmony::
  degree (const degree_sequence& s)
  {
    this->degree_ = s;
  }

  const harmony::frame_optional& harmony::
  frame () const
  {
    return this->frame_;
  }

  harmony::frame_optional& harmony::
  frame ()
  {
    return this->frame_;
  }

  void harmony::
  frame (const frame_type& x)
  {
    this->frame_.set (x);
  }

  void harmony::
  frame (const frame_optional& x)
  {
    this->frame_ = x;
  }

  void harmony::
  frame (::std::unique_ptr< frame_type > x)
  {
    this->frame_.set (std::move (x));
  }

  const harmony::offset_optional& harmony::
  offset () const
  {
    return this->offset_;
  }

  harmony::offset_optional& harmony::
  offset ()
  {
    return this->offset_;
  }

  void harmony::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void harmony::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void harmony::
  offset (::std::unique_ptr< offset_type > x)
  {
    this->offset_.set (std::move (x));
  }

  const harmony::footnote_optional& harmony::
  footnote () const
  {
    return this->footnote_;
  }

  harmony::footnote_optional& harmony::
  footnote ()
  {
    return this->footnote_;
  }

  void harmony::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void harmony::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void harmony::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const harmony::level_optional& harmony::
  level () const
  {
    return this->level_;
  }

  harmony::level_optional& harmony::
  level ()
  {
    return this->level_;
  }

  void harmony::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void harmony::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void harmony::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const harmony::staff_optional& harmony::
  staff () const
  {
    return this->staff_;
  }

  harmony::staff_optional& harmony::
  staff ()
  {
    return this->staff_;
  }

  void harmony::
  staff (const staff_type& x)
  {
    this->staff_.set (x);
  }

  void harmony::
  staff (const staff_optional& x)
  {
    this->staff_ = x;
  }

  const harmony::type_optional& harmony::
  type () const
  {
    return this->type_;
  }

  harmony::type_optional& harmony::
  type ()
  {
    return this->type_;
  }

  void harmony::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void harmony::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void harmony::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const harmony::print_object_optional& harmony::
  print_object () const
  {
    return this->print_object_;
  }

  harmony::print_object_optional& harmony::
  print_object ()
  {
    return this->print_object_;
  }

  void harmony::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void harmony::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void harmony::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const harmony::print_frame_optional& harmony::
  print_frame () const
  {
    return this->print_frame_;
  }

  harmony::print_frame_optional& harmony::
  print_frame ()
  {
    return this->print_frame_;
  }

  void harmony::
  print_frame (const print_frame_type& x)
  {
    this->print_frame_.set (x);
  }

  void harmony::
  print_frame (const print_frame_optional& x)
  {
    this->print_frame_ = x;
  }

  void harmony::
  print_frame (::std::unique_ptr< print_frame_type > x)
  {
    this->print_frame_.set (std::move (x));
  }

  const harmony::arrangement_optional& harmony::
  arrangement () const
  {
    return this->arrangement_;
  }

  harmony::arrangement_optional& harmony::
  arrangement ()
  {
    return this->arrangement_;
  }

  void harmony::
  arrangement (const arrangement_type& x)
  {
    this->arrangement_.set (x);
  }

  void harmony::
  arrangement (const arrangement_optional& x)
  {
    this->arrangement_ = x;
  }

  void harmony::
  arrangement (::std::unique_ptr< arrangement_type > x)
  {
    this->arrangement_.set (std::move (x));
  }

  const harmony::default_x_optional& harmony::
  default_x () const
  {
    return this->default_x_;
  }

  harmony::default_x_optional& harmony::
  default_x ()
  {
    return this->default_x_;
  }

  void harmony::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void harmony::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void harmony::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const harmony::default_y_optional& harmony::
  default_y () const
  {
    return this->default_y_;
  }

  harmony::default_y_optional& harmony::
  default_y ()
  {
    return this->default_y_;
  }

  void harmony::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void harmony::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void harmony::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const harmony::relative_x_optional& harmony::
  relative_x () const
  {
    return this->relative_x_;
  }

  harmony::relative_x_optional& harmony::
  relative_x ()
  {
    return this->relative_x_;
  }

  void harmony::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void harmony::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void harmony::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const harmony::relative_y_optional& harmony::
  relative_y () const
  {
    return this->relative_y_;
  }

  harmony::relative_y_optional& harmony::
  relative_y ()
  {
    return this->relative_y_;
  }

  void harmony::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void harmony::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void harmony::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const harmony::font_family_optional& harmony::
  font_family () const
  {
    return this->font_family_;
  }

  harmony::font_family_optional& harmony::
  font_family ()
  {
    return this->font_family_;
  }

  void harmony::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void harmony::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void harmony::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const harmony::font_style_optional& harmony::
  font_style () const
  {
    return this->font_style_;
  }

  harmony::font_style_optional& harmony::
  font_style ()
  {
    return this->font_style_;
  }

  void harmony::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void harmony::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void harmony::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const harmony::font_size_optional& harmony::
  font_size () const
  {
    return this->font_size_;
  }

  harmony::font_size_optional& harmony::
  font_size ()
  {
    return this->font_size_;
  }

  void harmony::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void harmony::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void harmony::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const harmony::font_weight_optional& harmony::
  font_weight () const
  {
    return this->font_weight_;
  }

  harmony::font_weight_optional& harmony::
  font_weight ()
  {
    return this->font_weight_;
  }

  void harmony::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void harmony::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void harmony::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const harmony::color_optional& harmony::
  color () const
  {
    return this->color_;
  }

  harmony::color_optional& harmony::
  color ()
  {
    return this->color_;
  }

  void harmony::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void harmony::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void harmony::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const harmony::placement_optional& harmony::
  placement () const
  {
    return this->placement_;
  }

  harmony::placement_optional& harmony::
  placement ()
  {
    return this->placement_;
  }

  void harmony::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void harmony::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void harmony::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const harmony::system_optional& harmony::
  system () const
  {
    return this->system_;
  }

  harmony::system_optional& harmony::
  system ()
  {
    return this->system_;
  }

  void harmony::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void harmony::
  system (const system_optional& x)
  {
    this->system_ = x;
  }

  void harmony::
  system (::std::unique_ptr< system_type > x)
  {
    this->system_.set (std::move (x));
  }

  const harmony::id_optional& harmony::
  id () const
  {
    return this->id_;
  }

  harmony::id_optional& harmony::
  id ()
  {
    return this->id_;
  }

  void harmony::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void harmony::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void harmony::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // harp_pedals
  // 

  const harp_pedals::pedal_tuning_sequence& harp_pedals::
  pedal_tuning () const
  {
    return this->pedal_tuning_;
  }

  harp_pedals::pedal_tuning_sequence& harp_pedals::
  pedal_tuning ()
  {
    return this->pedal_tuning_;
  }

  void harp_pedals::
  pedal_tuning (const pedal_tuning_sequence& s)
  {
    this->pedal_tuning_ = s;
  }

  const harp_pedals::default_x_optional& harp_pedals::
  default_x () const
  {
    return this->default_x_;
  }

  harp_pedals::default_x_optional& harp_pedals::
  default_x ()
  {
    return this->default_x_;
  }

  void harp_pedals::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void harp_pedals::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void harp_pedals::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const harp_pedals::default_y_optional& harp_pedals::
  default_y () const
  {
    return this->default_y_;
  }

  harp_pedals::default_y_optional& harp_pedals::
  default_y ()
  {
    return this->default_y_;
  }

  void harp_pedals::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void harp_pedals::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void harp_pedals::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const harp_pedals::relative_x_optional& harp_pedals::
  relative_x () const
  {
    return this->relative_x_;
  }

  harp_pedals::relative_x_optional& harp_pedals::
  relative_x ()
  {
    return this->relative_x_;
  }

  void harp_pedals::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void harp_pedals::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void harp_pedals::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const harp_pedals::relative_y_optional& harp_pedals::
  relative_y () const
  {
    return this->relative_y_;
  }

  harp_pedals::relative_y_optional& harp_pedals::
  relative_y ()
  {
    return this->relative_y_;
  }

  void harp_pedals::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void harp_pedals::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void harp_pedals::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const harp_pedals::font_family_optional& harp_pedals::
  font_family () const
  {
    return this->font_family_;
  }

  harp_pedals::font_family_optional& harp_pedals::
  font_family ()
  {
    return this->font_family_;
  }

  void harp_pedals::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void harp_pedals::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void harp_pedals::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const harp_pedals::font_style_optional& harp_pedals::
  font_style () const
  {
    return this->font_style_;
  }

  harp_pedals::font_style_optional& harp_pedals::
  font_style ()
  {
    return this->font_style_;
  }

  void harp_pedals::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void harp_pedals::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void harp_pedals::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const harp_pedals::font_size_optional& harp_pedals::
  font_size () const
  {
    return this->font_size_;
  }

  harp_pedals::font_size_optional& harp_pedals::
  font_size ()
  {
    return this->font_size_;
  }

  void harp_pedals::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void harp_pedals::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void harp_pedals::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const harp_pedals::font_weight_optional& harp_pedals::
  font_weight () const
  {
    return this->font_weight_;
  }

  harp_pedals::font_weight_optional& harp_pedals::
  font_weight ()
  {
    return this->font_weight_;
  }

  void harp_pedals::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void harp_pedals::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void harp_pedals::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const harp_pedals::color_optional& harp_pedals::
  color () const
  {
    return this->color_;
  }

  harp_pedals::color_optional& harp_pedals::
  color ()
  {
    return this->color_;
  }

  void harp_pedals::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void harp_pedals::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void harp_pedals::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const harp_pedals::halign_optional& harp_pedals::
  halign () const
  {
    return this->halign_;
  }

  harp_pedals::halign_optional& harp_pedals::
  halign ()
  {
    return this->halign_;
  }

  void harp_pedals::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void harp_pedals::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void harp_pedals::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const harp_pedals::valign_optional& harp_pedals::
  valign () const
  {
    return this->valign_;
  }

  harp_pedals::valign_optional& harp_pedals::
  valign ()
  {
    return this->valign_;
  }

  void harp_pedals::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void harp_pedals::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void harp_pedals::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const harp_pedals::id_optional& harp_pedals::
  id () const
  {
    return this->id_;
  }

  harp_pedals::id_optional& harp_pedals::
  id ()
  {
    return this->id_;
  }

  void harp_pedals::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void harp_pedals::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void harp_pedals::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // image
  // 

  const image::source_type& image::
  source () const
  {
    return this->source_.get ();
  }

  image::source_type& image::
  source ()
  {
    return this->source_.get ();
  }

  void image::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void image::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }

  const image::type_type& image::
  type () const
  {
    return this->type_.get ();
  }

  image::type_type& image::
  type ()
  {
    return this->type_.get ();
  }

  void image::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void image::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const image::height_optional& image::
  height () const
  {
    return this->height_;
  }

  image::height_optional& image::
  height ()
  {
    return this->height_;
  }

  void image::
  height (const height_type& x)
  {
    this->height_.set (x);
  }

  void image::
  height (const height_optional& x)
  {
    this->height_ = x;
  }

  void image::
  height (::std::unique_ptr< height_type > x)
  {
    this->height_.set (std::move (x));
  }

  const image::width_optional& image::
  width () const
  {
    return this->width_;
  }

  image::width_optional& image::
  width ()
  {
    return this->width_;
  }

  void image::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void image::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void image::
  width (::std::unique_ptr< width_type > x)
  {
    this->width_.set (std::move (x));
  }

  const image::default_x_optional& image::
  default_x () const
  {
    return this->default_x_;
  }

  image::default_x_optional& image::
  default_x ()
  {
    return this->default_x_;
  }

  void image::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void image::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void image::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const image::default_y_optional& image::
  default_y () const
  {
    return this->default_y_;
  }

  image::default_y_optional& image::
  default_y ()
  {
    return this->default_y_;
  }

  void image::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void image::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void image::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const image::relative_x_optional& image::
  relative_x () const
  {
    return this->relative_x_;
  }

  image::relative_x_optional& image::
  relative_x ()
  {
    return this->relative_x_;
  }

  void image::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void image::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void image::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const image::relative_y_optional& image::
  relative_y () const
  {
    return this->relative_y_;
  }

  image::relative_y_optional& image::
  relative_y ()
  {
    return this->relative_y_;
  }

  void image::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void image::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void image::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const image::halign_optional& image::
  halign () const
  {
    return this->halign_;
  }

  image::halign_optional& image::
  halign ()
  {
    return this->halign_;
  }

  void image::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void image::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void image::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const image::valign_optional& image::
  valign () const
  {
    return this->valign_;
  }

  image::valign_optional& image::
  valign ()
  {
    return this->valign_;
  }

  void image::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void image::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void image::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const image::id_optional& image::
  id () const
  {
    return this->id_;
  }

  image::id_optional& image::
  id ()
  {
    return this->id_;
  }

  void image::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void image::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void image::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // instrument_change
  // 

  const instrument_change::instrument_sound_optional& instrument_change::
  instrument_sound () const
  {
    return this->instrument_sound_;
  }

  instrument_change::instrument_sound_optional& instrument_change::
  instrument_sound ()
  {
    return this->instrument_sound_;
  }

  void instrument_change::
  instrument_sound (const instrument_sound_type& x)
  {
    this->instrument_sound_.set (x);
  }

  void instrument_change::
  instrument_sound (const instrument_sound_optional& x)
  {
    this->instrument_sound_ = x;
  }

  void instrument_change::
  instrument_sound (::std::unique_ptr< instrument_sound_type > x)
  {
    this->instrument_sound_.set (std::move (x));
  }

  const instrument_change::solo_optional& instrument_change::
  solo () const
  {
    return this->solo_;
  }

  instrument_change::solo_optional& instrument_change::
  solo ()
  {
    return this->solo_;
  }

  void instrument_change::
  solo (const solo_type& x)
  {
    this->solo_.set (x);
  }

  void instrument_change::
  solo (const solo_optional& x)
  {
    this->solo_ = x;
  }

  void instrument_change::
  solo (::std::unique_ptr< solo_type > x)
  {
    this->solo_.set (std::move (x));
  }

  const instrument_change::ensemble_optional& instrument_change::
  ensemble () const
  {
    return this->ensemble_;
  }

  instrument_change::ensemble_optional& instrument_change::
  ensemble ()
  {
    return this->ensemble_;
  }

  void instrument_change::
  ensemble (const ensemble_type& x)
  {
    this->ensemble_.set (x);
  }

  void instrument_change::
  ensemble (const ensemble_optional& x)
  {
    this->ensemble_ = x;
  }

  void instrument_change::
  ensemble (::std::unique_ptr< ensemble_type > x)
  {
    this->ensemble_.set (std::move (x));
  }

  const instrument_change::virtual_instrument_optional& instrument_change::
  virtual_instrument () const
  {
    return this->virtual_instrument_;
  }

  instrument_change::virtual_instrument_optional& instrument_change::
  virtual_instrument ()
  {
    return this->virtual_instrument_;
  }

  void instrument_change::
  virtual_instrument (const virtual_instrument_type& x)
  {
    this->virtual_instrument_.set (x);
  }

  void instrument_change::
  virtual_instrument (const virtual_instrument_optional& x)
  {
    this->virtual_instrument_ = x;
  }

  void instrument_change::
  virtual_instrument (::std::unique_ptr< virtual_instrument_type > x)
  {
    this->virtual_instrument_.set (std::move (x));
  }

  const instrument_change::id_type& instrument_change::
  id () const
  {
    return this->id_.get ();
  }

  instrument_change::id_type& instrument_change::
  id ()
  {
    return this->id_.get ();
  }

  void instrument_change::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void instrument_change::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // inversion
  // 

  const inversion::text_optional& inversion::
  text () const
  {
    return this->text_;
  }

  inversion::text_optional& inversion::
  text ()
  {
    return this->text_;
  }

  void inversion::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void inversion::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void inversion::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const inversion::default_x_optional& inversion::
  default_x () const
  {
    return this->default_x_;
  }

  inversion::default_x_optional& inversion::
  default_x ()
  {
    return this->default_x_;
  }

  void inversion::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void inversion::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void inversion::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const inversion::default_y_optional& inversion::
  default_y () const
  {
    return this->default_y_;
  }

  inversion::default_y_optional& inversion::
  default_y ()
  {
    return this->default_y_;
  }

  void inversion::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void inversion::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void inversion::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const inversion::relative_x_optional& inversion::
  relative_x () const
  {
    return this->relative_x_;
  }

  inversion::relative_x_optional& inversion::
  relative_x ()
  {
    return this->relative_x_;
  }

  void inversion::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void inversion::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void inversion::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const inversion::relative_y_optional& inversion::
  relative_y () const
  {
    return this->relative_y_;
  }

  inversion::relative_y_optional& inversion::
  relative_y ()
  {
    return this->relative_y_;
  }

  void inversion::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void inversion::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void inversion::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const inversion::font_family_optional& inversion::
  font_family () const
  {
    return this->font_family_;
  }

  inversion::font_family_optional& inversion::
  font_family ()
  {
    return this->font_family_;
  }

  void inversion::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void inversion::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void inversion::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const inversion::font_style_optional& inversion::
  font_style () const
  {
    return this->font_style_;
  }

  inversion::font_style_optional& inversion::
  font_style ()
  {
    return this->font_style_;
  }

  void inversion::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void inversion::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void inversion::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const inversion::font_size_optional& inversion::
  font_size () const
  {
    return this->font_size_;
  }

  inversion::font_size_optional& inversion::
  font_size ()
  {
    return this->font_size_;
  }

  void inversion::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void inversion::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void inversion::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const inversion::font_weight_optional& inversion::
  font_weight () const
  {
    return this->font_weight_;
  }

  inversion::font_weight_optional& inversion::
  font_weight ()
  {
    return this->font_weight_;
  }

  void inversion::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void inversion::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void inversion::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const inversion::color_optional& inversion::
  color () const
  {
    return this->color_;
  }

  inversion::color_optional& inversion::
  color ()
  {
    return this->color_;
  }

  void inversion::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void inversion::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void inversion::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // kind
  // 

  const kind::use_symbols_optional& kind::
  use_symbols () const
  {
    return this->use_symbols_;
  }

  kind::use_symbols_optional& kind::
  use_symbols ()
  {
    return this->use_symbols_;
  }

  void kind::
  use_symbols (const use_symbols_type& x)
  {
    this->use_symbols_.set (x);
  }

  void kind::
  use_symbols (const use_symbols_optional& x)
  {
    this->use_symbols_ = x;
  }

  void kind::
  use_symbols (::std::unique_ptr< use_symbols_type > x)
  {
    this->use_symbols_.set (std::move (x));
  }

  const kind::text_optional& kind::
  text () const
  {
    return this->text_;
  }

  kind::text_optional& kind::
  text ()
  {
    return this->text_;
  }

  void kind::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void kind::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void kind::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const kind::stack_degrees_optional& kind::
  stack_degrees () const
  {
    return this->stack_degrees_;
  }

  kind::stack_degrees_optional& kind::
  stack_degrees ()
  {
    return this->stack_degrees_;
  }

  void kind::
  stack_degrees (const stack_degrees_type& x)
  {
    this->stack_degrees_.set (x);
  }

  void kind::
  stack_degrees (const stack_degrees_optional& x)
  {
    this->stack_degrees_ = x;
  }

  void kind::
  stack_degrees (::std::unique_ptr< stack_degrees_type > x)
  {
    this->stack_degrees_.set (std::move (x));
  }

  const kind::parentheses_degrees_optional& kind::
  parentheses_degrees () const
  {
    return this->parentheses_degrees_;
  }

  kind::parentheses_degrees_optional& kind::
  parentheses_degrees ()
  {
    return this->parentheses_degrees_;
  }

  void kind::
  parentheses_degrees (const parentheses_degrees_type& x)
  {
    this->parentheses_degrees_.set (x);
  }

  void kind::
  parentheses_degrees (const parentheses_degrees_optional& x)
  {
    this->parentheses_degrees_ = x;
  }

  void kind::
  parentheses_degrees (::std::unique_ptr< parentheses_degrees_type > x)
  {
    this->parentheses_degrees_.set (std::move (x));
  }

  const kind::bracket_degrees_optional& kind::
  bracket_degrees () const
  {
    return this->bracket_degrees_;
  }

  kind::bracket_degrees_optional& kind::
  bracket_degrees ()
  {
    return this->bracket_degrees_;
  }

  void kind::
  bracket_degrees (const bracket_degrees_type& x)
  {
    this->bracket_degrees_.set (x);
  }

  void kind::
  bracket_degrees (const bracket_degrees_optional& x)
  {
    this->bracket_degrees_ = x;
  }

  void kind::
  bracket_degrees (::std::unique_ptr< bracket_degrees_type > x)
  {
    this->bracket_degrees_.set (std::move (x));
  }

  const kind::default_x_optional& kind::
  default_x () const
  {
    return this->default_x_;
  }

  kind::default_x_optional& kind::
  default_x ()
  {
    return this->default_x_;
  }

  void kind::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void kind::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void kind::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const kind::default_y_optional& kind::
  default_y () const
  {
    return this->default_y_;
  }

  kind::default_y_optional& kind::
  default_y ()
  {
    return this->default_y_;
  }

  void kind::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void kind::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void kind::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const kind::relative_x_optional& kind::
  relative_x () const
  {
    return this->relative_x_;
  }

  kind::relative_x_optional& kind::
  relative_x ()
  {
    return this->relative_x_;
  }

  void kind::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void kind::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void kind::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const kind::relative_y_optional& kind::
  relative_y () const
  {
    return this->relative_y_;
  }

  kind::relative_y_optional& kind::
  relative_y ()
  {
    return this->relative_y_;
  }

  void kind::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void kind::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void kind::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const kind::font_family_optional& kind::
  font_family () const
  {
    return this->font_family_;
  }

  kind::font_family_optional& kind::
  font_family ()
  {
    return this->font_family_;
  }

  void kind::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void kind::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void kind::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const kind::font_style_optional& kind::
  font_style () const
  {
    return this->font_style_;
  }

  kind::font_style_optional& kind::
  font_style ()
  {
    return this->font_style_;
  }

  void kind::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void kind::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void kind::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const kind::font_size_optional& kind::
  font_size () const
  {
    return this->font_size_;
  }

  kind::font_size_optional& kind::
  font_size ()
  {
    return this->font_size_;
  }

  void kind::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void kind::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void kind::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const kind::font_weight_optional& kind::
  font_weight () const
  {
    return this->font_weight_;
  }

  kind::font_weight_optional& kind::
  font_weight ()
  {
    return this->font_weight_;
  }

  void kind::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void kind::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void kind::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const kind::color_optional& kind::
  color () const
  {
    return this->color_;
  }

  kind::color_optional& kind::
  color ()
  {
    return this->color_;
  }

  void kind::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void kind::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void kind::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const kind::halign_optional& kind::
  halign () const
  {
    return this->halign_;
  }

  kind::halign_optional& kind::
  halign ()
  {
    return this->halign_;
  }

  void kind::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void kind::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void kind::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const kind::valign_optional& kind::
  valign () const
  {
    return this->valign_;
  }

  kind::valign_optional& kind::
  valign ()
  {
    return this->valign_;
  }

  void kind::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void kind::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void kind::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }


  // listening
  // 

  const listening::sync_sequence& listening::
  sync () const
  {
    return this->sync_;
  }

  listening::sync_sequence& listening::
  sync ()
  {
    return this->sync_;
  }

  void listening::
  sync (const sync_sequence& s)
  {
    this->sync_ = s;
  }

  const listening::other_listening_sequence& listening::
  other_listening () const
  {
    return this->other_listening_;
  }

  listening::other_listening_sequence& listening::
  other_listening ()
  {
    return this->other_listening_;
  }

  void listening::
  other_listening (const other_listening_sequence& s)
  {
    this->other_listening_ = s;
  }

  const listening::offset_optional& listening::
  offset () const
  {
    return this->offset_;
  }

  listening::offset_optional& listening::
  offset ()
  {
    return this->offset_;
  }

  void listening::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void listening::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void listening::
  offset (::std::unique_ptr< offset_type > x)
  {
    this->offset_.set (std::move (x));
  }


  // measure_numbering
  // 

  const measure_numbering::system_optional& measure_numbering::
  system () const
  {
    return this->system_;
  }

  measure_numbering::system_optional& measure_numbering::
  system ()
  {
    return this->system_;
  }

  void measure_numbering::
  system (const system_type& x)
  {
    this->system_.set (x);
  }

  void measure_numbering::
  system (const system_optional& x)
  {
    this->system_ = x;
  }

  void measure_numbering::
  system (::std::unique_ptr< system_type > x)
  {
    this->system_.set (std::move (x));
  }

  const measure_numbering::staff_optional& measure_numbering::
  staff () const
  {
    return this->staff_;
  }

  measure_numbering::staff_optional& measure_numbering::
  staff ()
  {
    return this->staff_;
  }

  void measure_numbering::
  staff (const staff_type& x)
  {
    this->staff_.set (x);
  }

  void measure_numbering::
  staff (const staff_optional& x)
  {
    this->staff_ = x;
  }

  void measure_numbering::
  staff (::std::unique_ptr< staff_type > x)
  {
    this->staff_.set (std::move (x));
  }

  const measure_numbering::multiple_rest_always_optional& measure_numbering::
  multiple_rest_always () const
  {
    return this->multiple_rest_always_;
  }

  measure_numbering::multiple_rest_always_optional& measure_numbering::
  multiple_rest_always ()
  {
    return this->multiple_rest_always_;
  }

  void measure_numbering::
  multiple_rest_always (const multiple_rest_always_type& x)
  {
    this->multiple_rest_always_.set (x);
  }

  void measure_numbering::
  multiple_rest_always (const multiple_rest_always_optional& x)
  {
    this->multiple_rest_always_ = x;
  }

  void measure_numbering::
  multiple_rest_always (::std::unique_ptr< multiple_rest_always_type > x)
  {
    this->multiple_rest_always_.set (std::move (x));
  }

  const measure_numbering::multiple_rest_range_optional& measure_numbering::
  multiple_rest_range () const
  {
    return this->multiple_rest_range_;
  }

  measure_numbering::multiple_rest_range_optional& measure_numbering::
  multiple_rest_range ()
  {
    return this->multiple_rest_range_;
  }

  void measure_numbering::
  multiple_rest_range (const multiple_rest_range_type& x)
  {
    this->multiple_rest_range_.set (x);
  }

  void measure_numbering::
  multiple_rest_range (const multiple_rest_range_optional& x)
  {
    this->multiple_rest_range_ = x;
  }

  void measure_numbering::
  multiple_rest_range (::std::unique_ptr< multiple_rest_range_type > x)
  {
    this->multiple_rest_range_.set (std::move (x));
  }

  const measure_numbering::default_x_optional& measure_numbering::
  default_x () const
  {
    return this->default_x_;
  }

  measure_numbering::default_x_optional& measure_numbering::
  default_x ()
  {
    return this->default_x_;
  }

  void measure_numbering::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void measure_numbering::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void measure_numbering::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const measure_numbering::default_y_optional& measure_numbering::
  default_y () const
  {
    return this->default_y_;
  }

  measure_numbering::default_y_optional& measure_numbering::
  default_y ()
  {
    return this->default_y_;
  }

  void measure_numbering::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void measure_numbering::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void measure_numbering::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const measure_numbering::relative_x_optional& measure_numbering::
  relative_x () const
  {
    return this->relative_x_;
  }

  measure_numbering::relative_x_optional& measure_numbering::
  relative_x ()
  {
    return this->relative_x_;
  }

  void measure_numbering::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void measure_numbering::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void measure_numbering::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const measure_numbering::relative_y_optional& measure_numbering::
  relative_y () const
  {
    return this->relative_y_;
  }

  measure_numbering::relative_y_optional& measure_numbering::
  relative_y ()
  {
    return this->relative_y_;
  }

  void measure_numbering::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void measure_numbering::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void measure_numbering::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const measure_numbering::font_family_optional& measure_numbering::
  font_family () const
  {
    return this->font_family_;
  }

  measure_numbering::font_family_optional& measure_numbering::
  font_family ()
  {
    return this->font_family_;
  }

  void measure_numbering::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void measure_numbering::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void measure_numbering::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const measure_numbering::font_style_optional& measure_numbering::
  font_style () const
  {
    return this->font_style_;
  }

  measure_numbering::font_style_optional& measure_numbering::
  font_style ()
  {
    return this->font_style_;
  }

  void measure_numbering::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void measure_numbering::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void measure_numbering::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const measure_numbering::font_size_optional& measure_numbering::
  font_size () const
  {
    return this->font_size_;
  }

  measure_numbering::font_size_optional& measure_numbering::
  font_size ()
  {
    return this->font_size_;
  }

  void measure_numbering::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void measure_numbering::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void measure_numbering::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const measure_numbering::font_weight_optional& measure_numbering::
  font_weight () const
  {
    return this->font_weight_;
  }

  measure_numbering::font_weight_optional& measure_numbering::
  font_weight ()
  {
    return this->font_weight_;
  }

  void measure_numbering::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void measure_numbering::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void measure_numbering::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const measure_numbering::color_optional& measure_numbering::
  color () const
  {
    return this->color_;
  }

  measure_numbering::color_optional& measure_numbering::
  color ()
  {
    return this->color_;
  }

  void measure_numbering::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void measure_numbering::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void measure_numbering::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const measure_numbering::halign_optional& measure_numbering::
  halign () const
  {
    return this->halign_;
  }

  measure_numbering::halign_optional& measure_numbering::
  halign ()
  {
    return this->halign_;
  }

  void measure_numbering::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void measure_numbering::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void measure_numbering::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const measure_numbering::valign_optional& measure_numbering::
  valign () const
  {
    return this->valign_;
  }

  measure_numbering::valign_optional& measure_numbering::
  valign ()
  {
    return this->valign_;
  }

  void measure_numbering::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void measure_numbering::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void measure_numbering::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }


  // membrane
  // 

  const membrane::smufl_optional& membrane::
  smufl () const
  {
    return this->smufl_;
  }

  membrane::smufl_optional& membrane::
  smufl ()
  {
    return this->smufl_;
  }

  void membrane::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void membrane::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void membrane::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // metal
  // 

  const metal::smufl_optional& metal::
  smufl () const
  {
    return this->smufl_;
  }

  metal::smufl_optional& metal::
  smufl ()
  {
    return this->smufl_;
  }

  void metal::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void metal::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void metal::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // metronome
  // 

  const metronome::beat_unit_sequence& metronome::
  beat_unit () const
  {
    return this->beat_unit_;
  }

  metronome::beat_unit_sequence& metronome::
  beat_unit ()
  {
    return this->beat_unit_;
  }

  void metronome::
  beat_unit (const beat_unit_sequence& s)
  {
    this->beat_unit_ = s;
  }

  const metronome::beat_unit_dot_sequence& metronome::
  beat_unit_dot () const
  {
    return this->beat_unit_dot_;
  }

  metronome::beat_unit_dot_sequence& metronome::
  beat_unit_dot ()
  {
    return this->beat_unit_dot_;
  }

  void metronome::
  beat_unit_dot (const beat_unit_dot_sequence& s)
  {
    this->beat_unit_dot_ = s;
  }

  const metronome::beat_unit_tied_sequence& metronome::
  beat_unit_tied () const
  {
    return this->beat_unit_tied_;
  }

  metronome::beat_unit_tied_sequence& metronome::
  beat_unit_tied ()
  {
    return this->beat_unit_tied_;
  }

  void metronome::
  beat_unit_tied (const beat_unit_tied_sequence& s)
  {
    this->beat_unit_tied_ = s;
  }

  const metronome::per_minute_optional& metronome::
  per_minute () const
  {
    return this->per_minute_;
  }

  metronome::per_minute_optional& metronome::
  per_minute ()
  {
    return this->per_minute_;
  }

  void metronome::
  per_minute (const per_minute_type& x)
  {
    this->per_minute_.set (x);
  }

  void metronome::
  per_minute (const per_minute_optional& x)
  {
    this->per_minute_ = x;
  }

  void metronome::
  per_minute (::std::unique_ptr< per_minute_type > x)
  {
    this->per_minute_.set (std::move (x));
  }

  const metronome::metronome_arrows_optional& metronome::
  metronome_arrows () const
  {
    return this->metronome_arrows_;
  }

  metronome::metronome_arrows_optional& metronome::
  metronome_arrows ()
  {
    return this->metronome_arrows_;
  }

  void metronome::
  metronome_arrows (const metronome_arrows_type& x)
  {
    this->metronome_arrows_.set (x);
  }

  void metronome::
  metronome_arrows (const metronome_arrows_optional& x)
  {
    this->metronome_arrows_ = x;
  }

  void metronome::
  metronome_arrows (::std::unique_ptr< metronome_arrows_type > x)
  {
    this->metronome_arrows_.set (std::move (x));
  }

  const metronome::metronome_note_sequence& metronome::
  metronome_note () const
  {
    return this->metronome_note_;
  }

  metronome::metronome_note_sequence& metronome::
  metronome_note ()
  {
    return this->metronome_note_;
  }

  void metronome::
  metronome_note (const metronome_note_sequence& s)
  {
    this->metronome_note_ = s;
  }

  const metronome::metronome_relation_optional& metronome::
  metronome_relation () const
  {
    return this->metronome_relation_;
  }

  metronome::metronome_relation_optional& metronome::
  metronome_relation ()
  {
    return this->metronome_relation_;
  }

  void metronome::
  metronome_relation (const metronome_relation_type& x)
  {
    this->metronome_relation_.set (x);
  }

  void metronome::
  metronome_relation (const metronome_relation_optional& x)
  {
    this->metronome_relation_ = x;
  }

  void metronome::
  metronome_relation (::std::unique_ptr< metronome_relation_type > x)
  {
    this->metronome_relation_.set (std::move (x));
  }

  const metronome::default_x_optional& metronome::
  default_x () const
  {
    return this->default_x_;
  }

  metronome::default_x_optional& metronome::
  default_x ()
  {
    return this->default_x_;
  }

  void metronome::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void metronome::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void metronome::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const metronome::default_y_optional& metronome::
  default_y () const
  {
    return this->default_y_;
  }

  metronome::default_y_optional& metronome::
  default_y ()
  {
    return this->default_y_;
  }

  void metronome::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void metronome::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void metronome::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const metronome::relative_x_optional& metronome::
  relative_x () const
  {
    return this->relative_x_;
  }

  metronome::relative_x_optional& metronome::
  relative_x ()
  {
    return this->relative_x_;
  }

  void metronome::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void metronome::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void metronome::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const metronome::relative_y_optional& metronome::
  relative_y () const
  {
    return this->relative_y_;
  }

  metronome::relative_y_optional& metronome::
  relative_y ()
  {
    return this->relative_y_;
  }

  void metronome::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void metronome::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void metronome::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const metronome::font_family_optional& metronome::
  font_family () const
  {
    return this->font_family_;
  }

  metronome::font_family_optional& metronome::
  font_family ()
  {
    return this->font_family_;
  }

  void metronome::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void metronome::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void metronome::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const metronome::font_style_optional& metronome::
  font_style () const
  {
    return this->font_style_;
  }

  metronome::font_style_optional& metronome::
  font_style ()
  {
    return this->font_style_;
  }

  void metronome::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void metronome::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void metronome::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const metronome::font_size_optional& metronome::
  font_size () const
  {
    return this->font_size_;
  }

  metronome::font_size_optional& metronome::
  font_size ()
  {
    return this->font_size_;
  }

  void metronome::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void metronome::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void metronome::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const metronome::font_weight_optional& metronome::
  font_weight () const
  {
    return this->font_weight_;
  }

  metronome::font_weight_optional& metronome::
  font_weight ()
  {
    return this->font_weight_;
  }

  void metronome::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void metronome::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void metronome::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const metronome::color_optional& metronome::
  color () const
  {
    return this->color_;
  }

  metronome::color_optional& metronome::
  color ()
  {
    return this->color_;
  }

  void metronome::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void metronome::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void metronome::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const metronome::halign_optional& metronome::
  halign () const
  {
    return this->halign_;
  }

  metronome::halign_optional& metronome::
  halign ()
  {
    return this->halign_;
  }

  void metronome::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void metronome::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void metronome::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const metronome::valign_optional& metronome::
  valign () const
  {
    return this->valign_;
  }

  metronome::valign_optional& metronome::
  valign ()
  {
    return this->valign_;
  }

  void metronome::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void metronome::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void metronome::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const metronome::print_object_optional& metronome::
  print_object () const
  {
    return this->print_object_;
  }

  metronome::print_object_optional& metronome::
  print_object ()
  {
    return this->print_object_;
  }

  void metronome::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void metronome::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void metronome::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const metronome::justify_optional& metronome::
  justify () const
  {
    return this->justify_;
  }

  metronome::justify_optional& metronome::
  justify ()
  {
    return this->justify_;
  }

  void metronome::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void metronome::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void metronome::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const metronome::parentheses_optional& metronome::
  parentheses () const
  {
    return this->parentheses_;
  }

  metronome::parentheses_optional& metronome::
  parentheses ()
  {
    return this->parentheses_;
  }

  void metronome::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void metronome::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void metronome::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const metronome::id_optional& metronome::
  id () const
  {
    return this->id_;
  }

  metronome::id_optional& metronome::
  id ()
  {
    return this->id_;
  }

  void metronome::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void metronome::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void metronome::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // metronome_beam
  // 

  const metronome_beam::number_type& metronome_beam::
  number () const
  {
    return this->number_.get ();
  }

  metronome_beam::number_type& metronome_beam::
  number ()
  {
    return this->number_.get ();
  }

  void metronome_beam::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void metronome_beam::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  metronome_beam::number_type metronome_beam::
  number_default_value ()
  {
    return number_type (1ULL);
  }


  // metronome_note
  // 

  const metronome_note::metronome_type_type& metronome_note::
  metronome_type () const
  {
    return this->metronome_type_.get ();
  }

  metronome_note::metronome_type_type& metronome_note::
  metronome_type ()
  {
    return this->metronome_type_.get ();
  }

  void metronome_note::
  metronome_type (const metronome_type_type& x)
  {
    this->metronome_type_.set (x);
  }

  void metronome_note::
  metronome_type (::std::unique_ptr< metronome_type_type > x)
  {
    this->metronome_type_.set (std::move (x));
  }

  const metronome_note::metronome_dot_sequence& metronome_note::
  metronome_dot () const
  {
    return this->metronome_dot_;
  }

  metronome_note::metronome_dot_sequence& metronome_note::
  metronome_dot ()
  {
    return this->metronome_dot_;
  }

  void metronome_note::
  metronome_dot (const metronome_dot_sequence& s)
  {
    this->metronome_dot_ = s;
  }

  const metronome_note::metronome_beam_sequence& metronome_note::
  metronome_beam () const
  {
    return this->metronome_beam_;
  }

  metronome_note::metronome_beam_sequence& metronome_note::
  metronome_beam ()
  {
    return this->metronome_beam_;
  }

  void metronome_note::
  metronome_beam (const metronome_beam_sequence& s)
  {
    this->metronome_beam_ = s;
  }

  const metronome_note::metronome_tied_optional& metronome_note::
  metronome_tied () const
  {
    return this->metronome_tied_;
  }

  metronome_note::metronome_tied_optional& metronome_note::
  metronome_tied ()
  {
    return this->metronome_tied_;
  }

  void metronome_note::
  metronome_tied (const metronome_tied_type& x)
  {
    this->metronome_tied_.set (x);
  }

  void metronome_note::
  metronome_tied (const metronome_tied_optional& x)
  {
    this->metronome_tied_ = x;
  }

  void metronome_note::
  metronome_tied (::std::unique_ptr< metronome_tied_type > x)
  {
    this->metronome_tied_.set (std::move (x));
  }

  const metronome_note::metronome_tuplet_optional& metronome_note::
  metronome_tuplet () const
  {
    return this->metronome_tuplet_;
  }

  metronome_note::metronome_tuplet_optional& metronome_note::
  metronome_tuplet ()
  {
    return this->metronome_tuplet_;
  }

  void metronome_note::
  metronome_tuplet (const metronome_tuplet_type& x)
  {
    this->metronome_tuplet_.set (x);
  }

  void metronome_note::
  metronome_tuplet (const metronome_tuplet_optional& x)
  {
    this->metronome_tuplet_ = x;
  }

  void metronome_note::
  metronome_tuplet (::std::unique_ptr< metronome_tuplet_type > x)
  {
    this->metronome_tuplet_.set (std::move (x));
  }


  // metronome_tied
  // 

  const metronome_tied::type_type& metronome_tied::
  type () const
  {
    return this->type_.get ();
  }

  metronome_tied::type_type& metronome_tied::
  type ()
  {
    return this->type_.get ();
  }

  void metronome_tied::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void metronome_tied::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // time_modification
  // 

  const time_modification::actual_notes_type& time_modification::
  actual_notes () const
  {
    return this->actual_notes_.get ();
  }

  time_modification::actual_notes_type& time_modification::
  actual_notes ()
  {
    return this->actual_notes_.get ();
  }

  void time_modification::
  actual_notes (const actual_notes_type& x)
  {
    this->actual_notes_.set (x);
  }

  const time_modification::normal_notes_type& time_modification::
  normal_notes () const
  {
    return this->normal_notes_.get ();
  }

  time_modification::normal_notes_type& time_modification::
  normal_notes ()
  {
    return this->normal_notes_.get ();
  }

  void time_modification::
  normal_notes (const normal_notes_type& x)
  {
    this->normal_notes_.set (x);
  }

  const time_modification::normal_type_optional& time_modification::
  normal_type () const
  {
    return this->normal_type_;
  }

  time_modification::normal_type_optional& time_modification::
  normal_type ()
  {
    return this->normal_type_;
  }

  void time_modification::
  normal_type (const normal_type_type& x)
  {
    this->normal_type_.set (x);
  }

  void time_modification::
  normal_type (const normal_type_optional& x)
  {
    this->normal_type_ = x;
  }

  void time_modification::
  normal_type (::std::unique_ptr< normal_type_type > x)
  {
    this->normal_type_.set (std::move (x));
  }

  const time_modification::normal_dot_sequence& time_modification::
  normal_dot () const
  {
    return this->normal_dot_;
  }

  time_modification::normal_dot_sequence& time_modification::
  normal_dot ()
  {
    return this->normal_dot_;
  }

  void time_modification::
  normal_dot (const normal_dot_sequence& s)
  {
    this->normal_dot_ = s;
  }


  // metronome_tuplet
  // 

  const metronome_tuplet::type_type& metronome_tuplet::
  type () const
  {
    return this->type_.get ();
  }

  metronome_tuplet::type_type& metronome_tuplet::
  type ()
  {
    return this->type_.get ();
  }

  void metronome_tuplet::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void metronome_tuplet::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const metronome_tuplet::bracket_optional& metronome_tuplet::
  bracket () const
  {
    return this->bracket_;
  }

  metronome_tuplet::bracket_optional& metronome_tuplet::
  bracket ()
  {
    return this->bracket_;
  }

  void metronome_tuplet::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void metronome_tuplet::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void metronome_tuplet::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const metronome_tuplet::show_number_optional& metronome_tuplet::
  show_number () const
  {
    return this->show_number_;
  }

  metronome_tuplet::show_number_optional& metronome_tuplet::
  show_number ()
  {
    return this->show_number_;
  }

  void metronome_tuplet::
  show_number (const show_number_type& x)
  {
    this->show_number_.set (x);
  }

  void metronome_tuplet::
  show_number (const show_number_optional& x)
  {
    this->show_number_ = x;
  }

  void metronome_tuplet::
  show_number (::std::unique_ptr< show_number_type > x)
  {
    this->show_number_.set (std::move (x));
  }


  // numeral
  // 

  const numeral::numeral_root_type& numeral::
  numeral_root () const
  {
    return this->numeral_root_.get ();
  }

  numeral::numeral_root_type& numeral::
  numeral_root ()
  {
    return this->numeral_root_.get ();
  }

  void numeral::
  numeral_root (const numeral_root_type& x)
  {
    this->numeral_root_.set (x);
  }

  void numeral::
  numeral_root (::std::unique_ptr< numeral_root_type > x)
  {
    this->numeral_root_.set (std::move (x));
  }

  const numeral::numeral_alter_optional& numeral::
  numeral_alter () const
  {
    return this->numeral_alter_;
  }

  numeral::numeral_alter_optional& numeral::
  numeral_alter ()
  {
    return this->numeral_alter_;
  }

  void numeral::
  numeral_alter (const numeral_alter_type& x)
  {
    this->numeral_alter_.set (x);
  }

  void numeral::
  numeral_alter (const numeral_alter_optional& x)
  {
    this->numeral_alter_ = x;
  }

  void numeral::
  numeral_alter (::std::unique_ptr< numeral_alter_type > x)
  {
    this->numeral_alter_.set (std::move (x));
  }

  const numeral::numeral_key_optional& numeral::
  numeral_key () const
  {
    return this->numeral_key_;
  }

  numeral::numeral_key_optional& numeral::
  numeral_key ()
  {
    return this->numeral_key_;
  }

  void numeral::
  numeral_key (const numeral_key_type& x)
  {
    this->numeral_key_.set (x);
  }

  void numeral::
  numeral_key (const numeral_key_optional& x)
  {
    this->numeral_key_ = x;
  }

  void numeral::
  numeral_key (::std::unique_ptr< numeral_key_type > x)
  {
    this->numeral_key_.set (std::move (x));
  }


  // numeral_key
  // 

  const numeral_key::numeral_fifths_type& numeral_key::
  numeral_fifths () const
  {
    return this->numeral_fifths_.get ();
  }

  numeral_key::numeral_fifths_type& numeral_key::
  numeral_fifths ()
  {
    return this->numeral_fifths_.get ();
  }

  void numeral_key::
  numeral_fifths (const numeral_fifths_type& x)
  {
    this->numeral_fifths_.set (x);
  }

  void numeral_key::
  numeral_fifths (::std::unique_ptr< numeral_fifths_type > x)
  {
    this->numeral_fifths_.set (std::move (x));
  }

  const numeral_key::numeral_mode_type& numeral_key::
  numeral_mode () const
  {
    return this->numeral_mode_.get ();
  }

  numeral_key::numeral_mode_type& numeral_key::
  numeral_mode ()
  {
    return this->numeral_mode_.get ();
  }

  void numeral_key::
  numeral_mode (const numeral_mode_type& x)
  {
    this->numeral_mode_.set (x);
  }

  void numeral_key::
  numeral_mode (::std::unique_ptr< numeral_mode_type > x)
  {
    this->numeral_mode_.set (std::move (x));
  }

  const numeral_key::print_object_optional& numeral_key::
  print_object () const
  {
    return this->print_object_;
  }

  numeral_key::print_object_optional& numeral_key::
  print_object ()
  {
    return this->print_object_;
  }

  void numeral_key::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void numeral_key::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void numeral_key::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }


  // numeral_root
  // 

  const numeral_root::text_optional& numeral_root::
  text () const
  {
    return this->text_;
  }

  numeral_root::text_optional& numeral_root::
  text ()
  {
    return this->text_;
  }

  void numeral_root::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void numeral_root::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void numeral_root::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const numeral_root::default_x_optional& numeral_root::
  default_x () const
  {
    return this->default_x_;
  }

  numeral_root::default_x_optional& numeral_root::
  default_x ()
  {
    return this->default_x_;
  }

  void numeral_root::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void numeral_root::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void numeral_root::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const numeral_root::default_y_optional& numeral_root::
  default_y () const
  {
    return this->default_y_;
  }

  numeral_root::default_y_optional& numeral_root::
  default_y ()
  {
    return this->default_y_;
  }

  void numeral_root::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void numeral_root::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void numeral_root::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const numeral_root::relative_x_optional& numeral_root::
  relative_x () const
  {
    return this->relative_x_;
  }

  numeral_root::relative_x_optional& numeral_root::
  relative_x ()
  {
    return this->relative_x_;
  }

  void numeral_root::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void numeral_root::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void numeral_root::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const numeral_root::relative_y_optional& numeral_root::
  relative_y () const
  {
    return this->relative_y_;
  }

  numeral_root::relative_y_optional& numeral_root::
  relative_y ()
  {
    return this->relative_y_;
  }

  void numeral_root::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void numeral_root::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void numeral_root::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const numeral_root::font_family_optional& numeral_root::
  font_family () const
  {
    return this->font_family_;
  }

  numeral_root::font_family_optional& numeral_root::
  font_family ()
  {
    return this->font_family_;
  }

  void numeral_root::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void numeral_root::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void numeral_root::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const numeral_root::font_style_optional& numeral_root::
  font_style () const
  {
    return this->font_style_;
  }

  numeral_root::font_style_optional& numeral_root::
  font_style ()
  {
    return this->font_style_;
  }

  void numeral_root::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void numeral_root::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void numeral_root::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const numeral_root::font_size_optional& numeral_root::
  font_size () const
  {
    return this->font_size_;
  }

  numeral_root::font_size_optional& numeral_root::
  font_size ()
  {
    return this->font_size_;
  }

  void numeral_root::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void numeral_root::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void numeral_root::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const numeral_root::font_weight_optional& numeral_root::
  font_weight () const
  {
    return this->font_weight_;
  }

  numeral_root::font_weight_optional& numeral_root::
  font_weight ()
  {
    return this->font_weight_;
  }

  void numeral_root::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void numeral_root::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void numeral_root::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const numeral_root::color_optional& numeral_root::
  color () const
  {
    return this->color_;
  }

  numeral_root::color_optional& numeral_root::
  color ()
  {
    return this->color_;
  }

  void numeral_root::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void numeral_root::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void numeral_root::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // octave_shift
  // 

  const octave_shift::type_type& octave_shift::
  type () const
  {
    return this->type_.get ();
  }

  octave_shift::type_type& octave_shift::
  type ()
  {
    return this->type_.get ();
  }

  void octave_shift::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void octave_shift::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const octave_shift::number_optional& octave_shift::
  number () const
  {
    return this->number_;
  }

  octave_shift::number_optional& octave_shift::
  number ()
  {
    return this->number_;
  }

  void octave_shift::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void octave_shift::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void octave_shift::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const octave_shift::size_type& octave_shift::
  size () const
  {
    return this->size_.get ();
  }

  octave_shift::size_type& octave_shift::
  size ()
  {
    return this->size_.get ();
  }

  void octave_shift::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  octave_shift::size_type octave_shift::
  size_default_value ()
  {
    return size_type (8ULL);
  }

  const octave_shift::dash_length_optional& octave_shift::
  dash_length () const
  {
    return this->dash_length_;
  }

  octave_shift::dash_length_optional& octave_shift::
  dash_length ()
  {
    return this->dash_length_;
  }

  void octave_shift::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void octave_shift::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void octave_shift::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const octave_shift::space_length_optional& octave_shift::
  space_length () const
  {
    return this->space_length_;
  }

  octave_shift::space_length_optional& octave_shift::
  space_length ()
  {
    return this->space_length_;
  }

  void octave_shift::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void octave_shift::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void octave_shift::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const octave_shift::default_x_optional& octave_shift::
  default_x () const
  {
    return this->default_x_;
  }

  octave_shift::default_x_optional& octave_shift::
  default_x ()
  {
    return this->default_x_;
  }

  void octave_shift::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void octave_shift::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void octave_shift::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const octave_shift::default_y_optional& octave_shift::
  default_y () const
  {
    return this->default_y_;
  }

  octave_shift::default_y_optional& octave_shift::
  default_y ()
  {
    return this->default_y_;
  }

  void octave_shift::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void octave_shift::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void octave_shift::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const octave_shift::relative_x_optional& octave_shift::
  relative_x () const
  {
    return this->relative_x_;
  }

  octave_shift::relative_x_optional& octave_shift::
  relative_x ()
  {
    return this->relative_x_;
  }

  void octave_shift::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void octave_shift::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void octave_shift::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const octave_shift::relative_y_optional& octave_shift::
  relative_y () const
  {
    return this->relative_y_;
  }

  octave_shift::relative_y_optional& octave_shift::
  relative_y ()
  {
    return this->relative_y_;
  }

  void octave_shift::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void octave_shift::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void octave_shift::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const octave_shift::font_family_optional& octave_shift::
  font_family () const
  {
    return this->font_family_;
  }

  octave_shift::font_family_optional& octave_shift::
  font_family ()
  {
    return this->font_family_;
  }

  void octave_shift::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void octave_shift::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void octave_shift::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const octave_shift::font_style_optional& octave_shift::
  font_style () const
  {
    return this->font_style_;
  }

  octave_shift::font_style_optional& octave_shift::
  font_style ()
  {
    return this->font_style_;
  }

  void octave_shift::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void octave_shift::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void octave_shift::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const octave_shift::font_size_optional& octave_shift::
  font_size () const
  {
    return this->font_size_;
  }

  octave_shift::font_size_optional& octave_shift::
  font_size ()
  {
    return this->font_size_;
  }

  void octave_shift::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void octave_shift::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void octave_shift::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const octave_shift::font_weight_optional& octave_shift::
  font_weight () const
  {
    return this->font_weight_;
  }

  octave_shift::font_weight_optional& octave_shift::
  font_weight ()
  {
    return this->font_weight_;
  }

  void octave_shift::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void octave_shift::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void octave_shift::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const octave_shift::color_optional& octave_shift::
  color () const
  {
    return this->color_;
  }

  octave_shift::color_optional& octave_shift::
  color ()
  {
    return this->color_;
  }

  void octave_shift::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void octave_shift::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void octave_shift::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const octave_shift::id_optional& octave_shift::
  id () const
  {
    return this->id_;
  }

  octave_shift::id_optional& octave_shift::
  id ()
  {
    return this->id_;
  }

  void octave_shift::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void octave_shift::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void octave_shift::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // offset
  // 

  const offset::sound_optional& offset::
  sound () const
  {
    return this->sound_;
  }

  offset::sound_optional& offset::
  sound ()
  {
    return this->sound_;
  }

  void offset::
  sound (const sound_type& x)
  {
    this->sound_.set (x);
  }

  void offset::
  sound (const sound_optional& x)
  {
    this->sound_ = x;
  }

  void offset::
  sound (::std::unique_ptr< sound_type > x)
  {
    this->sound_.set (std::move (x));
  }


  // other_direction
  // 

  const other_direction::print_object_optional& other_direction::
  print_object () const
  {
    return this->print_object_;
  }

  other_direction::print_object_optional& other_direction::
  print_object ()
  {
    return this->print_object_;
  }

  void other_direction::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void other_direction::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void other_direction::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const other_direction::default_x_optional& other_direction::
  default_x () const
  {
    return this->default_x_;
  }

  other_direction::default_x_optional& other_direction::
  default_x ()
  {
    return this->default_x_;
  }

  void other_direction::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void other_direction::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void other_direction::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const other_direction::default_y_optional& other_direction::
  default_y () const
  {
    return this->default_y_;
  }

  other_direction::default_y_optional& other_direction::
  default_y ()
  {
    return this->default_y_;
  }

  void other_direction::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void other_direction::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void other_direction::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const other_direction::relative_x_optional& other_direction::
  relative_x () const
  {
    return this->relative_x_;
  }

  other_direction::relative_x_optional& other_direction::
  relative_x ()
  {
    return this->relative_x_;
  }

  void other_direction::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void other_direction::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void other_direction::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const other_direction::relative_y_optional& other_direction::
  relative_y () const
  {
    return this->relative_y_;
  }

  other_direction::relative_y_optional& other_direction::
  relative_y ()
  {
    return this->relative_y_;
  }

  void other_direction::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void other_direction::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void other_direction::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const other_direction::font_family_optional& other_direction::
  font_family () const
  {
    return this->font_family_;
  }

  other_direction::font_family_optional& other_direction::
  font_family ()
  {
    return this->font_family_;
  }

  void other_direction::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void other_direction::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void other_direction::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const other_direction::font_style_optional& other_direction::
  font_style () const
  {
    return this->font_style_;
  }

  other_direction::font_style_optional& other_direction::
  font_style ()
  {
    return this->font_style_;
  }

  void other_direction::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void other_direction::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void other_direction::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const other_direction::font_size_optional& other_direction::
  font_size () const
  {
    return this->font_size_;
  }

  other_direction::font_size_optional& other_direction::
  font_size ()
  {
    return this->font_size_;
  }

  void other_direction::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void other_direction::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void other_direction::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const other_direction::font_weight_optional& other_direction::
  font_weight () const
  {
    return this->font_weight_;
  }

  other_direction::font_weight_optional& other_direction::
  font_weight ()
  {
    return this->font_weight_;
  }

  void other_direction::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void other_direction::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void other_direction::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const other_direction::color_optional& other_direction::
  color () const
  {
    return this->color_;
  }

  other_direction::color_optional& other_direction::
  color ()
  {
    return this->color_;
  }

  void other_direction::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void other_direction::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void other_direction::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const other_direction::halign_optional& other_direction::
  halign () const
  {
    return this->halign_;
  }

  other_direction::halign_optional& other_direction::
  halign ()
  {
    return this->halign_;
  }

  void other_direction::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void other_direction::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void other_direction::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const other_direction::valign_optional& other_direction::
  valign () const
  {
    return this->valign_;
  }

  other_direction::valign_optional& other_direction::
  valign ()
  {
    return this->valign_;
  }

  void other_direction::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void other_direction::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void other_direction::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const other_direction::smufl_optional& other_direction::
  smufl () const
  {
    return this->smufl_;
  }

  other_direction::smufl_optional& other_direction::
  smufl ()
  {
    return this->smufl_;
  }

  void other_direction::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void other_direction::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void other_direction::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }

  const other_direction::id_optional& other_direction::
  id () const
  {
    return this->id_;
  }

  other_direction::id_optional& other_direction::
  id ()
  {
    return this->id_;
  }

  void other_direction::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void other_direction::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void other_direction::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // other_listening
  // 

  const other_listening::type_type& other_listening::
  type () const
  {
    return this->type_.get ();
  }

  other_listening::type_type& other_listening::
  type ()
  {
    return this->type_.get ();
  }

  void other_listening::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void other_listening::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const other_listening::player_optional& other_listening::
  player () const
  {
    return this->player_;
  }

  other_listening::player_optional& other_listening::
  player ()
  {
    return this->player_;
  }

  void other_listening::
  player (const player_type& x)
  {
    this->player_.set (x);
  }

  void other_listening::
  player (const player_optional& x)
  {
    this->player_ = x;
  }

  void other_listening::
  player (::std::unique_ptr< player_type > x)
  {
    this->player_.set (std::move (x));
  }

  const other_listening::time_only_optional& other_listening::
  time_only () const
  {
    return this->time_only_;
  }

  other_listening::time_only_optional& other_listening::
  time_only ()
  {
    return this->time_only_;
  }

  void other_listening::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void other_listening::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void other_listening::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }


  // pedal
  // 

  const pedal::type_type& pedal::
  type () const
  {
    return this->type_.get ();
  }

  pedal::type_type& pedal::
  type ()
  {
    return this->type_.get ();
  }

  void pedal::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void pedal::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const pedal::number_optional& pedal::
  number () const
  {
    return this->number_;
  }

  pedal::number_optional& pedal::
  number ()
  {
    return this->number_;
  }

  void pedal::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void pedal::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void pedal::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const pedal::line_optional& pedal::
  line () const
  {
    return this->line_;
  }

  pedal::line_optional& pedal::
  line ()
  {
    return this->line_;
  }

  void pedal::
  line (const line_type& x)
  {
    this->line_.set (x);
  }

  void pedal::
  line (const line_optional& x)
  {
    this->line_ = x;
  }

  void pedal::
  line (::std::unique_ptr< line_type > x)
  {
    this->line_.set (std::move (x));
  }

  const pedal::sign_optional& pedal::
  sign () const
  {
    return this->sign_;
  }

  pedal::sign_optional& pedal::
  sign ()
  {
    return this->sign_;
  }

  void pedal::
  sign (const sign_type& x)
  {
    this->sign_.set (x);
  }

  void pedal::
  sign (const sign_optional& x)
  {
    this->sign_ = x;
  }

  void pedal::
  sign (::std::unique_ptr< sign_type > x)
  {
    this->sign_.set (std::move (x));
  }

  const pedal::abbreviated_optional& pedal::
  abbreviated () const
  {
    return this->abbreviated_;
  }

  pedal::abbreviated_optional& pedal::
  abbreviated ()
  {
    return this->abbreviated_;
  }

  void pedal::
  abbreviated (const abbreviated_type& x)
  {
    this->abbreviated_.set (x);
  }

  void pedal::
  abbreviated (const abbreviated_optional& x)
  {
    this->abbreviated_ = x;
  }

  void pedal::
  abbreviated (::std::unique_ptr< abbreviated_type > x)
  {
    this->abbreviated_.set (std::move (x));
  }

  const pedal::default_x_optional& pedal::
  default_x () const
  {
    return this->default_x_;
  }

  pedal::default_x_optional& pedal::
  default_x ()
  {
    return this->default_x_;
  }

  void pedal::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void pedal::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void pedal::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const pedal::default_y_optional& pedal::
  default_y () const
  {
    return this->default_y_;
  }

  pedal::default_y_optional& pedal::
  default_y ()
  {
    return this->default_y_;
  }

  void pedal::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void pedal::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void pedal::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const pedal::relative_x_optional& pedal::
  relative_x () const
  {
    return this->relative_x_;
  }

  pedal::relative_x_optional& pedal::
  relative_x ()
  {
    return this->relative_x_;
  }

  void pedal::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void pedal::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void pedal::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const pedal::relative_y_optional& pedal::
  relative_y () const
  {
    return this->relative_y_;
  }

  pedal::relative_y_optional& pedal::
  relative_y ()
  {
    return this->relative_y_;
  }

  void pedal::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void pedal::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void pedal::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const pedal::font_family_optional& pedal::
  font_family () const
  {
    return this->font_family_;
  }

  pedal::font_family_optional& pedal::
  font_family ()
  {
    return this->font_family_;
  }

  void pedal::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void pedal::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void pedal::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const pedal::font_style_optional& pedal::
  font_style () const
  {
    return this->font_style_;
  }

  pedal::font_style_optional& pedal::
  font_style ()
  {
    return this->font_style_;
  }

  void pedal::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void pedal::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void pedal::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const pedal::font_size_optional& pedal::
  font_size () const
  {
    return this->font_size_;
  }

  pedal::font_size_optional& pedal::
  font_size ()
  {
    return this->font_size_;
  }

  void pedal::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void pedal::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void pedal::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const pedal::font_weight_optional& pedal::
  font_weight () const
  {
    return this->font_weight_;
  }

  pedal::font_weight_optional& pedal::
  font_weight ()
  {
    return this->font_weight_;
  }

  void pedal::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void pedal::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void pedal::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const pedal::color_optional& pedal::
  color () const
  {
    return this->color_;
  }

  pedal::color_optional& pedal::
  color ()
  {
    return this->color_;
  }

  void pedal::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void pedal::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void pedal::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const pedal::halign_optional& pedal::
  halign () const
  {
    return this->halign_;
  }

  pedal::halign_optional& pedal::
  halign ()
  {
    return this->halign_;
  }

  void pedal::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void pedal::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void pedal::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const pedal::valign_optional& pedal::
  valign () const
  {
    return this->valign_;
  }

  pedal::valign_optional& pedal::
  valign ()
  {
    return this->valign_;
  }

  void pedal::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void pedal::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void pedal::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const pedal::id_optional& pedal::
  id () const
  {
    return this->id_;
  }

  pedal::id_optional& pedal::
  id ()
  {
    return this->id_;
  }

  void pedal::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void pedal::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void pedal::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // pedal_tuning
  // 

  const pedal_tuning::pedal_step_type& pedal_tuning::
  pedal_step () const
  {
    return this->pedal_step_.get ();
  }

  pedal_tuning::pedal_step_type& pedal_tuning::
  pedal_step ()
  {
    return this->pedal_step_.get ();
  }

  void pedal_tuning::
  pedal_step (const pedal_step_type& x)
  {
    this->pedal_step_.set (x);
  }

  void pedal_tuning::
  pedal_step (::std::unique_ptr< pedal_step_type > x)
  {
    this->pedal_step_.set (std::move (x));
  }

  const pedal_tuning::pedal_alter_type& pedal_tuning::
  pedal_alter () const
  {
    return this->pedal_alter_.get ();
  }

  pedal_tuning::pedal_alter_type& pedal_tuning::
  pedal_alter ()
  {
    return this->pedal_alter_.get ();
  }

  void pedal_tuning::
  pedal_alter (const pedal_alter_type& x)
  {
    this->pedal_alter_.set (x);
  }

  void pedal_tuning::
  pedal_alter (::std::unique_ptr< pedal_alter_type > x)
  {
    this->pedal_alter_.set (std::move (x));
  }


  // per_minute
  // 

  const per_minute::font_family_optional& per_minute::
  font_family () const
  {
    return this->font_family_;
  }

  per_minute::font_family_optional& per_minute::
  font_family ()
  {
    return this->font_family_;
  }

  void per_minute::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void per_minute::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void per_minute::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const per_minute::font_style_optional& per_minute::
  font_style () const
  {
    return this->font_style_;
  }

  per_minute::font_style_optional& per_minute::
  font_style ()
  {
    return this->font_style_;
  }

  void per_minute::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void per_minute::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void per_minute::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const per_minute::font_size_optional& per_minute::
  font_size () const
  {
    return this->font_size_;
  }

  per_minute::font_size_optional& per_minute::
  font_size ()
  {
    return this->font_size_;
  }

  void per_minute::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void per_minute::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void per_minute::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const per_minute::font_weight_optional& per_minute::
  font_weight () const
  {
    return this->font_weight_;
  }

  per_minute::font_weight_optional& per_minute::
  font_weight ()
  {
    return this->font_weight_;
  }

  void per_minute::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void per_minute::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void per_minute::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }


  // percussion
  // 

  const percussion::glass_optional& percussion::
  glass () const
  {
    return this->glass_;
  }

  percussion::glass_optional& percussion::
  glass ()
  {
    return this->glass_;
  }

  void percussion::
  glass (const glass_type& x)
  {
    this->glass_.set (x);
  }

  void percussion::
  glass (const glass_optional& x)
  {
    this->glass_ = x;
  }

  void percussion::
  glass (::std::unique_ptr< glass_type > x)
  {
    this->glass_.set (std::move (x));
  }

  const percussion::metal_optional& percussion::
  metal () const
  {
    return this->metal_;
  }

  percussion::metal_optional& percussion::
  metal ()
  {
    return this->metal_;
  }

  void percussion::
  metal (const metal_type& x)
  {
    this->metal_.set (x);
  }

  void percussion::
  metal (const metal_optional& x)
  {
    this->metal_ = x;
  }

  void percussion::
  metal (::std::unique_ptr< metal_type > x)
  {
    this->metal_.set (std::move (x));
  }

  const percussion::wood_optional& percussion::
  wood () const
  {
    return this->wood_;
  }

  percussion::wood_optional& percussion::
  wood ()
  {
    return this->wood_;
  }

  void percussion::
  wood (const wood_type& x)
  {
    this->wood_.set (x);
  }

  void percussion::
  wood (const wood_optional& x)
  {
    this->wood_ = x;
  }

  void percussion::
  wood (::std::unique_ptr< wood_type > x)
  {
    this->wood_.set (std::move (x));
  }

  const percussion::pitched_optional& percussion::
  pitched () const
  {
    return this->pitched_;
  }

  percussion::pitched_optional& percussion::
  pitched ()
  {
    return this->pitched_;
  }

  void percussion::
  pitched (const pitched_type& x)
  {
    this->pitched_.set (x);
  }

  void percussion::
  pitched (const pitched_optional& x)
  {
    this->pitched_ = x;
  }

  void percussion::
  pitched (::std::unique_ptr< pitched_type > x)
  {
    this->pitched_.set (std::move (x));
  }

  const percussion::membrane_optional& percussion::
  membrane () const
  {
    return this->membrane_;
  }

  percussion::membrane_optional& percussion::
  membrane ()
  {
    return this->membrane_;
  }

  void percussion::
  membrane (const membrane_type& x)
  {
    this->membrane_.set (x);
  }

  void percussion::
  membrane (const membrane_optional& x)
  {
    this->membrane_ = x;
  }

  void percussion::
  membrane (::std::unique_ptr< membrane_type > x)
  {
    this->membrane_.set (std::move (x));
  }

  const percussion::effect_optional& percussion::
  effect () const
  {
    return this->effect_;
  }

  percussion::effect_optional& percussion::
  effect ()
  {
    return this->effect_;
  }

  void percussion::
  effect (const effect_type& x)
  {
    this->effect_.set (x);
  }

  void percussion::
  effect (const effect_optional& x)
  {
    this->effect_ = x;
  }

  void percussion::
  effect (::std::unique_ptr< effect_type > x)
  {
    this->effect_.set (std::move (x));
  }

  const percussion::timpani_optional& percussion::
  timpani () const
  {
    return this->timpani_;
  }

  percussion::timpani_optional& percussion::
  timpani ()
  {
    return this->timpani_;
  }

  void percussion::
  timpani (const timpani_type& x)
  {
    this->timpani_.set (x);
  }

  void percussion::
  timpani (const timpani_optional& x)
  {
    this->timpani_ = x;
  }

  void percussion::
  timpani (::std::unique_ptr< timpani_type > x)
  {
    this->timpani_.set (std::move (x));
  }

  const percussion::beater_optional& percussion::
  beater () const
  {
    return this->beater_;
  }

  percussion::beater_optional& percussion::
  beater ()
  {
    return this->beater_;
  }

  void percussion::
  beater (const beater_type& x)
  {
    this->beater_.set (x);
  }

  void percussion::
  beater (const beater_optional& x)
  {
    this->beater_ = x;
  }

  void percussion::
  beater (::std::unique_ptr< beater_type > x)
  {
    this->beater_.set (std::move (x));
  }

  const percussion::stick_optional& percussion::
  stick () const
  {
    return this->stick_;
  }

  percussion::stick_optional& percussion::
  stick ()
  {
    return this->stick_;
  }

  void percussion::
  stick (const stick_type& x)
  {
    this->stick_.set (x);
  }

  void percussion::
  stick (const stick_optional& x)
  {
    this->stick_ = x;
  }

  void percussion::
  stick (::std::unique_ptr< stick_type > x)
  {
    this->stick_.set (std::move (x));
  }

  const percussion::stick_location_optional& percussion::
  stick_location () const
  {
    return this->stick_location_;
  }

  percussion::stick_location_optional& percussion::
  stick_location ()
  {
    return this->stick_location_;
  }

  void percussion::
  stick_location (const stick_location_type& x)
  {
    this->stick_location_.set (x);
  }

  void percussion::
  stick_location (const stick_location_optional& x)
  {
    this->stick_location_ = x;
  }

  void percussion::
  stick_location (::std::unique_ptr< stick_location_type > x)
  {
    this->stick_location_.set (std::move (x));
  }

  const percussion::other_percussion_optional& percussion::
  other_percussion () const
  {
    return this->other_percussion_;
  }

  percussion::other_percussion_optional& percussion::
  other_percussion ()
  {
    return this->other_percussion_;
  }

  void percussion::
  other_percussion (const other_percussion_type& x)
  {
    this->other_percussion_.set (x);
  }

  void percussion::
  other_percussion (const other_percussion_optional& x)
  {
    this->other_percussion_ = x;
  }

  void percussion::
  other_percussion (::std::unique_ptr< other_percussion_type > x)
  {
    this->other_percussion_.set (std::move (x));
  }

  const percussion::default_x_optional& percussion::
  default_x () const
  {
    return this->default_x_;
  }

  percussion::default_x_optional& percussion::
  default_x ()
  {
    return this->default_x_;
  }

  void percussion::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void percussion::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void percussion::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const percussion::default_y_optional& percussion::
  default_y () const
  {
    return this->default_y_;
  }

  percussion::default_y_optional& percussion::
  default_y ()
  {
    return this->default_y_;
  }

  void percussion::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void percussion::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void percussion::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const percussion::relative_x_optional& percussion::
  relative_x () const
  {
    return this->relative_x_;
  }

  percussion::relative_x_optional& percussion::
  relative_x ()
  {
    return this->relative_x_;
  }

  void percussion::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void percussion::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void percussion::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const percussion::relative_y_optional& percussion::
  relative_y () const
  {
    return this->relative_y_;
  }

  percussion::relative_y_optional& percussion::
  relative_y ()
  {
    return this->relative_y_;
  }

  void percussion::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void percussion::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void percussion::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const percussion::font_family_optional& percussion::
  font_family () const
  {
    return this->font_family_;
  }

  percussion::font_family_optional& percussion::
  font_family ()
  {
    return this->font_family_;
  }

  void percussion::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void percussion::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void percussion::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const percussion::font_style_optional& percussion::
  font_style () const
  {
    return this->font_style_;
  }

  percussion::font_style_optional& percussion::
  font_style ()
  {
    return this->font_style_;
  }

  void percussion::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void percussion::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void percussion::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const percussion::font_size_optional& percussion::
  font_size () const
  {
    return this->font_size_;
  }

  percussion::font_size_optional& percussion::
  font_size ()
  {
    return this->font_size_;
  }

  void percussion::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void percussion::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void percussion::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const percussion::font_weight_optional& percussion::
  font_weight () const
  {
    return this->font_weight_;
  }

  percussion::font_weight_optional& percussion::
  font_weight ()
  {
    return this->font_weight_;
  }

  void percussion::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void percussion::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void percussion::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const percussion::color_optional& percussion::
  color () const
  {
    return this->color_;
  }

  percussion::color_optional& percussion::
  color ()
  {
    return this->color_;
  }

  void percussion::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void percussion::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void percussion::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const percussion::halign_optional& percussion::
  halign () const
  {
    return this->halign_;
  }

  percussion::halign_optional& percussion::
  halign ()
  {
    return this->halign_;
  }

  void percussion::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void percussion::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void percussion::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const percussion::valign_optional& percussion::
  valign () const
  {
    return this->valign_;
  }

  percussion::valign_optional& percussion::
  valign ()
  {
    return this->valign_;
  }

  void percussion::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void percussion::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void percussion::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const percussion::enclosure_optional& percussion::
  enclosure () const
  {
    return this->enclosure_;
  }

  percussion::enclosure_optional& percussion::
  enclosure ()
  {
    return this->enclosure_;
  }

  void percussion::
  enclosure (const enclosure_type& x)
  {
    this->enclosure_.set (x);
  }

  void percussion::
  enclosure (const enclosure_optional& x)
  {
    this->enclosure_ = x;
  }

  void percussion::
  enclosure (::std::unique_ptr< enclosure_type > x)
  {
    this->enclosure_.set (std::move (x));
  }

  const percussion::id_optional& percussion::
  id () const
  {
    return this->id_;
  }

  percussion::id_optional& percussion::
  id ()
  {
    return this->id_;
  }

  void percussion::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void percussion::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void percussion::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // pitched
  // 

  const pitched::smufl_optional& pitched::
  smufl () const
  {
    return this->smufl_;
  }

  pitched::smufl_optional& pitched::
  smufl ()
  {
    return this->smufl_;
  }

  void pitched::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void pitched::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void pitched::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // principal_voice
  // 

  const principal_voice::type_type& principal_voice::
  type () const
  {
    return this->type_.get ();
  }

  principal_voice::type_type& principal_voice::
  type ()
  {
    return this->type_.get ();
  }

  void principal_voice::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void principal_voice::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const principal_voice::symbol_type& principal_voice::
  symbol () const
  {
    return this->symbol_.get ();
  }

  principal_voice::symbol_type& principal_voice::
  symbol ()
  {
    return this->symbol_.get ();
  }

  void principal_voice::
  symbol (const symbol_type& x)
  {
    this->symbol_.set (x);
  }

  void principal_voice::
  symbol (::std::unique_ptr< symbol_type > x)
  {
    this->symbol_.set (std::move (x));
  }

  const principal_voice::default_x_optional& principal_voice::
  default_x () const
  {
    return this->default_x_;
  }

  principal_voice::default_x_optional& principal_voice::
  default_x ()
  {
    return this->default_x_;
  }

  void principal_voice::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void principal_voice::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void principal_voice::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const principal_voice::default_y_optional& principal_voice::
  default_y () const
  {
    return this->default_y_;
  }

  principal_voice::default_y_optional& principal_voice::
  default_y ()
  {
    return this->default_y_;
  }

  void principal_voice::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void principal_voice::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void principal_voice::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const principal_voice::relative_x_optional& principal_voice::
  relative_x () const
  {
    return this->relative_x_;
  }

  principal_voice::relative_x_optional& principal_voice::
  relative_x ()
  {
    return this->relative_x_;
  }

  void principal_voice::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void principal_voice::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void principal_voice::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const principal_voice::relative_y_optional& principal_voice::
  relative_y () const
  {
    return this->relative_y_;
  }

  principal_voice::relative_y_optional& principal_voice::
  relative_y ()
  {
    return this->relative_y_;
  }

  void principal_voice::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void principal_voice::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void principal_voice::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const principal_voice::font_family_optional& principal_voice::
  font_family () const
  {
    return this->font_family_;
  }

  principal_voice::font_family_optional& principal_voice::
  font_family ()
  {
    return this->font_family_;
  }

  void principal_voice::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void principal_voice::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void principal_voice::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const principal_voice::font_style_optional& principal_voice::
  font_style () const
  {
    return this->font_style_;
  }

  principal_voice::font_style_optional& principal_voice::
  font_style ()
  {
    return this->font_style_;
  }

  void principal_voice::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void principal_voice::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void principal_voice::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const principal_voice::font_size_optional& principal_voice::
  font_size () const
  {
    return this->font_size_;
  }

  principal_voice::font_size_optional& principal_voice::
  font_size ()
  {
    return this->font_size_;
  }

  void principal_voice::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void principal_voice::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void principal_voice::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const principal_voice::font_weight_optional& principal_voice::
  font_weight () const
  {
    return this->font_weight_;
  }

  principal_voice::font_weight_optional& principal_voice::
  font_weight ()
  {
    return this->font_weight_;
  }

  void principal_voice::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void principal_voice::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void principal_voice::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const principal_voice::color_optional& principal_voice::
  color () const
  {
    return this->color_;
  }

  principal_voice::color_optional& principal_voice::
  color ()
  {
    return this->color_;
  }

  void principal_voice::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void principal_voice::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void principal_voice::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const principal_voice::halign_optional& principal_voice::
  halign () const
  {
    return this->halign_;
  }

  principal_voice::halign_optional& principal_voice::
  halign ()
  {
    return this->halign_;
  }

  void principal_voice::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void principal_voice::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void principal_voice::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const principal_voice::valign_optional& principal_voice::
  valign () const
  {
    return this->valign_;
  }

  principal_voice::valign_optional& principal_voice::
  valign ()
  {
    return this->valign_;
  }

  void principal_voice::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void principal_voice::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void principal_voice::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const principal_voice::id_optional& principal_voice::
  id () const
  {
    return this->id_;
  }

  principal_voice::id_optional& principal_voice::
  id ()
  {
    return this->id_;
  }

  void principal_voice::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void principal_voice::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void principal_voice::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // print
  // 

  const print::page_layout_optional& print::
  page_layout () const
  {
    return this->page_layout_;
  }

  print::page_layout_optional& print::
  page_layout ()
  {
    return this->page_layout_;
  }

  void print::
  page_layout (const page_layout_type& x)
  {
    this->page_layout_.set (x);
  }

  void print::
  page_layout (const page_layout_optional& x)
  {
    this->page_layout_ = x;
  }

  void print::
  page_layout (::std::unique_ptr< page_layout_type > x)
  {
    this->page_layout_.set (std::move (x));
  }

  const print::system_layout_optional& print::
  system_layout () const
  {
    return this->system_layout_;
  }

  print::system_layout_optional& print::
  system_layout ()
  {
    return this->system_layout_;
  }

  void print::
  system_layout (const system_layout_type& x)
  {
    this->system_layout_.set (x);
  }

  void print::
  system_layout (const system_layout_optional& x)
  {
    this->system_layout_ = x;
  }

  void print::
  system_layout (::std::unique_ptr< system_layout_type > x)
  {
    this->system_layout_.set (std::move (x));
  }

  const print::staff_layout_sequence& print::
  staff_layout () const
  {
    return this->staff_layout_;
  }

  print::staff_layout_sequence& print::
  staff_layout ()
  {
    return this->staff_layout_;
  }

  void print::
  staff_layout (const staff_layout_sequence& s)
  {
    this->staff_layout_ = s;
  }

  const print::measure_layout_optional& print::
  measure_layout () const
  {
    return this->measure_layout_;
  }

  print::measure_layout_optional& print::
  measure_layout ()
  {
    return this->measure_layout_;
  }

  void print::
  measure_layout (const measure_layout_type& x)
  {
    this->measure_layout_.set (x);
  }

  void print::
  measure_layout (const measure_layout_optional& x)
  {
    this->measure_layout_ = x;
  }

  void print::
  measure_layout (::std::unique_ptr< measure_layout_type > x)
  {
    this->measure_layout_.set (std::move (x));
  }

  const print::measure_numbering_optional& print::
  measure_numbering () const
  {
    return this->measure_numbering_;
  }

  print::measure_numbering_optional& print::
  measure_numbering ()
  {
    return this->measure_numbering_;
  }

  void print::
  measure_numbering (const measure_numbering_type& x)
  {
    this->measure_numbering_.set (x);
  }

  void print::
  measure_numbering (const measure_numbering_optional& x)
  {
    this->measure_numbering_ = x;
  }

  void print::
  measure_numbering (::std::unique_ptr< measure_numbering_type > x)
  {
    this->measure_numbering_.set (std::move (x));
  }

  const print::part_name_display_optional& print::
  part_name_display () const
  {
    return this->part_name_display_;
  }

  print::part_name_display_optional& print::
  part_name_display ()
  {
    return this->part_name_display_;
  }

  void print::
  part_name_display (const part_name_display_type& x)
  {
    this->part_name_display_.set (x);
  }

  void print::
  part_name_display (const part_name_display_optional& x)
  {
    this->part_name_display_ = x;
  }

  void print::
  part_name_display (::std::unique_ptr< part_name_display_type > x)
  {
    this->part_name_display_.set (std::move (x));
  }

  const print::part_abbreviation_display_optional& print::
  part_abbreviation_display () const
  {
    return this->part_abbreviation_display_;
  }

  print::part_abbreviation_display_optional& print::
  part_abbreviation_display ()
  {
    return this->part_abbreviation_display_;
  }

  void print::
  part_abbreviation_display (const part_abbreviation_display_type& x)
  {
    this->part_abbreviation_display_.set (x);
  }

  void print::
  part_abbreviation_display (const part_abbreviation_display_optional& x)
  {
    this->part_abbreviation_display_ = x;
  }

  void print::
  part_abbreviation_display (::std::unique_ptr< part_abbreviation_display_type > x)
  {
    this->part_abbreviation_display_.set (std::move (x));
  }

  const print::staff_spacing_optional& print::
  staff_spacing () const
  {
    return this->staff_spacing_;
  }

  print::staff_spacing_optional& print::
  staff_spacing ()
  {
    return this->staff_spacing_;
  }

  void print::
  staff_spacing (const staff_spacing_type& x)
  {
    this->staff_spacing_.set (x);
  }

  void print::
  staff_spacing (const staff_spacing_optional& x)
  {
    this->staff_spacing_ = x;
  }

  void print::
  staff_spacing (::std::unique_ptr< staff_spacing_type > x)
  {
    this->staff_spacing_.set (std::move (x));
  }

  const print::new_system_optional& print::
  new_system () const
  {
    return this->new_system_;
  }

  print::new_system_optional& print::
  new_system ()
  {
    return this->new_system_;
  }

  void print::
  new_system (const new_system_type& x)
  {
    this->new_system_.set (x);
  }

  void print::
  new_system (const new_system_optional& x)
  {
    this->new_system_ = x;
  }

  void print::
  new_system (::std::unique_ptr< new_system_type > x)
  {
    this->new_system_.set (std::move (x));
  }

  const print::new_page_optional& print::
  new_page () const
  {
    return this->new_page_;
  }

  print::new_page_optional& print::
  new_page ()
  {
    return this->new_page_;
  }

  void print::
  new_page (const new_page_type& x)
  {
    this->new_page_.set (x);
  }

  void print::
  new_page (const new_page_optional& x)
  {
    this->new_page_ = x;
  }

  void print::
  new_page (::std::unique_ptr< new_page_type > x)
  {
    this->new_page_.set (std::move (x));
  }

  const print::blank_page_optional& print::
  blank_page () const
  {
    return this->blank_page_;
  }

  print::blank_page_optional& print::
  blank_page ()
  {
    return this->blank_page_;
  }

  void print::
  blank_page (const blank_page_type& x)
  {
    this->blank_page_.set (x);
  }

  void print::
  blank_page (const blank_page_optional& x)
  {
    this->blank_page_ = x;
  }

  const print::page_number_optional& print::
  page_number () const
  {
    return this->page_number_;
  }

  print::page_number_optional& print::
  page_number ()
  {
    return this->page_number_;
  }

  void print::
  page_number (const page_number_type& x)
  {
    this->page_number_.set (x);
  }

  void print::
  page_number (const page_number_optional& x)
  {
    this->page_number_ = x;
  }

  void print::
  page_number (::std::unique_ptr< page_number_type > x)
  {
    this->page_number_.set (std::move (x));
  }

  const print::id_optional& print::
  id () const
  {
    return this->id_;
  }

  print::id_optional& print::
  id ()
  {
    return this->id_;
  }

  void print::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void print::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void print::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // root
  // 

  const root::root_step_type& root::
  root_step () const
  {
    return this->root_step_.get ();
  }

  root::root_step_type& root::
  root_step ()
  {
    return this->root_step_.get ();
  }

  void root::
  root_step (const root_step_type& x)
  {
    this->root_step_.set (x);
  }

  void root::
  root_step (::std::unique_ptr< root_step_type > x)
  {
    this->root_step_.set (std::move (x));
  }

  const root::root_alter_optional& root::
  root_alter () const
  {
    return this->root_alter_;
  }

  root::root_alter_optional& root::
  root_alter ()
  {
    return this->root_alter_;
  }

  void root::
  root_alter (const root_alter_type& x)
  {
    this->root_alter_.set (x);
  }

  void root::
  root_alter (const root_alter_optional& x)
  {
    this->root_alter_ = x;
  }

  void root::
  root_alter (::std::unique_ptr< root_alter_type > x)
  {
    this->root_alter_.set (std::move (x));
  }


  // root_step
  // 

  const root_step::text_optional& root_step::
  text () const
  {
    return this->text_;
  }

  root_step::text_optional& root_step::
  text ()
  {
    return this->text_;
  }

  void root_step::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void root_step::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void root_step::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const root_step::default_x_optional& root_step::
  default_x () const
  {
    return this->default_x_;
  }

  root_step::default_x_optional& root_step::
  default_x ()
  {
    return this->default_x_;
  }

  void root_step::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void root_step::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void root_step::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const root_step::default_y_optional& root_step::
  default_y () const
  {
    return this->default_y_;
  }

  root_step::default_y_optional& root_step::
  default_y ()
  {
    return this->default_y_;
  }

  void root_step::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void root_step::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void root_step::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const root_step::relative_x_optional& root_step::
  relative_x () const
  {
    return this->relative_x_;
  }

  root_step::relative_x_optional& root_step::
  relative_x ()
  {
    return this->relative_x_;
  }

  void root_step::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void root_step::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void root_step::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const root_step::relative_y_optional& root_step::
  relative_y () const
  {
    return this->relative_y_;
  }

  root_step::relative_y_optional& root_step::
  relative_y ()
  {
    return this->relative_y_;
  }

  void root_step::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void root_step::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void root_step::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const root_step::font_family_optional& root_step::
  font_family () const
  {
    return this->font_family_;
  }

  root_step::font_family_optional& root_step::
  font_family ()
  {
    return this->font_family_;
  }

  void root_step::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void root_step::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void root_step::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const root_step::font_style_optional& root_step::
  font_style () const
  {
    return this->font_style_;
  }

  root_step::font_style_optional& root_step::
  font_style ()
  {
    return this->font_style_;
  }

  void root_step::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void root_step::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void root_step::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const root_step::font_size_optional& root_step::
  font_size () const
  {
    return this->font_size_;
  }

  root_step::font_size_optional& root_step::
  font_size ()
  {
    return this->font_size_;
  }

  void root_step::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void root_step::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void root_step::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const root_step::font_weight_optional& root_step::
  font_weight () const
  {
    return this->font_weight_;
  }

  root_step::font_weight_optional& root_step::
  font_weight ()
  {
    return this->font_weight_;
  }

  void root_step::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void root_step::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void root_step::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const root_step::color_optional& root_step::
  color () const
  {
    return this->color_;
  }

  root_step::color_optional& root_step::
  color ()
  {
    return this->color_;
  }

  void root_step::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void root_step::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void root_step::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // scordatura
  // 

  const scordatura::accord_sequence& scordatura::
  accord () const
  {
    return this->accord_;
  }

  scordatura::accord_sequence& scordatura::
  accord ()
  {
    return this->accord_;
  }

  void scordatura::
  accord (const accord_sequence& s)
  {
    this->accord_ = s;
  }

  const scordatura::id_optional& scordatura::
  id () const
  {
    return this->id_;
  }

  scordatura::id_optional& scordatura::
  id ()
  {
    return this->id_;
  }

  void scordatura::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void scordatura::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void scordatura::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // sound
  // 

  const sound::instrument_change_sequence& sound::
  instrument_change () const
  {
    return this->instrument_change_;
  }

  sound::instrument_change_sequence& sound::
  instrument_change ()
  {
    return this->instrument_change_;
  }

  void sound::
  instrument_change (const instrument_change_sequence& s)
  {
    this->instrument_change_ = s;
  }

  const sound::midi_device_sequence& sound::
  midi_device () const
  {
    return this->midi_device_;
  }

  sound::midi_device_sequence& sound::
  midi_device ()
  {
    return this->midi_device_;
  }

  void sound::
  midi_device (const midi_device_sequence& s)
  {
    this->midi_device_ = s;
  }

  const sound::midi_instrument_sequence& sound::
  midi_instrument () const
  {
    return this->midi_instrument_;
  }

  sound::midi_instrument_sequence& sound::
  midi_instrument ()
  {
    return this->midi_instrument_;
  }

  void sound::
  midi_instrument (const midi_instrument_sequence& s)
  {
    this->midi_instrument_ = s;
  }

  const sound::play_sequence& sound::
  play () const
  {
    return this->play_;
  }

  sound::play_sequence& sound::
  play ()
  {
    return this->play_;
  }

  void sound::
  play (const play_sequence& s)
  {
    this->play_ = s;
  }

  const sound::swing_optional& sound::
  swing () const
  {
    return this->swing_;
  }

  sound::swing_optional& sound::
  swing ()
  {
    return this->swing_;
  }

  void sound::
  swing (const swing_type& x)
  {
    this->swing_.set (x);
  }

  void sound::
  swing (const swing_optional& x)
  {
    this->swing_ = x;
  }

  void sound::
  swing (::std::unique_ptr< swing_type > x)
  {
    this->swing_.set (std::move (x));
  }

  const sound::offset_optional& sound::
  offset () const
  {
    return this->offset_;
  }

  sound::offset_optional& sound::
  offset ()
  {
    return this->offset_;
  }

  void sound::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void sound::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void sound::
  offset (::std::unique_ptr< offset_type > x)
  {
    this->offset_.set (std::move (x));
  }

  const sound::tempo_optional& sound::
  tempo () const
  {
    return this->tempo_;
  }

  sound::tempo_optional& sound::
  tempo ()
  {
    return this->tempo_;
  }

  void sound::
  tempo (const tempo_type& x)
  {
    this->tempo_.set (x);
  }

  void sound::
  tempo (const tempo_optional& x)
  {
    this->tempo_ = x;
  }

  void sound::
  tempo (::std::unique_ptr< tempo_type > x)
  {
    this->tempo_.set (std::move (x));
  }

  const sound::dynamics_optional& sound::
  dynamics () const
  {
    return this->dynamics_;
  }

  sound::dynamics_optional& sound::
  dynamics ()
  {
    return this->dynamics_;
  }

  void sound::
  dynamics (const dynamics_type& x)
  {
    this->dynamics_.set (x);
  }

  void sound::
  dynamics (const dynamics_optional& x)
  {
    this->dynamics_ = x;
  }

  void sound::
  dynamics (::std::unique_ptr< dynamics_type > x)
  {
    this->dynamics_.set (std::move (x));
  }

  const sound::dacapo_optional& sound::
  dacapo () const
  {
    return this->dacapo_;
  }

  sound::dacapo_optional& sound::
  dacapo ()
  {
    return this->dacapo_;
  }

  void sound::
  dacapo (const dacapo_type& x)
  {
    this->dacapo_.set (x);
  }

  void sound::
  dacapo (const dacapo_optional& x)
  {
    this->dacapo_ = x;
  }

  void sound::
  dacapo (::std::unique_ptr< dacapo_type > x)
  {
    this->dacapo_.set (std::move (x));
  }

  const sound::segno_optional& sound::
  segno () const
  {
    return this->segno_;
  }

  sound::segno_optional& sound::
  segno ()
  {
    return this->segno_;
  }

  void sound::
  segno (const segno_type& x)
  {
    this->segno_.set (x);
  }

  void sound::
  segno (const segno_optional& x)
  {
    this->segno_ = x;
  }

  void sound::
  segno (::std::unique_ptr< segno_type > x)
  {
    this->segno_.set (std::move (x));
  }

  const sound::dalsegno_optional& sound::
  dalsegno () const
  {
    return this->dalsegno_;
  }

  sound::dalsegno_optional& sound::
  dalsegno ()
  {
    return this->dalsegno_;
  }

  void sound::
  dalsegno (const dalsegno_type& x)
  {
    this->dalsegno_.set (x);
  }

  void sound::
  dalsegno (const dalsegno_optional& x)
  {
    this->dalsegno_ = x;
  }

  void sound::
  dalsegno (::std::unique_ptr< dalsegno_type > x)
  {
    this->dalsegno_.set (std::move (x));
  }

  const sound::coda_optional& sound::
  coda () const
  {
    return this->coda_;
  }

  sound::coda_optional& sound::
  coda ()
  {
    return this->coda_;
  }

  void sound::
  coda (const coda_type& x)
  {
    this->coda_.set (x);
  }

  void sound::
  coda (const coda_optional& x)
  {
    this->coda_ = x;
  }

  void sound::
  coda (::std::unique_ptr< coda_type > x)
  {
    this->coda_.set (std::move (x));
  }

  const sound::tocoda_optional& sound::
  tocoda () const
  {
    return this->tocoda_;
  }

  sound::tocoda_optional& sound::
  tocoda ()
  {
    return this->tocoda_;
  }

  void sound::
  tocoda (const tocoda_type& x)
  {
    this->tocoda_.set (x);
  }

  void sound::
  tocoda (const tocoda_optional& x)
  {
    this->tocoda_ = x;
  }

  void sound::
  tocoda (::std::unique_ptr< tocoda_type > x)
  {
    this->tocoda_.set (std::move (x));
  }

  const sound::divisions_optional& sound::
  divisions () const
  {
    return this->divisions_;
  }

  sound::divisions_optional& sound::
  divisions ()
  {
    return this->divisions_;
  }

  void sound::
  divisions (const divisions_type& x)
  {
    this->divisions_.set (x);
  }

  void sound::
  divisions (const divisions_optional& x)
  {
    this->divisions_ = x;
  }

  void sound::
  divisions (::std::unique_ptr< divisions_type > x)
  {
    this->divisions_.set (std::move (x));
  }

  const sound::forward_repeat_optional& sound::
  forward_repeat () const
  {
    return this->forward_repeat_;
  }

  sound::forward_repeat_optional& sound::
  forward_repeat ()
  {
    return this->forward_repeat_;
  }

  void sound::
  forward_repeat (const forward_repeat_type& x)
  {
    this->forward_repeat_.set (x);
  }

  void sound::
  forward_repeat (const forward_repeat_optional& x)
  {
    this->forward_repeat_ = x;
  }

  void sound::
  forward_repeat (::std::unique_ptr< forward_repeat_type > x)
  {
    this->forward_repeat_.set (std::move (x));
  }

  const sound::fine_optional& sound::
  fine () const
  {
    return this->fine_;
  }

  sound::fine_optional& sound::
  fine ()
  {
    return this->fine_;
  }

  void sound::
  fine (const fine_type& x)
  {
    this->fine_.set (x);
  }

  void sound::
  fine (const fine_optional& x)
  {
    this->fine_ = x;
  }

  void sound::
  fine (::std::unique_ptr< fine_type > x)
  {
    this->fine_.set (std::move (x));
  }

  const sound::time_only_optional& sound::
  time_only () const
  {
    return this->time_only_;
  }

  sound::time_only_optional& sound::
  time_only ()
  {
    return this->time_only_;
  }

  void sound::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void sound::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void sound::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }

  const sound::pizzicato_optional& sound::
  pizzicato () const
  {
    return this->pizzicato_;
  }

  sound::pizzicato_optional& sound::
  pizzicato ()
  {
    return this->pizzicato_;
  }

  void sound::
  pizzicato (const pizzicato_type& x)
  {
    this->pizzicato_.set (x);
  }

  void sound::
  pizzicato (const pizzicato_optional& x)
  {
    this->pizzicato_ = x;
  }

  void sound::
  pizzicato (::std::unique_ptr< pizzicato_type > x)
  {
    this->pizzicato_.set (std::move (x));
  }

  const sound::pan_optional& sound::
  pan () const
  {
    return this->pan_;
  }

  sound::pan_optional& sound::
  pan ()
  {
    return this->pan_;
  }

  void sound::
  pan (const pan_type& x)
  {
    this->pan_.set (x);
  }

  void sound::
  pan (const pan_optional& x)
  {
    this->pan_ = x;
  }

  void sound::
  pan (::std::unique_ptr< pan_type > x)
  {
    this->pan_.set (std::move (x));
  }

  const sound::elevation_optional& sound::
  elevation () const
  {
    return this->elevation_;
  }

  sound::elevation_optional& sound::
  elevation ()
  {
    return this->elevation_;
  }

  void sound::
  elevation (const elevation_type& x)
  {
    this->elevation_.set (x);
  }

  void sound::
  elevation (const elevation_optional& x)
  {
    this->elevation_ = x;
  }

  void sound::
  elevation (::std::unique_ptr< elevation_type > x)
  {
    this->elevation_.set (std::move (x));
  }

  const sound::damper_pedal_optional& sound::
  damper_pedal () const
  {
    return this->damper_pedal_;
  }

  sound::damper_pedal_optional& sound::
  damper_pedal ()
  {
    return this->damper_pedal_;
  }

  void sound::
  damper_pedal (const damper_pedal_type& x)
  {
    this->damper_pedal_.set (x);
  }

  void sound::
  damper_pedal (const damper_pedal_optional& x)
  {
    this->damper_pedal_ = x;
  }

  void sound::
  damper_pedal (::std::unique_ptr< damper_pedal_type > x)
  {
    this->damper_pedal_.set (std::move (x));
  }

  const sound::soft_pedal_optional& sound::
  soft_pedal () const
  {
    return this->soft_pedal_;
  }

  sound::soft_pedal_optional& sound::
  soft_pedal ()
  {
    return this->soft_pedal_;
  }

  void sound::
  soft_pedal (const soft_pedal_type& x)
  {
    this->soft_pedal_.set (x);
  }

  void sound::
  soft_pedal (const soft_pedal_optional& x)
  {
    this->soft_pedal_ = x;
  }

  void sound::
  soft_pedal (::std::unique_ptr< soft_pedal_type > x)
  {
    this->soft_pedal_.set (std::move (x));
  }

  const sound::sostenuto_pedal_optional& sound::
  sostenuto_pedal () const
  {
    return this->sostenuto_pedal_;
  }

  sound::sostenuto_pedal_optional& sound::
  sostenuto_pedal ()
  {
    return this->sostenuto_pedal_;
  }

  void sound::
  sostenuto_pedal (const sostenuto_pedal_type& x)
  {
    this->sostenuto_pedal_.set (x);
  }

  void sound::
  sostenuto_pedal (const sostenuto_pedal_optional& x)
  {
    this->sostenuto_pedal_ = x;
  }

  void sound::
  sostenuto_pedal (::std::unique_ptr< sostenuto_pedal_type > x)
  {
    this->sostenuto_pedal_.set (std::move (x));
  }

  const sound::id_optional& sound::
  id () const
  {
    return this->id_;
  }

  sound::id_optional& sound::
  id ()
  {
    return this->id_;
  }

  void sound::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void sound::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void sound::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // staff_divide
  // 

  const staff_divide::type_type& staff_divide::
  type () const
  {
    return this->type_.get ();
  }

  staff_divide::type_type& staff_divide::
  type ()
  {
    return this->type_.get ();
  }

  void staff_divide::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void staff_divide::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const staff_divide::default_x_optional& staff_divide::
  default_x () const
  {
    return this->default_x_;
  }

  staff_divide::default_x_optional& staff_divide::
  default_x ()
  {
    return this->default_x_;
  }

  void staff_divide::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void staff_divide::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void staff_divide::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const staff_divide::default_y_optional& staff_divide::
  default_y () const
  {
    return this->default_y_;
  }

  staff_divide::default_y_optional& staff_divide::
  default_y ()
  {
    return this->default_y_;
  }

  void staff_divide::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void staff_divide::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void staff_divide::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const staff_divide::relative_x_optional& staff_divide::
  relative_x () const
  {
    return this->relative_x_;
  }

  staff_divide::relative_x_optional& staff_divide::
  relative_x ()
  {
    return this->relative_x_;
  }

  void staff_divide::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void staff_divide::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void staff_divide::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const staff_divide::relative_y_optional& staff_divide::
  relative_y () const
  {
    return this->relative_y_;
  }

  staff_divide::relative_y_optional& staff_divide::
  relative_y ()
  {
    return this->relative_y_;
  }

  void staff_divide::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void staff_divide::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void staff_divide::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const staff_divide::font_family_optional& staff_divide::
  font_family () const
  {
    return this->font_family_;
  }

  staff_divide::font_family_optional& staff_divide::
  font_family ()
  {
    return this->font_family_;
  }

  void staff_divide::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void staff_divide::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void staff_divide::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const staff_divide::font_style_optional& staff_divide::
  font_style () const
  {
    return this->font_style_;
  }

  staff_divide::font_style_optional& staff_divide::
  font_style ()
  {
    return this->font_style_;
  }

  void staff_divide::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void staff_divide::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void staff_divide::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const staff_divide::font_size_optional& staff_divide::
  font_size () const
  {
    return this->font_size_;
  }

  staff_divide::font_size_optional& staff_divide::
  font_size ()
  {
    return this->font_size_;
  }

  void staff_divide::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void staff_divide::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void staff_divide::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const staff_divide::font_weight_optional& staff_divide::
  font_weight () const
  {
    return this->font_weight_;
  }

  staff_divide::font_weight_optional& staff_divide::
  font_weight ()
  {
    return this->font_weight_;
  }

  void staff_divide::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void staff_divide::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void staff_divide::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const staff_divide::color_optional& staff_divide::
  color () const
  {
    return this->color_;
  }

  staff_divide::color_optional& staff_divide::
  color ()
  {
    return this->color_;
  }

  void staff_divide::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void staff_divide::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void staff_divide::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const staff_divide::halign_optional& staff_divide::
  halign () const
  {
    return this->halign_;
  }

  staff_divide::halign_optional& staff_divide::
  halign ()
  {
    return this->halign_;
  }

  void staff_divide::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void staff_divide::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void staff_divide::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const staff_divide::valign_optional& staff_divide::
  valign () const
  {
    return this->valign_;
  }

  staff_divide::valign_optional& staff_divide::
  valign ()
  {
    return this->valign_;
  }

  void staff_divide::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void staff_divide::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void staff_divide::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const staff_divide::id_optional& staff_divide::
  id () const
  {
    return this->id_;
  }

  staff_divide::id_optional& staff_divide::
  id ()
  {
    return this->id_;
  }

  void staff_divide::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void staff_divide::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void staff_divide::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // stick
  // 

  const stick::stick_type_type& stick::
  stick_type () const
  {
    return this->stick_type_.get ();
  }

  stick::stick_type_type& stick::
  stick_type ()
  {
    return this->stick_type_.get ();
  }

  void stick::
  stick_type (const stick_type_type& x)
  {
    this->stick_type_.set (x);
  }

  void stick::
  stick_type (::std::unique_ptr< stick_type_type > x)
  {
    this->stick_type_.set (std::move (x));
  }

  const stick::stick_material_type& stick::
  stick_material () const
  {
    return this->stick_material_.get ();
  }

  stick::stick_material_type& stick::
  stick_material ()
  {
    return this->stick_material_.get ();
  }

  void stick::
  stick_material (const stick_material_type& x)
  {
    this->stick_material_.set (x);
  }

  void stick::
  stick_material (::std::unique_ptr< stick_material_type > x)
  {
    this->stick_material_.set (std::move (x));
  }

  const stick::tip_optional& stick::
  tip () const
  {
    return this->tip_;
  }

  stick::tip_optional& stick::
  tip ()
  {
    return this->tip_;
  }

  void stick::
  tip (const tip_type& x)
  {
    this->tip_.set (x);
  }

  void stick::
  tip (const tip_optional& x)
  {
    this->tip_ = x;
  }

  void stick::
  tip (::std::unique_ptr< tip_type > x)
  {
    this->tip_.set (std::move (x));
  }

  const stick::parentheses_optional& stick::
  parentheses () const
  {
    return this->parentheses_;
  }

  stick::parentheses_optional& stick::
  parentheses ()
  {
    return this->parentheses_;
  }

  void stick::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void stick::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void stick::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const stick::dashed_circle_optional& stick::
  dashed_circle () const
  {
    return this->dashed_circle_;
  }

  stick::dashed_circle_optional& stick::
  dashed_circle ()
  {
    return this->dashed_circle_;
  }

  void stick::
  dashed_circle (const dashed_circle_type& x)
  {
    this->dashed_circle_.set (x);
  }

  void stick::
  dashed_circle (const dashed_circle_optional& x)
  {
    this->dashed_circle_ = x;
  }

  void stick::
  dashed_circle (::std::unique_ptr< dashed_circle_type > x)
  {
    this->dashed_circle_.set (std::move (x));
  }


  // string_mute
  // 

  const string_mute::type_type& string_mute::
  type () const
  {
    return this->type_.get ();
  }

  string_mute::type_type& string_mute::
  type ()
  {
    return this->type_.get ();
  }

  void string_mute::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void string_mute::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const string_mute::default_x_optional& string_mute::
  default_x () const
  {
    return this->default_x_;
  }

  string_mute::default_x_optional& string_mute::
  default_x ()
  {
    return this->default_x_;
  }

  void string_mute::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void string_mute::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void string_mute::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const string_mute::default_y_optional& string_mute::
  default_y () const
  {
    return this->default_y_;
  }

  string_mute::default_y_optional& string_mute::
  default_y ()
  {
    return this->default_y_;
  }

  void string_mute::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void string_mute::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void string_mute::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const string_mute::relative_x_optional& string_mute::
  relative_x () const
  {
    return this->relative_x_;
  }

  string_mute::relative_x_optional& string_mute::
  relative_x ()
  {
    return this->relative_x_;
  }

  void string_mute::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void string_mute::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void string_mute::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const string_mute::relative_y_optional& string_mute::
  relative_y () const
  {
    return this->relative_y_;
  }

  string_mute::relative_y_optional& string_mute::
  relative_y ()
  {
    return this->relative_y_;
  }

  void string_mute::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void string_mute::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void string_mute::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const string_mute::font_family_optional& string_mute::
  font_family () const
  {
    return this->font_family_;
  }

  string_mute::font_family_optional& string_mute::
  font_family ()
  {
    return this->font_family_;
  }

  void string_mute::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void string_mute::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void string_mute::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const string_mute::font_style_optional& string_mute::
  font_style () const
  {
    return this->font_style_;
  }

  string_mute::font_style_optional& string_mute::
  font_style ()
  {
    return this->font_style_;
  }

  void string_mute::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void string_mute::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void string_mute::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const string_mute::font_size_optional& string_mute::
  font_size () const
  {
    return this->font_size_;
  }

  string_mute::font_size_optional& string_mute::
  font_size ()
  {
    return this->font_size_;
  }

  void string_mute::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void string_mute::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void string_mute::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const string_mute::font_weight_optional& string_mute::
  font_weight () const
  {
    return this->font_weight_;
  }

  string_mute::font_weight_optional& string_mute::
  font_weight ()
  {
    return this->font_weight_;
  }

  void string_mute::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void string_mute::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void string_mute::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const string_mute::color_optional& string_mute::
  color () const
  {
    return this->color_;
  }

  string_mute::color_optional& string_mute::
  color ()
  {
    return this->color_;
  }

  void string_mute::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void string_mute::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void string_mute::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const string_mute::halign_optional& string_mute::
  halign () const
  {
    return this->halign_;
  }

  string_mute::halign_optional& string_mute::
  halign ()
  {
    return this->halign_;
  }

  void string_mute::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void string_mute::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void string_mute::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const string_mute::valign_optional& string_mute::
  valign () const
  {
    return this->valign_;
  }

  string_mute::valign_optional& string_mute::
  valign ()
  {
    return this->valign_;
  }

  void string_mute::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void string_mute::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void string_mute::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const string_mute::id_optional& string_mute::
  id () const
  {
    return this->id_;
  }

  string_mute::id_optional& string_mute::
  id ()
  {
    return this->id_;
  }

  void string_mute::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void string_mute::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void string_mute::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // swing
  // 

  const swing::straight_optional& swing::
  straight () const
  {
    return this->straight_;
  }

  swing::straight_optional& swing::
  straight ()
  {
    return this->straight_;
  }

  void swing::
  straight (const straight_type& x)
  {
    this->straight_.set (x);
  }

  void swing::
  straight (const straight_optional& x)
  {
    this->straight_ = x;
  }

  void swing::
  straight (::std::unique_ptr< straight_type > x)
  {
    this->straight_.set (std::move (x));
  }

  const swing::first_optional& swing::
  first () const
  {
    return this->first_;
  }

  swing::first_optional& swing::
  first ()
  {
    return this->first_;
  }

  void swing::
  first (const first_type& x)
  {
    this->first_.set (x);
  }

  void swing::
  first (const first_optional& x)
  {
    this->first_ = x;
  }

  const swing::second_optional& swing::
  second () const
  {
    return this->second_;
  }

  swing::second_optional& swing::
  second ()
  {
    return this->second_;
  }

  void swing::
  second (const second_type& x)
  {
    this->second_.set (x);
  }

  void swing::
  second (const second_optional& x)
  {
    this->second_ = x;
  }

  const swing::swing_type_optional& swing::
  swing_type () const
  {
    return this->swing_type_;
  }

  swing::swing_type_optional& swing::
  swing_type ()
  {
    return this->swing_type_;
  }

  void swing::
  swing_type (const swing_type_type& x)
  {
    this->swing_type_.set (x);
  }

  void swing::
  swing_type (const swing_type_optional& x)
  {
    this->swing_type_ = x;
  }

  void swing::
  swing_type (::std::unique_ptr< swing_type_type > x)
  {
    this->swing_type_.set (std::move (x));
  }

  const swing::swing_style_optional& swing::
  swing_style () const
  {
    return this->swing_style_;
  }

  swing::swing_style_optional& swing::
  swing_style ()
  {
    return this->swing_style_;
  }

  void swing::
  swing_style (const swing_style_type& x)
  {
    this->swing_style_.set (x);
  }

  void swing::
  swing_style (const swing_style_optional& x)
  {
    this->swing_style_ = x;
  }

  void swing::
  swing_style (::std::unique_ptr< swing_style_type > x)
  {
    this->swing_style_.set (std::move (x));
  }


  // sync
  // 

  const sync::type_type& sync::
  type () const
  {
    return this->type_.get ();
  }

  sync::type_type& sync::
  type ()
  {
    return this->type_.get ();
  }

  void sync::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void sync::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const sync::latency_optional& sync::
  latency () const
  {
    return this->latency_;
  }

  sync::latency_optional& sync::
  latency ()
  {
    return this->latency_;
  }

  void sync::
  latency (const latency_type& x)
  {
    this->latency_.set (x);
  }

  void sync::
  latency (const latency_optional& x)
  {
    this->latency_ = x;
  }

  void sync::
  latency (::std::unique_ptr< latency_type > x)
  {
    this->latency_.set (std::move (x));
  }

  const sync::player_optional& sync::
  player () const
  {
    return this->player_;
  }

  sync::player_optional& sync::
  player ()
  {
    return this->player_;
  }

  void sync::
  player (const player_type& x)
  {
    this->player_.set (x);
  }

  void sync::
  player (const player_optional& x)
  {
    this->player_ = x;
  }

  void sync::
  player (::std::unique_ptr< player_type > x)
  {
    this->player_.set (std::move (x));
  }

  const sync::time_only_optional& sync::
  time_only () const
  {
    return this->time_only_;
  }

  sync::time_only_optional& sync::
  time_only ()
  {
    return this->time_only_;
  }

  void sync::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void sync::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void sync::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }


  // timpani
  // 

  const timpani::smufl_optional& timpani::
  smufl () const
  {
    return this->smufl_;
  }

  timpani::smufl_optional& timpani::
  smufl ()
  {
    return this->smufl_;
  }

  void timpani::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void timpani::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void timpani::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // wedge
  // 

  const wedge::type_type& wedge::
  type () const
  {
    return this->type_.get ();
  }

  wedge::type_type& wedge::
  type ()
  {
    return this->type_.get ();
  }

  void wedge::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void wedge::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const wedge::number_optional& wedge::
  number () const
  {
    return this->number_;
  }

  wedge::number_optional& wedge::
  number ()
  {
    return this->number_;
  }

  void wedge::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void wedge::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void wedge::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const wedge::spread_optional& wedge::
  spread () const
  {
    return this->spread_;
  }

  wedge::spread_optional& wedge::
  spread ()
  {
    return this->spread_;
  }

  void wedge::
  spread (const spread_type& x)
  {
    this->spread_.set (x);
  }

  void wedge::
  spread (const spread_optional& x)
  {
    this->spread_ = x;
  }

  void wedge::
  spread (::std::unique_ptr< spread_type > x)
  {
    this->spread_.set (std::move (x));
  }

  const wedge::niente_optional& wedge::
  niente () const
  {
    return this->niente_;
  }

  wedge::niente_optional& wedge::
  niente ()
  {
    return this->niente_;
  }

  void wedge::
  niente (const niente_type& x)
  {
    this->niente_.set (x);
  }

  void wedge::
  niente (const niente_optional& x)
  {
    this->niente_ = x;
  }

  void wedge::
  niente (::std::unique_ptr< niente_type > x)
  {
    this->niente_.set (std::move (x));
  }

  const wedge::line_type_optional& wedge::
  line_type () const
  {
    return this->line_type_;
  }

  wedge::line_type_optional& wedge::
  line_type ()
  {
    return this->line_type_;
  }

  void wedge::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void wedge::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void wedge::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const wedge::dash_length_optional& wedge::
  dash_length () const
  {
    return this->dash_length_;
  }

  wedge::dash_length_optional& wedge::
  dash_length ()
  {
    return this->dash_length_;
  }

  void wedge::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void wedge::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void wedge::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const wedge::space_length_optional& wedge::
  space_length () const
  {
    return this->space_length_;
  }

  wedge::space_length_optional& wedge::
  space_length ()
  {
    return this->space_length_;
  }

  void wedge::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void wedge::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void wedge::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const wedge::default_x_optional& wedge::
  default_x () const
  {
    return this->default_x_;
  }

  wedge::default_x_optional& wedge::
  default_x ()
  {
    return this->default_x_;
  }

  void wedge::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void wedge::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void wedge::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const wedge::default_y_optional& wedge::
  default_y () const
  {
    return this->default_y_;
  }

  wedge::default_y_optional& wedge::
  default_y ()
  {
    return this->default_y_;
  }

  void wedge::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void wedge::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void wedge::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const wedge::relative_x_optional& wedge::
  relative_x () const
  {
    return this->relative_x_;
  }

  wedge::relative_x_optional& wedge::
  relative_x ()
  {
    return this->relative_x_;
  }

  void wedge::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void wedge::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void wedge::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const wedge::relative_y_optional& wedge::
  relative_y () const
  {
    return this->relative_y_;
  }

  wedge::relative_y_optional& wedge::
  relative_y ()
  {
    return this->relative_y_;
  }

  void wedge::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void wedge::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void wedge::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const wedge::color_optional& wedge::
  color () const
  {
    return this->color_;
  }

  wedge::color_optional& wedge::
  color ()
  {
    return this->color_;
  }

  void wedge::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void wedge::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void wedge::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const wedge::id_optional& wedge::
  id () const
  {
    return this->id_;
  }

  wedge::id_optional& wedge::
  id ()
  {
    return this->id_;
  }

  void wedge::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void wedge::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void wedge::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // wood
  // 

  const wood::smufl_optional& wood::
  smufl () const
  {
    return this->smufl_;
  }

  wood::smufl_optional& wood::
  smufl ()
  {
    return this->smufl_;
  }

  void wood::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void wood::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void wood::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // encoding
  // 

  const encoding::encoding_date_sequence& encoding::
  encoding_date () const
  {
    return this->encoding_date_;
  }

  encoding::encoding_date_sequence& encoding::
  encoding_date ()
  {
    return this->encoding_date_;
  }

  void encoding::
  encoding_date (const encoding_date_sequence& s)
  {
    this->encoding_date_ = s;
  }

  const encoding::encoder_sequence& encoding::
  encoder () const
  {
    return this->encoder_;
  }

  encoding::encoder_sequence& encoding::
  encoder ()
  {
    return this->encoder_;
  }

  void encoding::
  encoder (const encoder_sequence& s)
  {
    this->encoder_ = s;
  }

  const encoding::software_sequence& encoding::
  software () const
  {
    return this->software_;
  }

  encoding::software_sequence& encoding::
  software ()
  {
    return this->software_;
  }

  void encoding::
  software (const software_sequence& s)
  {
    this->software_ = s;
  }

  const encoding::encoding_description_sequence& encoding::
  encoding_description () const
  {
    return this->encoding_description_;
  }

  encoding::encoding_description_sequence& encoding::
  encoding_description ()
  {
    return this->encoding_description_;
  }

  void encoding::
  encoding_description (const encoding_description_sequence& s)
  {
    this->encoding_description_ = s;
  }

  const encoding::supports_sequence& encoding::
  supports () const
  {
    return this->supports_;
  }

  encoding::supports_sequence& encoding::
  supports ()
  {
    return this->supports_;
  }

  void encoding::
  supports (const supports_sequence& s)
  {
    this->supports_ = s;
  }


  // identification
  // 

  const identification::creator_sequence& identification::
  creator () const
  {
    return this->creator_;
  }

  identification::creator_sequence& identification::
  creator ()
  {
    return this->creator_;
  }

  void identification::
  creator (const creator_sequence& s)
  {
    this->creator_ = s;
  }

  const identification::rights_sequence& identification::
  rights () const
  {
    return this->rights_;
  }

  identification::rights_sequence& identification::
  rights ()
  {
    return this->rights_;
  }

  void identification::
  rights (const rights_sequence& s)
  {
    this->rights_ = s;
  }

  const identification::encoding_optional& identification::
  encoding () const
  {
    return this->encoding_;
  }

  identification::encoding_optional& identification::
  encoding ()
  {
    return this->encoding_;
  }

  void identification::
  encoding (const encoding_type& x)
  {
    this->encoding_.set (x);
  }

  void identification::
  encoding (const encoding_optional& x)
  {
    this->encoding_ = x;
  }

  void identification::
  encoding (::std::unique_ptr< encoding_type > x)
  {
    this->encoding_.set (std::move (x));
  }

  const identification::source_optional& identification::
  source () const
  {
    return this->source_;
  }

  identification::source_optional& identification::
  source ()
  {
    return this->source_;
  }

  void identification::
  source (const source_type& x)
  {
    this->source_.set (x);
  }

  void identification::
  source (const source_optional& x)
  {
    this->source_ = x;
  }

  void identification::
  source (::std::unique_ptr< source_type > x)
  {
    this->source_.set (std::move (x));
  }

  const identification::relation_sequence& identification::
  relation () const
  {
    return this->relation_;
  }

  identification::relation_sequence& identification::
  relation ()
  {
    return this->relation_;
  }

  void identification::
  relation (const relation_sequence& s)
  {
    this->relation_ = s;
  }

  const identification::miscellaneous_optional& identification::
  miscellaneous () const
  {
    return this->miscellaneous_;
  }

  identification::miscellaneous_optional& identification::
  miscellaneous ()
  {
    return this->miscellaneous_;
  }

  void identification::
  miscellaneous (const miscellaneous_type& x)
  {
    this->miscellaneous_.set (x);
  }

  void identification::
  miscellaneous (const miscellaneous_optional& x)
  {
    this->miscellaneous_ = x;
  }

  void identification::
  miscellaneous (::std::unique_ptr< miscellaneous_type > x)
  {
    this->miscellaneous_.set (std::move (x));
  }


  // miscellaneous
  // 

  const miscellaneous::miscellaneous_field_sequence& miscellaneous::
  miscellaneous_field () const
  {
    return this->miscellaneous_field_;
  }

  miscellaneous::miscellaneous_field_sequence& miscellaneous::
  miscellaneous_field ()
  {
    return this->miscellaneous_field_;
  }

  void miscellaneous::
  miscellaneous_field (const miscellaneous_field_sequence& s)
  {
    this->miscellaneous_field_ = s;
  }


  // miscellaneous_field
  // 

  const miscellaneous_field::name_type& miscellaneous_field::
  name () const
  {
    return this->name_.get ();
  }

  miscellaneous_field::name_type& miscellaneous_field::
  name ()
  {
    return this->name_.get ();
  }

  void miscellaneous_field::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void miscellaneous_field::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }


  // supports
  // 

  const supports::type_type& supports::
  type () const
  {
    return this->type_.get ();
  }

  supports::type_type& supports::
  type ()
  {
    return this->type_.get ();
  }

  void supports::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void supports::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const supports::element_type& supports::
  element () const
  {
    return this->element_.get ();
  }

  supports::element_type& supports::
  element ()
  {
    return this->element_.get ();
  }

  void supports::
  element (const element_type& x)
  {
    this->element_.set (x);
  }

  void supports::
  element (::std::unique_ptr< element_type > x)
  {
    this->element_.set (std::move (x));
  }

  const supports::attribute_optional& supports::
  attribute () const
  {
    return this->attribute_;
  }

  supports::attribute_optional& supports::
  attribute ()
  {
    return this->attribute_;
  }

  void supports::
  attribute (const attribute_type& x)
  {
    this->attribute_.set (x);
  }

  void supports::
  attribute (const attribute_optional& x)
  {
    this->attribute_ = x;
  }

  void supports::
  attribute (::std::unique_ptr< attribute_type > x)
  {
    this->attribute_.set (std::move (x));
  }

  const supports::value_optional& supports::
  value () const
  {
    return this->value_;
  }

  supports::value_optional& supports::
  value ()
  {
    return this->value_;
  }

  void supports::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void supports::
  value (const value_optional& x)
  {
    this->value_ = x;
  }

  void supports::
  value (::std::unique_ptr< value_type > x)
  {
    this->value_.set (std::move (x));
  }


  // appearance
  // 

  const appearance::line_width_sequence& appearance::
  line_width () const
  {
    return this->line_width_;
  }

  appearance::line_width_sequence& appearance::
  line_width ()
  {
    return this->line_width_;
  }

  void appearance::
  line_width (const line_width_sequence& s)
  {
    this->line_width_ = s;
  }

  const appearance::note_size_sequence& appearance::
  note_size () const
  {
    return this->note_size_;
  }

  appearance::note_size_sequence& appearance::
  note_size ()
  {
    return this->note_size_;
  }

  void appearance::
  note_size (const note_size_sequence& s)
  {
    this->note_size_ = s;
  }

  const appearance::distance_sequence& appearance::
  distance () const
  {
    return this->distance_;
  }

  appearance::distance_sequence& appearance::
  distance ()
  {
    return this->distance_;
  }

  void appearance::
  distance (const distance_sequence& s)
  {
    this->distance_ = s;
  }

  const appearance::glyph_sequence& appearance::
  glyph () const
  {
    return this->glyph_;
  }

  appearance::glyph_sequence& appearance::
  glyph ()
  {
    return this->glyph_;
  }

  void appearance::
  glyph (const glyph_sequence& s)
  {
    this->glyph_ = s;
  }

  const appearance::other_appearance_sequence& appearance::
  other_appearance () const
  {
    return this->other_appearance_;
  }

  appearance::other_appearance_sequence& appearance::
  other_appearance ()
  {
    return this->other_appearance_;
  }

  void appearance::
  other_appearance (const other_appearance_sequence& s)
  {
    this->other_appearance_ = s;
  }


  // distance
  // 

  const distance::type_type& distance::
  type () const
  {
    return this->type_.get ();
  }

  distance::type_type& distance::
  type ()
  {
    return this->type_.get ();
  }

  void distance::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void distance::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // glyph
  // 

  const glyph::type_type& glyph::
  type () const
  {
    return this->type_.get ();
  }

  glyph::type_type& glyph::
  type ()
  {
    return this->type_.get ();
  }

  void glyph::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void glyph::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // line_width
  // 

  const line_width::type_type& line_width::
  type () const
  {
    return this->type_.get ();
  }

  line_width::type_type& line_width::
  type ()
  {
    return this->type_.get ();
  }

  void line_width::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void line_width::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // measure_layout
  // 

  const measure_layout::measure_distance_optional& measure_layout::
  measure_distance () const
  {
    return this->measure_distance_;
  }

  measure_layout::measure_distance_optional& measure_layout::
  measure_distance ()
  {
    return this->measure_distance_;
  }

  void measure_layout::
  measure_distance (const measure_distance_type& x)
  {
    this->measure_distance_.set (x);
  }

  void measure_layout::
  measure_distance (const measure_distance_optional& x)
  {
    this->measure_distance_ = x;
  }

  void measure_layout::
  measure_distance (::std::unique_ptr< measure_distance_type > x)
  {
    this->measure_distance_.set (std::move (x));
  }


  // note_size
  // 

  const note_size::type_type& note_size::
  type () const
  {
    return this->type_.get ();
  }

  note_size::type_type& note_size::
  type ()
  {
    return this->type_.get ();
  }

  void note_size::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void note_size::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // other_appearance
  // 

  const other_appearance::type_type& other_appearance::
  type () const
  {
    return this->type_.get ();
  }

  other_appearance::type_type& other_appearance::
  type ()
  {
    return this->type_.get ();
  }

  void other_appearance::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void other_appearance::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // page_layout
  // 

  const page_layout::page_height_optional& page_layout::
  page_height () const
  {
    return this->page_height_;
  }

  page_layout::page_height_optional& page_layout::
  page_height ()
  {
    return this->page_height_;
  }

  void page_layout::
  page_height (const page_height_type& x)
  {
    this->page_height_.set (x);
  }

  void page_layout::
  page_height (const page_height_optional& x)
  {
    this->page_height_ = x;
  }

  void page_layout::
  page_height (::std::unique_ptr< page_height_type > x)
  {
    this->page_height_.set (std::move (x));
  }

  const page_layout::page_width_optional& page_layout::
  page_width () const
  {
    return this->page_width_;
  }

  page_layout::page_width_optional& page_layout::
  page_width ()
  {
    return this->page_width_;
  }

  void page_layout::
  page_width (const page_width_type& x)
  {
    this->page_width_.set (x);
  }

  void page_layout::
  page_width (const page_width_optional& x)
  {
    this->page_width_ = x;
  }

  void page_layout::
  page_width (::std::unique_ptr< page_width_type > x)
  {
    this->page_width_.set (std::move (x));
  }

  const page_layout::page_margins_sequence& page_layout::
  page_margins () const
  {
    return this->page_margins_;
  }

  page_layout::page_margins_sequence& page_layout::
  page_margins ()
  {
    return this->page_margins_;
  }

  void page_layout::
  page_margins (const page_margins_sequence& s)
  {
    this->page_margins_ = s;
  }


  // page_margins
  // 

  const page_margins::left_margin_type& page_margins::
  left_margin () const
  {
    return this->left_margin_.get ();
  }

  page_margins::left_margin_type& page_margins::
  left_margin ()
  {
    return this->left_margin_.get ();
  }

  void page_margins::
  left_margin (const left_margin_type& x)
  {
    this->left_margin_.set (x);
  }

  void page_margins::
  left_margin (::std::unique_ptr< left_margin_type > x)
  {
    this->left_margin_.set (std::move (x));
  }

  const page_margins::right_margin_type& page_margins::
  right_margin () const
  {
    return this->right_margin_.get ();
  }

  page_margins::right_margin_type& page_margins::
  right_margin ()
  {
    return this->right_margin_.get ();
  }

  void page_margins::
  right_margin (const right_margin_type& x)
  {
    this->right_margin_.set (x);
  }

  void page_margins::
  right_margin (::std::unique_ptr< right_margin_type > x)
  {
    this->right_margin_.set (std::move (x));
  }

  const page_margins::top_margin_type& page_margins::
  top_margin () const
  {
    return this->top_margin_.get ();
  }

  page_margins::top_margin_type& page_margins::
  top_margin ()
  {
    return this->top_margin_.get ();
  }

  void page_margins::
  top_margin (const top_margin_type& x)
  {
    this->top_margin_.set (x);
  }

  void page_margins::
  top_margin (::std::unique_ptr< top_margin_type > x)
  {
    this->top_margin_.set (std::move (x));
  }

  const page_margins::bottom_margin_type& page_margins::
  bottom_margin () const
  {
    return this->bottom_margin_.get ();
  }

  page_margins::bottom_margin_type& page_margins::
  bottom_margin ()
  {
    return this->bottom_margin_.get ();
  }

  void page_margins::
  bottom_margin (const bottom_margin_type& x)
  {
    this->bottom_margin_.set (x);
  }

  void page_margins::
  bottom_margin (::std::unique_ptr< bottom_margin_type > x)
  {
    this->bottom_margin_.set (std::move (x));
  }

  const page_margins::type_optional& page_margins::
  type () const
  {
    return this->type_;
  }

  page_margins::type_optional& page_margins::
  type ()
  {
    return this->type_;
  }

  void page_margins::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void page_margins::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void page_margins::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }


  // scaling
  // 

  const scaling::millimeters_type& scaling::
  millimeters () const
  {
    return this->millimeters_.get ();
  }

  scaling::millimeters_type& scaling::
  millimeters ()
  {
    return this->millimeters_.get ();
  }

  void scaling::
  millimeters (const millimeters_type& x)
  {
    this->millimeters_.set (x);
  }

  void scaling::
  millimeters (::std::unique_ptr< millimeters_type > x)
  {
    this->millimeters_.set (std::move (x));
  }

  const scaling::tenths_type& scaling::
  tenths () const
  {
    return this->tenths_.get ();
  }

  scaling::tenths_type& scaling::
  tenths ()
  {
    return this->tenths_.get ();
  }

  void scaling::
  tenths (const tenths_type& x)
  {
    this->tenths_.set (x);
  }

  void scaling::
  tenths (::std::unique_ptr< tenths_type > x)
  {
    this->tenths_.set (std::move (x));
  }


  // staff_layout
  // 

  const staff_layout::staff_distance_optional& staff_layout::
  staff_distance () const
  {
    return this->staff_distance_;
  }

  staff_layout::staff_distance_optional& staff_layout::
  staff_distance ()
  {
    return this->staff_distance_;
  }

  void staff_layout::
  staff_distance (const staff_distance_type& x)
  {
    this->staff_distance_.set (x);
  }

  void staff_layout::
  staff_distance (const staff_distance_optional& x)
  {
    this->staff_distance_ = x;
  }

  void staff_layout::
  staff_distance (::std::unique_ptr< staff_distance_type > x)
  {
    this->staff_distance_.set (std::move (x));
  }

  const staff_layout::number_optional& staff_layout::
  number () const
  {
    return this->number_;
  }

  staff_layout::number_optional& staff_layout::
  number ()
  {
    return this->number_;
  }

  void staff_layout::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void staff_layout::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void staff_layout::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }


  // system_dividers
  // 

  const system_dividers::left_divider_type& system_dividers::
  left_divider () const
  {
    return this->left_divider_.get ();
  }

  system_dividers::left_divider_type& system_dividers::
  left_divider ()
  {
    return this->left_divider_.get ();
  }

  void system_dividers::
  left_divider (const left_divider_type& x)
  {
    this->left_divider_.set (x);
  }

  void system_dividers::
  left_divider (::std::unique_ptr< left_divider_type > x)
  {
    this->left_divider_.set (std::move (x));
  }

  const system_dividers::right_divider_type& system_dividers::
  right_divider () const
  {
    return this->right_divider_.get ();
  }

  system_dividers::right_divider_type& system_dividers::
  right_divider ()
  {
    return this->right_divider_.get ();
  }

  void system_dividers::
  right_divider (const right_divider_type& x)
  {
    this->right_divider_.set (x);
  }

  void system_dividers::
  right_divider (::std::unique_ptr< right_divider_type > x)
  {
    this->right_divider_.set (std::move (x));
  }


  // system_layout
  // 

  const system_layout::system_margins_optional& system_layout::
  system_margins () const
  {
    return this->system_margins_;
  }

  system_layout::system_margins_optional& system_layout::
  system_margins ()
  {
    return this->system_margins_;
  }

  void system_layout::
  system_margins (const system_margins_type& x)
  {
    this->system_margins_.set (x);
  }

  void system_layout::
  system_margins (const system_margins_optional& x)
  {
    this->system_margins_ = x;
  }

  void system_layout::
  system_margins (::std::unique_ptr< system_margins_type > x)
  {
    this->system_margins_.set (std::move (x));
  }

  const system_layout::system_distance_optional& system_layout::
  system_distance () const
  {
    return this->system_distance_;
  }

  system_layout::system_distance_optional& system_layout::
  system_distance ()
  {
    return this->system_distance_;
  }

  void system_layout::
  system_distance (const system_distance_type& x)
  {
    this->system_distance_.set (x);
  }

  void system_layout::
  system_distance (const system_distance_optional& x)
  {
    this->system_distance_ = x;
  }

  void system_layout::
  system_distance (::std::unique_ptr< system_distance_type > x)
  {
    this->system_distance_.set (std::move (x));
  }

  const system_layout::top_system_distance_optional& system_layout::
  top_system_distance () const
  {
    return this->top_system_distance_;
  }

  system_layout::top_system_distance_optional& system_layout::
  top_system_distance ()
  {
    return this->top_system_distance_;
  }

  void system_layout::
  top_system_distance (const top_system_distance_type& x)
  {
    this->top_system_distance_.set (x);
  }

  void system_layout::
  top_system_distance (const top_system_distance_optional& x)
  {
    this->top_system_distance_ = x;
  }

  void system_layout::
  top_system_distance (::std::unique_ptr< top_system_distance_type > x)
  {
    this->top_system_distance_.set (std::move (x));
  }

  const system_layout::system_dividers_optional& system_layout::
  system_dividers () const
  {
    return this->system_dividers_;
  }

  system_layout::system_dividers_optional& system_layout::
  system_dividers ()
  {
    return this->system_dividers_;
  }

  void system_layout::
  system_dividers (const system_dividers_type& x)
  {
    this->system_dividers_.set (x);
  }

  void system_layout::
  system_dividers (const system_dividers_optional& x)
  {
    this->system_dividers_ = x;
  }

  void system_layout::
  system_dividers (::std::unique_ptr< system_dividers_type > x)
  {
    this->system_dividers_.set (std::move (x));
  }


  // system_margins
  // 

  const system_margins::left_margin_type& system_margins::
  left_margin () const
  {
    return this->left_margin_.get ();
  }

  system_margins::left_margin_type& system_margins::
  left_margin ()
  {
    return this->left_margin_.get ();
  }

  void system_margins::
  left_margin (const left_margin_type& x)
  {
    this->left_margin_.set (x);
  }

  void system_margins::
  left_margin (::std::unique_ptr< left_margin_type > x)
  {
    this->left_margin_.set (std::move (x));
  }

  const system_margins::right_margin_type& system_margins::
  right_margin () const
  {
    return this->right_margin_.get ();
  }

  system_margins::right_margin_type& system_margins::
  right_margin ()
  {
    return this->right_margin_.get ();
  }

  void system_margins::
  right_margin (const right_margin_type& x)
  {
    this->right_margin_.set (x);
  }

  void system_margins::
  right_margin (::std::unique_ptr< right_margin_type > x)
  {
    this->right_margin_.set (std::move (x));
  }


  // bookmark
  // 

  const bookmark::id_type& bookmark::
  id () const
  {
    return this->id_.get ();
  }

  bookmark::id_type& bookmark::
  id ()
  {
    return this->id_.get ();
  }

  void bookmark::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void bookmark::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const bookmark::name_optional& bookmark::
  name () const
  {
    return this->name_;
  }

  bookmark::name_optional& bookmark::
  name ()
  {
    return this->name_;
  }

  void bookmark::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void bookmark::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void bookmark::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const bookmark::element_optional& bookmark::
  element () const
  {
    return this->element_;
  }

  bookmark::element_optional& bookmark::
  element ()
  {
    return this->element_;
  }

  void bookmark::
  element (const element_type& x)
  {
    this->element_.set (x);
  }

  void bookmark::
  element (const element_optional& x)
  {
    this->element_ = x;
  }

  void bookmark::
  element (::std::unique_ptr< element_type > x)
  {
    this->element_.set (std::move (x));
  }

  const bookmark::position_optional& bookmark::
  position () const
  {
    return this->position_;
  }

  bookmark::position_optional& bookmark::
  position ()
  {
    return this->position_;
  }

  void bookmark::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  void bookmark::
  position (const position_optional& x)
  {
    this->position_ = x;
  }


  // link
  // 

  const link::href_type& link::
  href () const
  {
    return this->href_.get ();
  }

  link::href_type& link::
  href ()
  {
    return this->href_.get ();
  }

  void link::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void link::
  href (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }

  const link::type_type& link::
  type () const
  {
    return this->type_.get ();
  }

  const link::type_type& link::
  type_default_value ()
  {
    return type_default_value_;
  }

  const link::role_optional& link::
  role () const
  {
    return this->role_;
  }

  link::role_optional& link::
  role ()
  {
    return this->role_;
  }

  void link::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void link::
  role (const role_optional& x)
  {
    this->role_ = x;
  }

  void link::
  role (::std::unique_ptr< role_type > x)
  {
    this->role_.set (std::move (x));
  }

  const link::title_optional& link::
  title () const
  {
    return this->title_;
  }

  link::title_optional& link::
  title ()
  {
    return this->title_;
  }

  void link::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void link::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void link::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const link::show_type& link::
  show () const
  {
    return this->show_.get ();
  }

  link::show_type& link::
  show ()
  {
    return this->show_.get ();
  }

  void link::
  show (const show_type& x)
  {
    this->show_.set (x);
  }

  void link::
  show (::std::unique_ptr< show_type > x)
  {
    this->show_.set (std::move (x));
  }

  const link::show_type& link::
  show_default_value ()
  {
    return show_default_value_;
  }

  const link::actuate_type& link::
  actuate () const
  {
    return this->actuate_.get ();
  }

  link::actuate_type& link::
  actuate ()
  {
    return this->actuate_.get ();
  }

  void link::
  actuate (const actuate_type& x)
  {
    this->actuate_.set (x);
  }

  void link::
  actuate (::std::unique_ptr< actuate_type > x)
  {
    this->actuate_.set (std::move (x));
  }

  const link::actuate_type& link::
  actuate_default_value ()
  {
    return actuate_default_value_;
  }

  const link::name_optional& link::
  name () const
  {
    return this->name_;
  }

  link::name_optional& link::
  name ()
  {
    return this->name_;
  }

  void link::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void link::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void link::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const link::element_optional& link::
  element () const
  {
    return this->element_;
  }

  link::element_optional& link::
  element ()
  {
    return this->element_;
  }

  void link::
  element (const element_type& x)
  {
    this->element_.set (x);
  }

  void link::
  element (const element_optional& x)
  {
    this->element_ = x;
  }

  void link::
  element (::std::unique_ptr< element_type > x)
  {
    this->element_.set (std::move (x));
  }

  const link::position_optional& link::
  position () const
  {
    return this->position_;
  }

  link::position_optional& link::
  position ()
  {
    return this->position_;
  }

  void link::
  position (const position_type& x)
  {
    this->position_.set (x);
  }

  void link::
  position (const position_optional& x)
  {
    this->position_ = x;
  }

  const link::default_x_optional& link::
  default_x () const
  {
    return this->default_x_;
  }

  link::default_x_optional& link::
  default_x ()
  {
    return this->default_x_;
  }

  void link::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void link::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void link::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const link::default_y_optional& link::
  default_y () const
  {
    return this->default_y_;
  }

  link::default_y_optional& link::
  default_y ()
  {
    return this->default_y_;
  }

  void link::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void link::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void link::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const link::relative_x_optional& link::
  relative_x () const
  {
    return this->relative_x_;
  }

  link::relative_x_optional& link::
  relative_x ()
  {
    return this->relative_x_;
  }

  void link::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void link::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void link::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const link::relative_y_optional& link::
  relative_y () const
  {
    return this->relative_y_;
  }

  link::relative_y_optional& link::
  relative_y ()
  {
    return this->relative_y_;
  }

  void link::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void link::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void link::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }


  // accidental
  // 

  const accidental::cautionary_optional& accidental::
  cautionary () const
  {
    return this->cautionary_;
  }

  accidental::cautionary_optional& accidental::
  cautionary ()
  {
    return this->cautionary_;
  }

  void accidental::
  cautionary (const cautionary_type& x)
  {
    this->cautionary_.set (x);
  }

  void accidental::
  cautionary (const cautionary_optional& x)
  {
    this->cautionary_ = x;
  }

  void accidental::
  cautionary (::std::unique_ptr< cautionary_type > x)
  {
    this->cautionary_.set (std::move (x));
  }

  const accidental::editorial_optional& accidental::
  editorial () const
  {
    return this->editorial_;
  }

  accidental::editorial_optional& accidental::
  editorial ()
  {
    return this->editorial_;
  }

  void accidental::
  editorial (const editorial_type& x)
  {
    this->editorial_.set (x);
  }

  void accidental::
  editorial (const editorial_optional& x)
  {
    this->editorial_ = x;
  }

  void accidental::
  editorial (::std::unique_ptr< editorial_type > x)
  {
    this->editorial_.set (std::move (x));
  }

  const accidental::parentheses_optional& accidental::
  parentheses () const
  {
    return this->parentheses_;
  }

  accidental::parentheses_optional& accidental::
  parentheses ()
  {
    return this->parentheses_;
  }

  void accidental::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void accidental::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void accidental::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const accidental::bracket_optional& accidental::
  bracket () const
  {
    return this->bracket_;
  }

  accidental::bracket_optional& accidental::
  bracket ()
  {
    return this->bracket_;
  }

  void accidental::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void accidental::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void accidental::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const accidental::size_optional& accidental::
  size () const
  {
    return this->size_;
  }

  accidental::size_optional& accidental::
  size ()
  {
    return this->size_;
  }

  void accidental::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void accidental::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void accidental::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }

  const accidental::default_x_optional& accidental::
  default_x () const
  {
    return this->default_x_;
  }

  accidental::default_x_optional& accidental::
  default_x ()
  {
    return this->default_x_;
  }

  void accidental::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void accidental::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void accidental::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const accidental::default_y_optional& accidental::
  default_y () const
  {
    return this->default_y_;
  }

  accidental::default_y_optional& accidental::
  default_y ()
  {
    return this->default_y_;
  }

  void accidental::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void accidental::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void accidental::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const accidental::relative_x_optional& accidental::
  relative_x () const
  {
    return this->relative_x_;
  }

  accidental::relative_x_optional& accidental::
  relative_x ()
  {
    return this->relative_x_;
  }

  void accidental::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void accidental::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void accidental::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const accidental::relative_y_optional& accidental::
  relative_y () const
  {
    return this->relative_y_;
  }

  accidental::relative_y_optional& accidental::
  relative_y ()
  {
    return this->relative_y_;
  }

  void accidental::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void accidental::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void accidental::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const accidental::font_family_optional& accidental::
  font_family () const
  {
    return this->font_family_;
  }

  accidental::font_family_optional& accidental::
  font_family ()
  {
    return this->font_family_;
  }

  void accidental::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void accidental::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void accidental::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const accidental::font_style_optional& accidental::
  font_style () const
  {
    return this->font_style_;
  }

  accidental::font_style_optional& accidental::
  font_style ()
  {
    return this->font_style_;
  }

  void accidental::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void accidental::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void accidental::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const accidental::font_size_optional& accidental::
  font_size () const
  {
    return this->font_size_;
  }

  accidental::font_size_optional& accidental::
  font_size ()
  {
    return this->font_size_;
  }

  void accidental::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void accidental::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void accidental::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const accidental::font_weight_optional& accidental::
  font_weight () const
  {
    return this->font_weight_;
  }

  accidental::font_weight_optional& accidental::
  font_weight ()
  {
    return this->font_weight_;
  }

  void accidental::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void accidental::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void accidental::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const accidental::color_optional& accidental::
  color () const
  {
    return this->color_;
  }

  accidental::color_optional& accidental::
  color ()
  {
    return this->color_;
  }

  void accidental::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void accidental::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void accidental::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const accidental::smufl_optional& accidental::
  smufl () const
  {
    return this->smufl_;
  }

  accidental::smufl_optional& accidental::
  smufl ()
  {
    return this->smufl_;
  }

  void accidental::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void accidental::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void accidental::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // accidental_mark
  // 

  const accidental_mark::parentheses_optional& accidental_mark::
  parentheses () const
  {
    return this->parentheses_;
  }

  accidental_mark::parentheses_optional& accidental_mark::
  parentheses ()
  {
    return this->parentheses_;
  }

  void accidental_mark::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void accidental_mark::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void accidental_mark::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const accidental_mark::bracket_optional& accidental_mark::
  bracket () const
  {
    return this->bracket_;
  }

  accidental_mark::bracket_optional& accidental_mark::
  bracket ()
  {
    return this->bracket_;
  }

  void accidental_mark::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void accidental_mark::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void accidental_mark::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const accidental_mark::size_optional& accidental_mark::
  size () const
  {
    return this->size_;
  }

  accidental_mark::size_optional& accidental_mark::
  size ()
  {
    return this->size_;
  }

  void accidental_mark::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void accidental_mark::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void accidental_mark::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }

  const accidental_mark::default_x_optional& accidental_mark::
  default_x () const
  {
    return this->default_x_;
  }

  accidental_mark::default_x_optional& accidental_mark::
  default_x ()
  {
    return this->default_x_;
  }

  void accidental_mark::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void accidental_mark::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void accidental_mark::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const accidental_mark::default_y_optional& accidental_mark::
  default_y () const
  {
    return this->default_y_;
  }

  accidental_mark::default_y_optional& accidental_mark::
  default_y ()
  {
    return this->default_y_;
  }

  void accidental_mark::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void accidental_mark::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void accidental_mark::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const accidental_mark::relative_x_optional& accidental_mark::
  relative_x () const
  {
    return this->relative_x_;
  }

  accidental_mark::relative_x_optional& accidental_mark::
  relative_x ()
  {
    return this->relative_x_;
  }

  void accidental_mark::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void accidental_mark::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void accidental_mark::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const accidental_mark::relative_y_optional& accidental_mark::
  relative_y () const
  {
    return this->relative_y_;
  }

  accidental_mark::relative_y_optional& accidental_mark::
  relative_y ()
  {
    return this->relative_y_;
  }

  void accidental_mark::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void accidental_mark::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void accidental_mark::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const accidental_mark::font_family_optional& accidental_mark::
  font_family () const
  {
    return this->font_family_;
  }

  accidental_mark::font_family_optional& accidental_mark::
  font_family ()
  {
    return this->font_family_;
  }

  void accidental_mark::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void accidental_mark::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void accidental_mark::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const accidental_mark::font_style_optional& accidental_mark::
  font_style () const
  {
    return this->font_style_;
  }

  accidental_mark::font_style_optional& accidental_mark::
  font_style ()
  {
    return this->font_style_;
  }

  void accidental_mark::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void accidental_mark::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void accidental_mark::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const accidental_mark::font_size_optional& accidental_mark::
  font_size () const
  {
    return this->font_size_;
  }

  accidental_mark::font_size_optional& accidental_mark::
  font_size ()
  {
    return this->font_size_;
  }

  void accidental_mark::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void accidental_mark::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void accidental_mark::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const accidental_mark::font_weight_optional& accidental_mark::
  font_weight () const
  {
    return this->font_weight_;
  }

  accidental_mark::font_weight_optional& accidental_mark::
  font_weight ()
  {
    return this->font_weight_;
  }

  void accidental_mark::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void accidental_mark::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void accidental_mark::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const accidental_mark::color_optional& accidental_mark::
  color () const
  {
    return this->color_;
  }

  accidental_mark::color_optional& accidental_mark::
  color ()
  {
    return this->color_;
  }

  void accidental_mark::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void accidental_mark::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void accidental_mark::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const accidental_mark::placement_optional& accidental_mark::
  placement () const
  {
    return this->placement_;
  }

  accidental_mark::placement_optional& accidental_mark::
  placement ()
  {
    return this->placement_;
  }

  void accidental_mark::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void accidental_mark::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void accidental_mark::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const accidental_mark::smufl_optional& accidental_mark::
  smufl () const
  {
    return this->smufl_;
  }

  accidental_mark::smufl_optional& accidental_mark::
  smufl ()
  {
    return this->smufl_;
  }

  void accidental_mark::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void accidental_mark::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void accidental_mark::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }

  const accidental_mark::id_optional& accidental_mark::
  id () const
  {
    return this->id_;
  }

  accidental_mark::id_optional& accidental_mark::
  id ()
  {
    return this->id_;
  }

  void accidental_mark::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void accidental_mark::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void accidental_mark::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // arpeggiate
  // 

  const arpeggiate::number_optional& arpeggiate::
  number () const
  {
    return this->number_;
  }

  arpeggiate::number_optional& arpeggiate::
  number ()
  {
    return this->number_;
  }

  void arpeggiate::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void arpeggiate::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void arpeggiate::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const arpeggiate::direction_optional& arpeggiate::
  direction () const
  {
    return this->direction_;
  }

  arpeggiate::direction_optional& arpeggiate::
  direction ()
  {
    return this->direction_;
  }

  void arpeggiate::
  direction (const direction_type& x)
  {
    this->direction_.set (x);
  }

  void arpeggiate::
  direction (const direction_optional& x)
  {
    this->direction_ = x;
  }

  void arpeggiate::
  direction (::std::unique_ptr< direction_type > x)
  {
    this->direction_.set (std::move (x));
  }

  const arpeggiate::unbroken_optional& arpeggiate::
  unbroken () const
  {
    return this->unbroken_;
  }

  arpeggiate::unbroken_optional& arpeggiate::
  unbroken ()
  {
    return this->unbroken_;
  }

  void arpeggiate::
  unbroken (const unbroken_type& x)
  {
    this->unbroken_.set (x);
  }

  void arpeggiate::
  unbroken (const unbroken_optional& x)
  {
    this->unbroken_ = x;
  }

  void arpeggiate::
  unbroken (::std::unique_ptr< unbroken_type > x)
  {
    this->unbroken_.set (std::move (x));
  }

  const arpeggiate::default_x_optional& arpeggiate::
  default_x () const
  {
    return this->default_x_;
  }

  arpeggiate::default_x_optional& arpeggiate::
  default_x ()
  {
    return this->default_x_;
  }

  void arpeggiate::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void arpeggiate::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void arpeggiate::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const arpeggiate::default_y_optional& arpeggiate::
  default_y () const
  {
    return this->default_y_;
  }

  arpeggiate::default_y_optional& arpeggiate::
  default_y ()
  {
    return this->default_y_;
  }

  void arpeggiate::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void arpeggiate::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void arpeggiate::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const arpeggiate::relative_x_optional& arpeggiate::
  relative_x () const
  {
    return this->relative_x_;
  }

  arpeggiate::relative_x_optional& arpeggiate::
  relative_x ()
  {
    return this->relative_x_;
  }

  void arpeggiate::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void arpeggiate::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void arpeggiate::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const arpeggiate::relative_y_optional& arpeggiate::
  relative_y () const
  {
    return this->relative_y_;
  }

  arpeggiate::relative_y_optional& arpeggiate::
  relative_y ()
  {
    return this->relative_y_;
  }

  void arpeggiate::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void arpeggiate::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void arpeggiate::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const arpeggiate::placement_optional& arpeggiate::
  placement () const
  {
    return this->placement_;
  }

  arpeggiate::placement_optional& arpeggiate::
  placement ()
  {
    return this->placement_;
  }

  void arpeggiate::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void arpeggiate::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void arpeggiate::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const arpeggiate::color_optional& arpeggiate::
  color () const
  {
    return this->color_;
  }

  arpeggiate::color_optional& arpeggiate::
  color ()
  {
    return this->color_;
  }

  void arpeggiate::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void arpeggiate::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void arpeggiate::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const arpeggiate::id_optional& arpeggiate::
  id () const
  {
    return this->id_;
  }

  arpeggiate::id_optional& arpeggiate::
  id ()
  {
    return this->id_;
  }

  void arpeggiate::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void arpeggiate::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void arpeggiate::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // articulations
  // 

  const articulations::accent_sequence& articulations::
  accent () const
  {
    return this->accent_;
  }

  articulations::accent_sequence& articulations::
  accent ()
  {
    return this->accent_;
  }

  void articulations::
  accent (const accent_sequence& s)
  {
    this->accent_ = s;
  }

  const articulations::strong_accent_sequence& articulations::
  strong_accent () const
  {
    return this->strong_accent_;
  }

  articulations::strong_accent_sequence& articulations::
  strong_accent ()
  {
    return this->strong_accent_;
  }

  void articulations::
  strong_accent (const strong_accent_sequence& s)
  {
    this->strong_accent_ = s;
  }

  const articulations::staccato_sequence& articulations::
  staccato () const
  {
    return this->staccato_;
  }

  articulations::staccato_sequence& articulations::
  staccato ()
  {
    return this->staccato_;
  }

  void articulations::
  staccato (const staccato_sequence& s)
  {
    this->staccato_ = s;
  }

  const articulations::tenuto_sequence& articulations::
  tenuto () const
  {
    return this->tenuto_;
  }

  articulations::tenuto_sequence& articulations::
  tenuto ()
  {
    return this->tenuto_;
  }

  void articulations::
  tenuto (const tenuto_sequence& s)
  {
    this->tenuto_ = s;
  }

  const articulations::detached_legato_sequence& articulations::
  detached_legato () const
  {
    return this->detached_legato_;
  }

  articulations::detached_legato_sequence& articulations::
  detached_legato ()
  {
    return this->detached_legato_;
  }

  void articulations::
  detached_legato (const detached_legato_sequence& s)
  {
    this->detached_legato_ = s;
  }

  const articulations::staccatissimo_sequence& articulations::
  staccatissimo () const
  {
    return this->staccatissimo_;
  }

  articulations::staccatissimo_sequence& articulations::
  staccatissimo ()
  {
    return this->staccatissimo_;
  }

  void articulations::
  staccatissimo (const staccatissimo_sequence& s)
  {
    this->staccatissimo_ = s;
  }

  const articulations::spiccato_sequence& articulations::
  spiccato () const
  {
    return this->spiccato_;
  }

  articulations::spiccato_sequence& articulations::
  spiccato ()
  {
    return this->spiccato_;
  }

  void articulations::
  spiccato (const spiccato_sequence& s)
  {
    this->spiccato_ = s;
  }

  const articulations::scoop_sequence& articulations::
  scoop () const
  {
    return this->scoop_;
  }

  articulations::scoop_sequence& articulations::
  scoop ()
  {
    return this->scoop_;
  }

  void articulations::
  scoop (const scoop_sequence& s)
  {
    this->scoop_ = s;
  }

  const articulations::plop_sequence& articulations::
  plop () const
  {
    return this->plop_;
  }

  articulations::plop_sequence& articulations::
  plop ()
  {
    return this->plop_;
  }

  void articulations::
  plop (const plop_sequence& s)
  {
    this->plop_ = s;
  }

  const articulations::doit_sequence& articulations::
  doit () const
  {
    return this->doit_;
  }

  articulations::doit_sequence& articulations::
  doit ()
  {
    return this->doit_;
  }

  void articulations::
  doit (const doit_sequence& s)
  {
    this->doit_ = s;
  }

  const articulations::falloff_sequence& articulations::
  falloff () const
  {
    return this->falloff_;
  }

  articulations::falloff_sequence& articulations::
  falloff ()
  {
    return this->falloff_;
  }

  void articulations::
  falloff (const falloff_sequence& s)
  {
    this->falloff_ = s;
  }

  const articulations::breath_mark_sequence& articulations::
  breath_mark () const
  {
    return this->breath_mark_;
  }

  articulations::breath_mark_sequence& articulations::
  breath_mark ()
  {
    return this->breath_mark_;
  }

  void articulations::
  breath_mark (const breath_mark_sequence& s)
  {
    this->breath_mark_ = s;
  }

  const articulations::caesura_sequence& articulations::
  caesura () const
  {
    return this->caesura_;
  }

  articulations::caesura_sequence& articulations::
  caesura ()
  {
    return this->caesura_;
  }

  void articulations::
  caesura (const caesura_sequence& s)
  {
    this->caesura_ = s;
  }

  const articulations::stress_sequence& articulations::
  stress () const
  {
    return this->stress_;
  }

  articulations::stress_sequence& articulations::
  stress ()
  {
    return this->stress_;
  }

  void articulations::
  stress (const stress_sequence& s)
  {
    this->stress_ = s;
  }

  const articulations::unstress_sequence& articulations::
  unstress () const
  {
    return this->unstress_;
  }

  articulations::unstress_sequence& articulations::
  unstress ()
  {
    return this->unstress_;
  }

  void articulations::
  unstress (const unstress_sequence& s)
  {
    this->unstress_ = s;
  }

  const articulations::soft_accent_sequence& articulations::
  soft_accent () const
  {
    return this->soft_accent_;
  }

  articulations::soft_accent_sequence& articulations::
  soft_accent ()
  {
    return this->soft_accent_;
  }

  void articulations::
  soft_accent (const soft_accent_sequence& s)
  {
    this->soft_accent_ = s;
  }

  const articulations::other_articulation_sequence& articulations::
  other_articulation () const
  {
    return this->other_articulation_;
  }

  articulations::other_articulation_sequence& articulations::
  other_articulation ()
  {
    return this->other_articulation_;
  }

  void articulations::
  other_articulation (const other_articulation_sequence& s)
  {
    this->other_articulation_ = s;
  }

  const articulations::id_optional& articulations::
  id () const
  {
    return this->id_;
  }

  articulations::id_optional& articulations::
  id ()
  {
    return this->id_;
  }

  void articulations::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void articulations::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void articulations::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // arrow
  // 

  const arrow::arrow_direction_optional& arrow::
  arrow_direction () const
  {
    return this->arrow_direction_;
  }

  arrow::arrow_direction_optional& arrow::
  arrow_direction ()
  {
    return this->arrow_direction_;
  }

  void arrow::
  arrow_direction (const arrow_direction_type& x)
  {
    this->arrow_direction_.set (x);
  }

  void arrow::
  arrow_direction (const arrow_direction_optional& x)
  {
    this->arrow_direction_ = x;
  }

  void arrow::
  arrow_direction (::std::unique_ptr< arrow_direction_type > x)
  {
    this->arrow_direction_.set (std::move (x));
  }

  const arrow::arrow_style_optional& arrow::
  arrow_style () const
  {
    return this->arrow_style_;
  }

  arrow::arrow_style_optional& arrow::
  arrow_style ()
  {
    return this->arrow_style_;
  }

  void arrow::
  arrow_style (const arrow_style_type& x)
  {
    this->arrow_style_.set (x);
  }

  void arrow::
  arrow_style (const arrow_style_optional& x)
  {
    this->arrow_style_ = x;
  }

  void arrow::
  arrow_style (::std::unique_ptr< arrow_style_type > x)
  {
    this->arrow_style_.set (std::move (x));
  }

  const arrow::arrowhead_optional& arrow::
  arrowhead () const
  {
    return this->arrowhead_;
  }

  arrow::arrowhead_optional& arrow::
  arrowhead ()
  {
    return this->arrowhead_;
  }

  void arrow::
  arrowhead (const arrowhead_type& x)
  {
    this->arrowhead_.set (x);
  }

  void arrow::
  arrowhead (const arrowhead_optional& x)
  {
    this->arrowhead_ = x;
  }

  void arrow::
  arrowhead (::std::unique_ptr< arrowhead_type > x)
  {
    this->arrowhead_.set (std::move (x));
  }

  const arrow::circular_arrow_optional& arrow::
  circular_arrow () const
  {
    return this->circular_arrow_;
  }

  arrow::circular_arrow_optional& arrow::
  circular_arrow ()
  {
    return this->circular_arrow_;
  }

  void arrow::
  circular_arrow (const circular_arrow_type& x)
  {
    this->circular_arrow_.set (x);
  }

  void arrow::
  circular_arrow (const circular_arrow_optional& x)
  {
    this->circular_arrow_ = x;
  }

  void arrow::
  circular_arrow (::std::unique_ptr< circular_arrow_type > x)
  {
    this->circular_arrow_.set (std::move (x));
  }

  const arrow::default_x_optional& arrow::
  default_x () const
  {
    return this->default_x_;
  }

  arrow::default_x_optional& arrow::
  default_x ()
  {
    return this->default_x_;
  }

  void arrow::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void arrow::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void arrow::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const arrow::default_y_optional& arrow::
  default_y () const
  {
    return this->default_y_;
  }

  arrow::default_y_optional& arrow::
  default_y ()
  {
    return this->default_y_;
  }

  void arrow::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void arrow::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void arrow::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const arrow::relative_x_optional& arrow::
  relative_x () const
  {
    return this->relative_x_;
  }

  arrow::relative_x_optional& arrow::
  relative_x ()
  {
    return this->relative_x_;
  }

  void arrow::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void arrow::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void arrow::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const arrow::relative_y_optional& arrow::
  relative_y () const
  {
    return this->relative_y_;
  }

  arrow::relative_y_optional& arrow::
  relative_y ()
  {
    return this->relative_y_;
  }

  void arrow::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void arrow::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void arrow::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const arrow::font_family_optional& arrow::
  font_family () const
  {
    return this->font_family_;
  }

  arrow::font_family_optional& arrow::
  font_family ()
  {
    return this->font_family_;
  }

  void arrow::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void arrow::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void arrow::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const arrow::font_style_optional& arrow::
  font_style () const
  {
    return this->font_style_;
  }

  arrow::font_style_optional& arrow::
  font_style ()
  {
    return this->font_style_;
  }

  void arrow::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void arrow::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void arrow::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const arrow::font_size_optional& arrow::
  font_size () const
  {
    return this->font_size_;
  }

  arrow::font_size_optional& arrow::
  font_size ()
  {
    return this->font_size_;
  }

  void arrow::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void arrow::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void arrow::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const arrow::font_weight_optional& arrow::
  font_weight () const
  {
    return this->font_weight_;
  }

  arrow::font_weight_optional& arrow::
  font_weight ()
  {
    return this->font_weight_;
  }

  void arrow::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void arrow::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void arrow::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const arrow::color_optional& arrow::
  color () const
  {
    return this->color_;
  }

  arrow::color_optional& arrow::
  color ()
  {
    return this->color_;
  }

  void arrow::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void arrow::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void arrow::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const arrow::placement_optional& arrow::
  placement () const
  {
    return this->placement_;
  }

  arrow::placement_optional& arrow::
  placement ()
  {
    return this->placement_;
  }

  void arrow::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void arrow::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void arrow::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const arrow::smufl_optional& arrow::
  smufl () const
  {
    return this->smufl_;
  }

  arrow::smufl_optional& arrow::
  smufl ()
  {
    return this->smufl_;
  }

  void arrow::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void arrow::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void arrow::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // assess
  // 

  const assess::type_type& assess::
  type () const
  {
    return this->type_.get ();
  }

  assess::type_type& assess::
  type ()
  {
    return this->type_.get ();
  }

  void assess::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void assess::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const assess::player_optional& assess::
  player () const
  {
    return this->player_;
  }

  assess::player_optional& assess::
  player ()
  {
    return this->player_;
  }

  void assess::
  player (const player_type& x)
  {
    this->player_.set (x);
  }

  void assess::
  player (const player_optional& x)
  {
    this->player_ = x;
  }

  void assess::
  player (::std::unique_ptr< player_type > x)
  {
    this->player_.set (std::move (x));
  }

  const assess::time_only_optional& assess::
  time_only () const
  {
    return this->time_only_;
  }

  assess::time_only_optional& assess::
  time_only ()
  {
    return this->time_only_;
  }

  void assess::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void assess::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void assess::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }


  // backup
  // 

  const backup::duration_type& backup::
  duration () const
  {
    return this->duration_.get ();
  }

  backup::duration_type& backup::
  duration ()
  {
    return this->duration_.get ();
  }

  void backup::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void backup::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const backup::footnote_optional& backup::
  footnote () const
  {
    return this->footnote_;
  }

  backup::footnote_optional& backup::
  footnote ()
  {
    return this->footnote_;
  }

  void backup::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void backup::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void backup::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const backup::level_optional& backup::
  level () const
  {
    return this->level_;
  }

  backup::level_optional& backup::
  level ()
  {
    return this->level_;
  }

  void backup::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void backup::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void backup::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }


  // beam
  // 

  const beam::number_type& beam::
  number () const
  {
    return this->number_.get ();
  }

  beam::number_type& beam::
  number ()
  {
    return this->number_.get ();
  }

  void beam::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void beam::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  beam::number_type beam::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const beam::repeater_optional& beam::
  repeater () const
  {
    return this->repeater_;
  }

  beam::repeater_optional& beam::
  repeater ()
  {
    return this->repeater_;
  }

  void beam::
  repeater (const repeater_type& x)
  {
    this->repeater_.set (x);
  }

  void beam::
  repeater (const repeater_optional& x)
  {
    this->repeater_ = x;
  }

  void beam::
  repeater (::std::unique_ptr< repeater_type > x)
  {
    this->repeater_.set (std::move (x));
  }

  const beam::fan_optional& beam::
  fan () const
  {
    return this->fan_;
  }

  beam::fan_optional& beam::
  fan ()
  {
    return this->fan_;
  }

  void beam::
  fan (const fan_type& x)
  {
    this->fan_.set (x);
  }

  void beam::
  fan (const fan_optional& x)
  {
    this->fan_ = x;
  }

  void beam::
  fan (::std::unique_ptr< fan_type > x)
  {
    this->fan_.set (std::move (x));
  }

  const beam::color_optional& beam::
  color () const
  {
    return this->color_;
  }

  beam::color_optional& beam::
  color ()
  {
    return this->color_;
  }

  void beam::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void beam::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void beam::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const beam::id_optional& beam::
  id () const
  {
    return this->id_;
  }

  beam::id_optional& beam::
  id ()
  {
    return this->id_;
  }

  void beam::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void beam::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void beam::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // bend
  // 

  const bend::bend_alter_type& bend::
  bend_alter () const
  {
    return this->bend_alter_.get ();
  }

  bend::bend_alter_type& bend::
  bend_alter ()
  {
    return this->bend_alter_.get ();
  }

  void bend::
  bend_alter (const bend_alter_type& x)
  {
    this->bend_alter_.set (x);
  }

  void bend::
  bend_alter (::std::unique_ptr< bend_alter_type > x)
  {
    this->bend_alter_.set (std::move (x));
  }

  const bend::pre_bend_optional& bend::
  pre_bend () const
  {
    return this->pre_bend_;
  }

  bend::pre_bend_optional& bend::
  pre_bend ()
  {
    return this->pre_bend_;
  }

  void bend::
  pre_bend (const pre_bend_type& x)
  {
    this->pre_bend_.set (x);
  }

  void bend::
  pre_bend (const pre_bend_optional& x)
  {
    this->pre_bend_ = x;
  }

  void bend::
  pre_bend (::std::unique_ptr< pre_bend_type > x)
  {
    this->pre_bend_.set (std::move (x));
  }

  const bend::release_optional& bend::
  release () const
  {
    return this->release_;
  }

  bend::release_optional& bend::
  release ()
  {
    return this->release_;
  }

  void bend::
  release (const release_type& x)
  {
    this->release_.set (x);
  }

  void bend::
  release (const release_optional& x)
  {
    this->release_ = x;
  }

  void bend::
  release (::std::unique_ptr< release_type > x)
  {
    this->release_.set (std::move (x));
  }

  const bend::with_bar_optional& bend::
  with_bar () const
  {
    return this->with_bar_;
  }

  bend::with_bar_optional& bend::
  with_bar ()
  {
    return this->with_bar_;
  }

  void bend::
  with_bar (const with_bar_type& x)
  {
    this->with_bar_.set (x);
  }

  void bend::
  with_bar (const with_bar_optional& x)
  {
    this->with_bar_ = x;
  }

  void bend::
  with_bar (::std::unique_ptr< with_bar_type > x)
  {
    this->with_bar_.set (std::move (x));
  }

  const bend::shape_optional& bend::
  shape () const
  {
    return this->shape_;
  }

  bend::shape_optional& bend::
  shape ()
  {
    return this->shape_;
  }

  void bend::
  shape (const shape_type& x)
  {
    this->shape_.set (x);
  }

  void bend::
  shape (const shape_optional& x)
  {
    this->shape_ = x;
  }

  void bend::
  shape (::std::unique_ptr< shape_type > x)
  {
    this->shape_.set (std::move (x));
  }

  const bend::default_x_optional& bend::
  default_x () const
  {
    return this->default_x_;
  }

  bend::default_x_optional& bend::
  default_x ()
  {
    return this->default_x_;
  }

  void bend::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void bend::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void bend::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const bend::default_y_optional& bend::
  default_y () const
  {
    return this->default_y_;
  }

  bend::default_y_optional& bend::
  default_y ()
  {
    return this->default_y_;
  }

  void bend::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void bend::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void bend::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const bend::relative_x_optional& bend::
  relative_x () const
  {
    return this->relative_x_;
  }

  bend::relative_x_optional& bend::
  relative_x ()
  {
    return this->relative_x_;
  }

  void bend::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void bend::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void bend::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const bend::relative_y_optional& bend::
  relative_y () const
  {
    return this->relative_y_;
  }

  bend::relative_y_optional& bend::
  relative_y ()
  {
    return this->relative_y_;
  }

  void bend::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void bend::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void bend::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const bend::font_family_optional& bend::
  font_family () const
  {
    return this->font_family_;
  }

  bend::font_family_optional& bend::
  font_family ()
  {
    return this->font_family_;
  }

  void bend::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void bend::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void bend::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const bend::font_style_optional& bend::
  font_style () const
  {
    return this->font_style_;
  }

  bend::font_style_optional& bend::
  font_style ()
  {
    return this->font_style_;
  }

  void bend::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void bend::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void bend::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const bend::font_size_optional& bend::
  font_size () const
  {
    return this->font_size_;
  }

  bend::font_size_optional& bend::
  font_size ()
  {
    return this->font_size_;
  }

  void bend::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void bend::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void bend::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const bend::font_weight_optional& bend::
  font_weight () const
  {
    return this->font_weight_;
  }

  bend::font_weight_optional& bend::
  font_weight ()
  {
    return this->font_weight_;
  }

  void bend::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void bend::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void bend::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const bend::color_optional& bend::
  color () const
  {
    return this->color_;
  }

  bend::color_optional& bend::
  color ()
  {
    return this->color_;
  }

  void bend::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void bend::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void bend::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const bend::accelerate_optional& bend::
  accelerate () const
  {
    return this->accelerate_;
  }

  bend::accelerate_optional& bend::
  accelerate ()
  {
    return this->accelerate_;
  }

  void bend::
  accelerate (const accelerate_type& x)
  {
    this->accelerate_.set (x);
  }

  void bend::
  accelerate (const accelerate_optional& x)
  {
    this->accelerate_ = x;
  }

  void bend::
  accelerate (::std::unique_ptr< accelerate_type > x)
  {
    this->accelerate_.set (std::move (x));
  }

  const bend::beats_optional& bend::
  beats () const
  {
    return this->beats_;
  }

  bend::beats_optional& bend::
  beats ()
  {
    return this->beats_;
  }

  void bend::
  beats (const beats_type& x)
  {
    this->beats_.set (x);
  }

  void bend::
  beats (const beats_optional& x)
  {
    this->beats_ = x;
  }

  void bend::
  beats (::std::unique_ptr< beats_type > x)
  {
    this->beats_.set (std::move (x));
  }

  const bend::first_beat_optional& bend::
  first_beat () const
  {
    return this->first_beat_;
  }

  bend::first_beat_optional& bend::
  first_beat ()
  {
    return this->first_beat_;
  }

  void bend::
  first_beat (const first_beat_type& x)
  {
    this->first_beat_.set (x);
  }

  void bend::
  first_beat (const first_beat_optional& x)
  {
    this->first_beat_ = x;
  }

  void bend::
  first_beat (::std::unique_ptr< first_beat_type > x)
  {
    this->first_beat_.set (std::move (x));
  }

  const bend::last_beat_optional& bend::
  last_beat () const
  {
    return this->last_beat_;
  }

  bend::last_beat_optional& bend::
  last_beat ()
  {
    return this->last_beat_;
  }

  void bend::
  last_beat (const last_beat_type& x)
  {
    this->last_beat_.set (x);
  }

  void bend::
  last_beat (const last_beat_optional& x)
  {
    this->last_beat_ = x;
  }

  void bend::
  last_beat (::std::unique_ptr< last_beat_type > x)
  {
    this->last_beat_.set (std::move (x));
  }


  // breath_mark
  // 

  const breath_mark::default_x_optional& breath_mark::
  default_x () const
  {
    return this->default_x_;
  }

  breath_mark::default_x_optional& breath_mark::
  default_x ()
  {
    return this->default_x_;
  }

  void breath_mark::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void breath_mark::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void breath_mark::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const breath_mark::default_y_optional& breath_mark::
  default_y () const
  {
    return this->default_y_;
  }

  breath_mark::default_y_optional& breath_mark::
  default_y ()
  {
    return this->default_y_;
  }

  void breath_mark::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void breath_mark::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void breath_mark::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const breath_mark::relative_x_optional& breath_mark::
  relative_x () const
  {
    return this->relative_x_;
  }

  breath_mark::relative_x_optional& breath_mark::
  relative_x ()
  {
    return this->relative_x_;
  }

  void breath_mark::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void breath_mark::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void breath_mark::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const breath_mark::relative_y_optional& breath_mark::
  relative_y () const
  {
    return this->relative_y_;
  }

  breath_mark::relative_y_optional& breath_mark::
  relative_y ()
  {
    return this->relative_y_;
  }

  void breath_mark::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void breath_mark::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void breath_mark::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const breath_mark::font_family_optional& breath_mark::
  font_family () const
  {
    return this->font_family_;
  }

  breath_mark::font_family_optional& breath_mark::
  font_family ()
  {
    return this->font_family_;
  }

  void breath_mark::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void breath_mark::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void breath_mark::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const breath_mark::font_style_optional& breath_mark::
  font_style () const
  {
    return this->font_style_;
  }

  breath_mark::font_style_optional& breath_mark::
  font_style ()
  {
    return this->font_style_;
  }

  void breath_mark::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void breath_mark::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void breath_mark::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const breath_mark::font_size_optional& breath_mark::
  font_size () const
  {
    return this->font_size_;
  }

  breath_mark::font_size_optional& breath_mark::
  font_size ()
  {
    return this->font_size_;
  }

  void breath_mark::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void breath_mark::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void breath_mark::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const breath_mark::font_weight_optional& breath_mark::
  font_weight () const
  {
    return this->font_weight_;
  }

  breath_mark::font_weight_optional& breath_mark::
  font_weight ()
  {
    return this->font_weight_;
  }

  void breath_mark::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void breath_mark::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void breath_mark::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const breath_mark::color_optional& breath_mark::
  color () const
  {
    return this->color_;
  }

  breath_mark::color_optional& breath_mark::
  color ()
  {
    return this->color_;
  }

  void breath_mark::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void breath_mark::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void breath_mark::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const breath_mark::placement_optional& breath_mark::
  placement () const
  {
    return this->placement_;
  }

  breath_mark::placement_optional& breath_mark::
  placement ()
  {
    return this->placement_;
  }

  void breath_mark::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void breath_mark::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void breath_mark::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // caesura
  // 

  const caesura::default_x_optional& caesura::
  default_x () const
  {
    return this->default_x_;
  }

  caesura::default_x_optional& caesura::
  default_x ()
  {
    return this->default_x_;
  }

  void caesura::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void caesura::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void caesura::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const caesura::default_y_optional& caesura::
  default_y () const
  {
    return this->default_y_;
  }

  caesura::default_y_optional& caesura::
  default_y ()
  {
    return this->default_y_;
  }

  void caesura::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void caesura::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void caesura::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const caesura::relative_x_optional& caesura::
  relative_x () const
  {
    return this->relative_x_;
  }

  caesura::relative_x_optional& caesura::
  relative_x ()
  {
    return this->relative_x_;
  }

  void caesura::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void caesura::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void caesura::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const caesura::relative_y_optional& caesura::
  relative_y () const
  {
    return this->relative_y_;
  }

  caesura::relative_y_optional& caesura::
  relative_y ()
  {
    return this->relative_y_;
  }

  void caesura::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void caesura::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void caesura::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const caesura::font_family_optional& caesura::
  font_family () const
  {
    return this->font_family_;
  }

  caesura::font_family_optional& caesura::
  font_family ()
  {
    return this->font_family_;
  }

  void caesura::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void caesura::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void caesura::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const caesura::font_style_optional& caesura::
  font_style () const
  {
    return this->font_style_;
  }

  caesura::font_style_optional& caesura::
  font_style ()
  {
    return this->font_style_;
  }

  void caesura::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void caesura::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void caesura::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const caesura::font_size_optional& caesura::
  font_size () const
  {
    return this->font_size_;
  }

  caesura::font_size_optional& caesura::
  font_size ()
  {
    return this->font_size_;
  }

  void caesura::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void caesura::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void caesura::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const caesura::font_weight_optional& caesura::
  font_weight () const
  {
    return this->font_weight_;
  }

  caesura::font_weight_optional& caesura::
  font_weight ()
  {
    return this->font_weight_;
  }

  void caesura::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void caesura::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void caesura::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const caesura::color_optional& caesura::
  color () const
  {
    return this->color_;
  }

  caesura::color_optional& caesura::
  color ()
  {
    return this->color_;
  }

  void caesura::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void caesura::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void caesura::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const caesura::placement_optional& caesura::
  placement () const
  {
    return this->placement_;
  }

  caesura::placement_optional& caesura::
  placement ()
  {
    return this->placement_;
  }

  void caesura::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void caesura::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void caesura::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // elision
  // 

  const elision::font_family_optional& elision::
  font_family () const
  {
    return this->font_family_;
  }

  elision::font_family_optional& elision::
  font_family ()
  {
    return this->font_family_;
  }

  void elision::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void elision::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void elision::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const elision::font_style_optional& elision::
  font_style () const
  {
    return this->font_style_;
  }

  elision::font_style_optional& elision::
  font_style ()
  {
    return this->font_style_;
  }

  void elision::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void elision::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void elision::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const elision::font_size_optional& elision::
  font_size () const
  {
    return this->font_size_;
  }

  elision::font_size_optional& elision::
  font_size ()
  {
    return this->font_size_;
  }

  void elision::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void elision::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void elision::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const elision::font_weight_optional& elision::
  font_weight () const
  {
    return this->font_weight_;
  }

  elision::font_weight_optional& elision::
  font_weight ()
  {
    return this->font_weight_;
  }

  void elision::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void elision::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void elision::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const elision::color_optional& elision::
  color () const
  {
    return this->color_;
  }

  elision::color_optional& elision::
  color ()
  {
    return this->color_;
  }

  void elision::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void elision::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void elision::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const elision::smufl_optional& elision::
  smufl () const
  {
    return this->smufl_;
  }

  elision::smufl_optional& elision::
  smufl ()
  {
    return this->smufl_;
  }

  void elision::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void elision::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void elision::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // empty_line
  // 

  const empty_line::line_shape_optional& empty_line::
  line_shape () const
  {
    return this->line_shape_;
  }

  empty_line::line_shape_optional& empty_line::
  line_shape ()
  {
    return this->line_shape_;
  }

  void empty_line::
  line_shape (const line_shape_type& x)
  {
    this->line_shape_.set (x);
  }

  void empty_line::
  line_shape (const line_shape_optional& x)
  {
    this->line_shape_ = x;
  }

  void empty_line::
  line_shape (::std::unique_ptr< line_shape_type > x)
  {
    this->line_shape_.set (std::move (x));
  }

  const empty_line::line_type_optional& empty_line::
  line_type () const
  {
    return this->line_type_;
  }

  empty_line::line_type_optional& empty_line::
  line_type ()
  {
    return this->line_type_;
  }

  void empty_line::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void empty_line::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void empty_line::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const empty_line::line_length_optional& empty_line::
  line_length () const
  {
    return this->line_length_;
  }

  empty_line::line_length_optional& empty_line::
  line_length ()
  {
    return this->line_length_;
  }

  void empty_line::
  line_length (const line_length_type& x)
  {
    this->line_length_.set (x);
  }

  void empty_line::
  line_length (const line_length_optional& x)
  {
    this->line_length_ = x;
  }

  void empty_line::
  line_length (::std::unique_ptr< line_length_type > x)
  {
    this->line_length_.set (std::move (x));
  }

  const empty_line::dash_length_optional& empty_line::
  dash_length () const
  {
    return this->dash_length_;
  }

  empty_line::dash_length_optional& empty_line::
  dash_length ()
  {
    return this->dash_length_;
  }

  void empty_line::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void empty_line::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void empty_line::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const empty_line::space_length_optional& empty_line::
  space_length () const
  {
    return this->space_length_;
  }

  empty_line::space_length_optional& empty_line::
  space_length ()
  {
    return this->space_length_;
  }

  void empty_line::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void empty_line::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void empty_line::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const empty_line::default_x_optional& empty_line::
  default_x () const
  {
    return this->default_x_;
  }

  empty_line::default_x_optional& empty_line::
  default_x ()
  {
    return this->default_x_;
  }

  void empty_line::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void empty_line::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void empty_line::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const empty_line::default_y_optional& empty_line::
  default_y () const
  {
    return this->default_y_;
  }

  empty_line::default_y_optional& empty_line::
  default_y ()
  {
    return this->default_y_;
  }

  void empty_line::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void empty_line::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void empty_line::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const empty_line::relative_x_optional& empty_line::
  relative_x () const
  {
    return this->relative_x_;
  }

  empty_line::relative_x_optional& empty_line::
  relative_x ()
  {
    return this->relative_x_;
  }

  void empty_line::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void empty_line::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void empty_line::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const empty_line::relative_y_optional& empty_line::
  relative_y () const
  {
    return this->relative_y_;
  }

  empty_line::relative_y_optional& empty_line::
  relative_y ()
  {
    return this->relative_y_;
  }

  void empty_line::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void empty_line::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void empty_line::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const empty_line::font_family_optional& empty_line::
  font_family () const
  {
    return this->font_family_;
  }

  empty_line::font_family_optional& empty_line::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_line::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_line::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_line::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_line::font_style_optional& empty_line::
  font_style () const
  {
    return this->font_style_;
  }

  empty_line::font_style_optional& empty_line::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_line::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_line::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_line::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_line::font_size_optional& empty_line::
  font_size () const
  {
    return this->font_size_;
  }

  empty_line::font_size_optional& empty_line::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_line::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_line::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_line::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_line::font_weight_optional& empty_line::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_line::font_weight_optional& empty_line::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_line::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_line::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_line::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const empty_line::color_optional& empty_line::
  color () const
  {
    return this->color_;
  }

  empty_line::color_optional& empty_line::
  color ()
  {
    return this->color_;
  }

  void empty_line::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void empty_line::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void empty_line::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const empty_line::placement_optional& empty_line::
  placement () const
  {
    return this->placement_;
  }

  empty_line::placement_optional& empty_line::
  placement ()
  {
    return this->placement_;
  }

  void empty_line::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void empty_line::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void empty_line::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // extend
  // 

  const extend::type_optional& extend::
  type () const
  {
    return this->type_;
  }

  extend::type_optional& extend::
  type ()
  {
    return this->type_;
  }

  void extend::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void extend::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void extend::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const extend::default_x_optional& extend::
  default_x () const
  {
    return this->default_x_;
  }

  extend::default_x_optional& extend::
  default_x ()
  {
    return this->default_x_;
  }

  void extend::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void extend::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void extend::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const extend::default_y_optional& extend::
  default_y () const
  {
    return this->default_y_;
  }

  extend::default_y_optional& extend::
  default_y ()
  {
    return this->default_y_;
  }

  void extend::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void extend::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void extend::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const extend::relative_x_optional& extend::
  relative_x () const
  {
    return this->relative_x_;
  }

  extend::relative_x_optional& extend::
  relative_x ()
  {
    return this->relative_x_;
  }

  void extend::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void extend::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void extend::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const extend::relative_y_optional& extend::
  relative_y () const
  {
    return this->relative_y_;
  }

  extend::relative_y_optional& extend::
  relative_y ()
  {
    return this->relative_y_;
  }

  void extend::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void extend::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void extend::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const extend::color_optional& extend::
  color () const
  {
    return this->color_;
  }

  extend::color_optional& extend::
  color ()
  {
    return this->color_;
  }

  void extend::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void extend::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void extend::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // figure
  // 

  const figure::prefix_optional& figure::
  prefix () const
  {
    return this->prefix_;
  }

  figure::prefix_optional& figure::
  prefix ()
  {
    return this->prefix_;
  }

  void figure::
  prefix (const prefix_type& x)
  {
    this->prefix_.set (x);
  }

  void figure::
  prefix (const prefix_optional& x)
  {
    this->prefix_ = x;
  }

  void figure::
  prefix (::std::unique_ptr< prefix_type > x)
  {
    this->prefix_.set (std::move (x));
  }

  const figure::figure_number_optional& figure::
  figure_number () const
  {
    return this->figure_number_;
  }

  figure::figure_number_optional& figure::
  figure_number ()
  {
    return this->figure_number_;
  }

  void figure::
  figure_number (const figure_number_type& x)
  {
    this->figure_number_.set (x);
  }

  void figure::
  figure_number (const figure_number_optional& x)
  {
    this->figure_number_ = x;
  }

  void figure::
  figure_number (::std::unique_ptr< figure_number_type > x)
  {
    this->figure_number_.set (std::move (x));
  }

  const figure::suffix_optional& figure::
  suffix () const
  {
    return this->suffix_;
  }

  figure::suffix_optional& figure::
  suffix ()
  {
    return this->suffix_;
  }

  void figure::
  suffix (const suffix_type& x)
  {
    this->suffix_.set (x);
  }

  void figure::
  suffix (const suffix_optional& x)
  {
    this->suffix_ = x;
  }

  void figure::
  suffix (::std::unique_ptr< suffix_type > x)
  {
    this->suffix_.set (std::move (x));
  }

  const figure::extend_optional& figure::
  extend () const
  {
    return this->extend_;
  }

  figure::extend_optional& figure::
  extend ()
  {
    return this->extend_;
  }

  void figure::
  extend (const extend_type& x)
  {
    this->extend_.set (x);
  }

  void figure::
  extend (const extend_optional& x)
  {
    this->extend_ = x;
  }

  void figure::
  extend (::std::unique_ptr< extend_type > x)
  {
    this->extend_.set (std::move (x));
  }

  const figure::footnote_optional& figure::
  footnote () const
  {
    return this->footnote_;
  }

  figure::footnote_optional& figure::
  footnote ()
  {
    return this->footnote_;
  }

  void figure::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void figure::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void figure::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const figure::level_optional& figure::
  level () const
  {
    return this->level_;
  }

  figure::level_optional& figure::
  level ()
  {
    return this->level_;
  }

  void figure::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void figure::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void figure::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }


  // figured_bass
  // 

  const figured_bass::figure_sequence& figured_bass::
  figure () const
  {
    return this->figure_;
  }

  figured_bass::figure_sequence& figured_bass::
  figure ()
  {
    return this->figure_;
  }

  void figured_bass::
  figure (const figure_sequence& s)
  {
    this->figure_ = s;
  }

  const figured_bass::duration_optional& figured_bass::
  duration () const
  {
    return this->duration_;
  }

  figured_bass::duration_optional& figured_bass::
  duration ()
  {
    return this->duration_;
  }

  void figured_bass::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void figured_bass::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void figured_bass::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const figured_bass::footnote_optional& figured_bass::
  footnote () const
  {
    return this->footnote_;
  }

  figured_bass::footnote_optional& figured_bass::
  footnote ()
  {
    return this->footnote_;
  }

  void figured_bass::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void figured_bass::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void figured_bass::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const figured_bass::level_optional& figured_bass::
  level () const
  {
    return this->level_;
  }

  figured_bass::level_optional& figured_bass::
  level ()
  {
    return this->level_;
  }

  void figured_bass::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void figured_bass::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void figured_bass::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const figured_bass::default_x_optional& figured_bass::
  default_x () const
  {
    return this->default_x_;
  }

  figured_bass::default_x_optional& figured_bass::
  default_x ()
  {
    return this->default_x_;
  }

  void figured_bass::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void figured_bass::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void figured_bass::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const figured_bass::default_y_optional& figured_bass::
  default_y () const
  {
    return this->default_y_;
  }

  figured_bass::default_y_optional& figured_bass::
  default_y ()
  {
    return this->default_y_;
  }

  void figured_bass::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void figured_bass::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void figured_bass::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const figured_bass::relative_x_optional& figured_bass::
  relative_x () const
  {
    return this->relative_x_;
  }

  figured_bass::relative_x_optional& figured_bass::
  relative_x ()
  {
    return this->relative_x_;
  }

  void figured_bass::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void figured_bass::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void figured_bass::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const figured_bass::relative_y_optional& figured_bass::
  relative_y () const
  {
    return this->relative_y_;
  }

  figured_bass::relative_y_optional& figured_bass::
  relative_y ()
  {
    return this->relative_y_;
  }

  void figured_bass::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void figured_bass::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void figured_bass::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const figured_bass::font_family_optional& figured_bass::
  font_family () const
  {
    return this->font_family_;
  }

  figured_bass::font_family_optional& figured_bass::
  font_family ()
  {
    return this->font_family_;
  }

  void figured_bass::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void figured_bass::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void figured_bass::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const figured_bass::font_style_optional& figured_bass::
  font_style () const
  {
    return this->font_style_;
  }

  figured_bass::font_style_optional& figured_bass::
  font_style ()
  {
    return this->font_style_;
  }

  void figured_bass::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void figured_bass::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void figured_bass::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const figured_bass::font_size_optional& figured_bass::
  font_size () const
  {
    return this->font_size_;
  }

  figured_bass::font_size_optional& figured_bass::
  font_size ()
  {
    return this->font_size_;
  }

  void figured_bass::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void figured_bass::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void figured_bass::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const figured_bass::font_weight_optional& figured_bass::
  font_weight () const
  {
    return this->font_weight_;
  }

  figured_bass::font_weight_optional& figured_bass::
  font_weight ()
  {
    return this->font_weight_;
  }

  void figured_bass::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void figured_bass::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void figured_bass::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const figured_bass::color_optional& figured_bass::
  color () const
  {
    return this->color_;
  }

  figured_bass::color_optional& figured_bass::
  color ()
  {
    return this->color_;
  }

  void figured_bass::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void figured_bass::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void figured_bass::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const figured_bass::halign_optional& figured_bass::
  halign () const
  {
    return this->halign_;
  }

  figured_bass::halign_optional& figured_bass::
  halign ()
  {
    return this->halign_;
  }

  void figured_bass::
  halign (const halign_type& x)
  {
    this->halign_.set (x);
  }

  void figured_bass::
  halign (const halign_optional& x)
  {
    this->halign_ = x;
  }

  void figured_bass::
  halign (::std::unique_ptr< halign_type > x)
  {
    this->halign_.set (std::move (x));
  }

  const figured_bass::valign_optional& figured_bass::
  valign () const
  {
    return this->valign_;
  }

  figured_bass::valign_optional& figured_bass::
  valign ()
  {
    return this->valign_;
  }

  void figured_bass::
  valign (const valign_type& x)
  {
    this->valign_.set (x);
  }

  void figured_bass::
  valign (const valign_optional& x)
  {
    this->valign_ = x;
  }

  void figured_bass::
  valign (::std::unique_ptr< valign_type > x)
  {
    this->valign_.set (std::move (x));
  }

  const figured_bass::placement_optional& figured_bass::
  placement () const
  {
    return this->placement_;
  }

  figured_bass::placement_optional& figured_bass::
  placement ()
  {
    return this->placement_;
  }

  void figured_bass::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void figured_bass::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void figured_bass::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const figured_bass::print_object_optional& figured_bass::
  print_object () const
  {
    return this->print_object_;
  }

  figured_bass::print_object_optional& figured_bass::
  print_object ()
  {
    return this->print_object_;
  }

  void figured_bass::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void figured_bass::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void figured_bass::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const figured_bass::print_dot_optional& figured_bass::
  print_dot () const
  {
    return this->print_dot_;
  }

  figured_bass::print_dot_optional& figured_bass::
  print_dot ()
  {
    return this->print_dot_;
  }

  void figured_bass::
  print_dot (const print_dot_type& x)
  {
    this->print_dot_.set (x);
  }

  void figured_bass::
  print_dot (const print_dot_optional& x)
  {
    this->print_dot_ = x;
  }

  void figured_bass::
  print_dot (::std::unique_ptr< print_dot_type > x)
  {
    this->print_dot_.set (std::move (x));
  }

  const figured_bass::print_spacing_optional& figured_bass::
  print_spacing () const
  {
    return this->print_spacing_;
  }

  figured_bass::print_spacing_optional& figured_bass::
  print_spacing ()
  {
    return this->print_spacing_;
  }

  void figured_bass::
  print_spacing (const print_spacing_type& x)
  {
    this->print_spacing_.set (x);
  }

  void figured_bass::
  print_spacing (const print_spacing_optional& x)
  {
    this->print_spacing_ = x;
  }

  void figured_bass::
  print_spacing (::std::unique_ptr< print_spacing_type > x)
  {
    this->print_spacing_.set (std::move (x));
  }

  const figured_bass::print_lyric_optional& figured_bass::
  print_lyric () const
  {
    return this->print_lyric_;
  }

  figured_bass::print_lyric_optional& figured_bass::
  print_lyric ()
  {
    return this->print_lyric_;
  }

  void figured_bass::
  print_lyric (const print_lyric_type& x)
  {
    this->print_lyric_.set (x);
  }

  void figured_bass::
  print_lyric (const print_lyric_optional& x)
  {
    this->print_lyric_ = x;
  }

  void figured_bass::
  print_lyric (::std::unique_ptr< print_lyric_type > x)
  {
    this->print_lyric_.set (std::move (x));
  }

  const figured_bass::parentheses_optional& figured_bass::
  parentheses () const
  {
    return this->parentheses_;
  }

  figured_bass::parentheses_optional& figured_bass::
  parentheses ()
  {
    return this->parentheses_;
  }

  void figured_bass::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void figured_bass::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void figured_bass::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const figured_bass::id_optional& figured_bass::
  id () const
  {
    return this->id_;
  }

  figured_bass::id_optional& figured_bass::
  id ()
  {
    return this->id_;
  }

  void figured_bass::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void figured_bass::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void figured_bass::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // forward
  // 

  const forward::duration_type& forward::
  duration () const
  {
    return this->duration_.get ();
  }

  forward::duration_type& forward::
  duration ()
  {
    return this->duration_.get ();
  }

  void forward::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void forward::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const forward::footnote_optional& forward::
  footnote () const
  {
    return this->footnote_;
  }

  forward::footnote_optional& forward::
  footnote ()
  {
    return this->footnote_;
  }

  void forward::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void forward::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void forward::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const forward::level_optional& forward::
  level () const
  {
    return this->level_;
  }

  forward::level_optional& forward::
  level ()
  {
    return this->level_;
  }

  void forward::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void forward::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void forward::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const forward::voice_optional& forward::
  voice () const
  {
    return this->voice_;
  }

  forward::voice_optional& forward::
  voice ()
  {
    return this->voice_;
  }

  void forward::
  voice (const voice_type& x)
  {
    this->voice_.set (x);
  }

  void forward::
  voice (const voice_optional& x)
  {
    this->voice_ = x;
  }

  void forward::
  voice (::std::unique_ptr< voice_type > x)
  {
    this->voice_.set (std::move (x));
  }

  const forward::staff_optional& forward::
  staff () const
  {
    return this->staff_;
  }

  forward::staff_optional& forward::
  staff ()
  {
    return this->staff_;
  }

  void forward::
  staff (const staff_type& x)
  {
    this->staff_.set (x);
  }

  void forward::
  staff (const staff_optional& x)
  {
    this->staff_ = x;
  }


  // glissando
  // 

  const glissando::type_type& glissando::
  type () const
  {
    return this->type_.get ();
  }

  glissando::type_type& glissando::
  type ()
  {
    return this->type_.get ();
  }

  void glissando::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void glissando::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const glissando::number_type& glissando::
  number () const
  {
    return this->number_.get ();
  }

  glissando::number_type& glissando::
  number ()
  {
    return this->number_.get ();
  }

  void glissando::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void glissando::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  glissando::number_type glissando::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const glissando::line_type_optional& glissando::
  line_type () const
  {
    return this->line_type_;
  }

  glissando::line_type_optional& glissando::
  line_type ()
  {
    return this->line_type_;
  }

  void glissando::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void glissando::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void glissando::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const glissando::dash_length_optional& glissando::
  dash_length () const
  {
    return this->dash_length_;
  }

  glissando::dash_length_optional& glissando::
  dash_length ()
  {
    return this->dash_length_;
  }

  void glissando::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void glissando::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void glissando::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const glissando::space_length_optional& glissando::
  space_length () const
  {
    return this->space_length_;
  }

  glissando::space_length_optional& glissando::
  space_length ()
  {
    return this->space_length_;
  }

  void glissando::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void glissando::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void glissando::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const glissando::default_x_optional& glissando::
  default_x () const
  {
    return this->default_x_;
  }

  glissando::default_x_optional& glissando::
  default_x ()
  {
    return this->default_x_;
  }

  void glissando::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void glissando::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void glissando::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const glissando::default_y_optional& glissando::
  default_y () const
  {
    return this->default_y_;
  }

  glissando::default_y_optional& glissando::
  default_y ()
  {
    return this->default_y_;
  }

  void glissando::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void glissando::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void glissando::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const glissando::relative_x_optional& glissando::
  relative_x () const
  {
    return this->relative_x_;
  }

  glissando::relative_x_optional& glissando::
  relative_x ()
  {
    return this->relative_x_;
  }

  void glissando::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void glissando::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void glissando::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const glissando::relative_y_optional& glissando::
  relative_y () const
  {
    return this->relative_y_;
  }

  glissando::relative_y_optional& glissando::
  relative_y ()
  {
    return this->relative_y_;
  }

  void glissando::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void glissando::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void glissando::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const glissando::font_family_optional& glissando::
  font_family () const
  {
    return this->font_family_;
  }

  glissando::font_family_optional& glissando::
  font_family ()
  {
    return this->font_family_;
  }

  void glissando::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void glissando::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void glissando::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const glissando::font_style_optional& glissando::
  font_style () const
  {
    return this->font_style_;
  }

  glissando::font_style_optional& glissando::
  font_style ()
  {
    return this->font_style_;
  }

  void glissando::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void glissando::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void glissando::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const glissando::font_size_optional& glissando::
  font_size () const
  {
    return this->font_size_;
  }

  glissando::font_size_optional& glissando::
  font_size ()
  {
    return this->font_size_;
  }

  void glissando::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void glissando::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void glissando::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const glissando::font_weight_optional& glissando::
  font_weight () const
  {
    return this->font_weight_;
  }

  glissando::font_weight_optional& glissando::
  font_weight ()
  {
    return this->font_weight_;
  }

  void glissando::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void glissando::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void glissando::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const glissando::color_optional& glissando::
  color () const
  {
    return this->color_;
  }

  glissando::color_optional& glissando::
  color ()
  {
    return this->color_;
  }

  void glissando::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void glissando::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void glissando::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const glissando::id_optional& glissando::
  id () const
  {
    return this->id_;
  }

  glissando::id_optional& glissando::
  id ()
  {
    return this->id_;
  }

  void glissando::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void glissando::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void glissando::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // grace
  // 

  const grace::steal_time_previous_optional& grace::
  steal_time_previous () const
  {
    return this->steal_time_previous_;
  }

  grace::steal_time_previous_optional& grace::
  steal_time_previous ()
  {
    return this->steal_time_previous_;
  }

  void grace::
  steal_time_previous (const steal_time_previous_type& x)
  {
    this->steal_time_previous_.set (x);
  }

  void grace::
  steal_time_previous (const steal_time_previous_optional& x)
  {
    this->steal_time_previous_ = x;
  }

  void grace::
  steal_time_previous (::std::unique_ptr< steal_time_previous_type > x)
  {
    this->steal_time_previous_.set (std::move (x));
  }

  const grace::steal_time_following_optional& grace::
  steal_time_following () const
  {
    return this->steal_time_following_;
  }

  grace::steal_time_following_optional& grace::
  steal_time_following ()
  {
    return this->steal_time_following_;
  }

  void grace::
  steal_time_following (const steal_time_following_type& x)
  {
    this->steal_time_following_.set (x);
  }

  void grace::
  steal_time_following (const steal_time_following_optional& x)
  {
    this->steal_time_following_ = x;
  }

  void grace::
  steal_time_following (::std::unique_ptr< steal_time_following_type > x)
  {
    this->steal_time_following_.set (std::move (x));
  }

  const grace::make_time_optional& grace::
  make_time () const
  {
    return this->make_time_;
  }

  grace::make_time_optional& grace::
  make_time ()
  {
    return this->make_time_;
  }

  void grace::
  make_time (const make_time_type& x)
  {
    this->make_time_.set (x);
  }

  void grace::
  make_time (const make_time_optional& x)
  {
    this->make_time_ = x;
  }

  void grace::
  make_time (::std::unique_ptr< make_time_type > x)
  {
    this->make_time_.set (std::move (x));
  }

  const grace::slash_optional& grace::
  slash () const
  {
    return this->slash_;
  }

  grace::slash_optional& grace::
  slash ()
  {
    return this->slash_;
  }

  void grace::
  slash (const slash_type& x)
  {
    this->slash_.set (x);
  }

  void grace::
  slash (const slash_optional& x)
  {
    this->slash_ = x;
  }

  void grace::
  slash (::std::unique_ptr< slash_type > x)
  {
    this->slash_.set (std::move (x));
  }


  // hammer_on_pull_off
  // 

  const hammer_on_pull_off::type_type& hammer_on_pull_off::
  type () const
  {
    return this->type_.get ();
  }

  hammer_on_pull_off::type_type& hammer_on_pull_off::
  type ()
  {
    return this->type_.get ();
  }

  void hammer_on_pull_off::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void hammer_on_pull_off::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const hammer_on_pull_off::number_type& hammer_on_pull_off::
  number () const
  {
    return this->number_.get ();
  }

  hammer_on_pull_off::number_type& hammer_on_pull_off::
  number ()
  {
    return this->number_.get ();
  }

  void hammer_on_pull_off::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void hammer_on_pull_off::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  hammer_on_pull_off::number_type hammer_on_pull_off::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const hammer_on_pull_off::default_x_optional& hammer_on_pull_off::
  default_x () const
  {
    return this->default_x_;
  }

  hammer_on_pull_off::default_x_optional& hammer_on_pull_off::
  default_x ()
  {
    return this->default_x_;
  }

  void hammer_on_pull_off::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void hammer_on_pull_off::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void hammer_on_pull_off::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const hammer_on_pull_off::default_y_optional& hammer_on_pull_off::
  default_y () const
  {
    return this->default_y_;
  }

  hammer_on_pull_off::default_y_optional& hammer_on_pull_off::
  default_y ()
  {
    return this->default_y_;
  }

  void hammer_on_pull_off::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void hammer_on_pull_off::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void hammer_on_pull_off::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const hammer_on_pull_off::relative_x_optional& hammer_on_pull_off::
  relative_x () const
  {
    return this->relative_x_;
  }

  hammer_on_pull_off::relative_x_optional& hammer_on_pull_off::
  relative_x ()
  {
    return this->relative_x_;
  }

  void hammer_on_pull_off::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void hammer_on_pull_off::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void hammer_on_pull_off::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const hammer_on_pull_off::relative_y_optional& hammer_on_pull_off::
  relative_y () const
  {
    return this->relative_y_;
  }

  hammer_on_pull_off::relative_y_optional& hammer_on_pull_off::
  relative_y ()
  {
    return this->relative_y_;
  }

  void hammer_on_pull_off::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void hammer_on_pull_off::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void hammer_on_pull_off::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const hammer_on_pull_off::font_family_optional& hammer_on_pull_off::
  font_family () const
  {
    return this->font_family_;
  }

  hammer_on_pull_off::font_family_optional& hammer_on_pull_off::
  font_family ()
  {
    return this->font_family_;
  }

  void hammer_on_pull_off::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void hammer_on_pull_off::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void hammer_on_pull_off::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const hammer_on_pull_off::font_style_optional& hammer_on_pull_off::
  font_style () const
  {
    return this->font_style_;
  }

  hammer_on_pull_off::font_style_optional& hammer_on_pull_off::
  font_style ()
  {
    return this->font_style_;
  }

  void hammer_on_pull_off::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void hammer_on_pull_off::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void hammer_on_pull_off::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const hammer_on_pull_off::font_size_optional& hammer_on_pull_off::
  font_size () const
  {
    return this->font_size_;
  }

  hammer_on_pull_off::font_size_optional& hammer_on_pull_off::
  font_size ()
  {
    return this->font_size_;
  }

  void hammer_on_pull_off::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void hammer_on_pull_off::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void hammer_on_pull_off::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const hammer_on_pull_off::font_weight_optional& hammer_on_pull_off::
  font_weight () const
  {
    return this->font_weight_;
  }

  hammer_on_pull_off::font_weight_optional& hammer_on_pull_off::
  font_weight ()
  {
    return this->font_weight_;
  }

  void hammer_on_pull_off::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void hammer_on_pull_off::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void hammer_on_pull_off::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const hammer_on_pull_off::color_optional& hammer_on_pull_off::
  color () const
  {
    return this->color_;
  }

  hammer_on_pull_off::color_optional& hammer_on_pull_off::
  color ()
  {
    return this->color_;
  }

  void hammer_on_pull_off::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void hammer_on_pull_off::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void hammer_on_pull_off::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const hammer_on_pull_off::placement_optional& hammer_on_pull_off::
  placement () const
  {
    return this->placement_;
  }

  hammer_on_pull_off::placement_optional& hammer_on_pull_off::
  placement ()
  {
    return this->placement_;
  }

  void hammer_on_pull_off::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void hammer_on_pull_off::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void hammer_on_pull_off::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // handbell
  // 

  const handbell::default_x_optional& handbell::
  default_x () const
  {
    return this->default_x_;
  }

  handbell::default_x_optional& handbell::
  default_x ()
  {
    return this->default_x_;
  }

  void handbell::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void handbell::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void handbell::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const handbell::default_y_optional& handbell::
  default_y () const
  {
    return this->default_y_;
  }

  handbell::default_y_optional& handbell::
  default_y ()
  {
    return this->default_y_;
  }

  void handbell::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void handbell::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void handbell::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const handbell::relative_x_optional& handbell::
  relative_x () const
  {
    return this->relative_x_;
  }

  handbell::relative_x_optional& handbell::
  relative_x ()
  {
    return this->relative_x_;
  }

  void handbell::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void handbell::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void handbell::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const handbell::relative_y_optional& handbell::
  relative_y () const
  {
    return this->relative_y_;
  }

  handbell::relative_y_optional& handbell::
  relative_y ()
  {
    return this->relative_y_;
  }

  void handbell::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void handbell::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void handbell::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const handbell::font_family_optional& handbell::
  font_family () const
  {
    return this->font_family_;
  }

  handbell::font_family_optional& handbell::
  font_family ()
  {
    return this->font_family_;
  }

  void handbell::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void handbell::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void handbell::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const handbell::font_style_optional& handbell::
  font_style () const
  {
    return this->font_style_;
  }

  handbell::font_style_optional& handbell::
  font_style ()
  {
    return this->font_style_;
  }

  void handbell::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void handbell::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void handbell::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const handbell::font_size_optional& handbell::
  font_size () const
  {
    return this->font_size_;
  }

  handbell::font_size_optional& handbell::
  font_size ()
  {
    return this->font_size_;
  }

  void handbell::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void handbell::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void handbell::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const handbell::font_weight_optional& handbell::
  font_weight () const
  {
    return this->font_weight_;
  }

  handbell::font_weight_optional& handbell::
  font_weight ()
  {
    return this->font_weight_;
  }

  void handbell::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void handbell::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void handbell::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const handbell::color_optional& handbell::
  color () const
  {
    return this->color_;
  }

  handbell::color_optional& handbell::
  color ()
  {
    return this->color_;
  }

  void handbell::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void handbell::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void handbell::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const handbell::placement_optional& handbell::
  placement () const
  {
    return this->placement_;
  }

  handbell::placement_optional& handbell::
  placement ()
  {
    return this->placement_;
  }

  void handbell::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void handbell::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void handbell::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // harmon_closed
  // 

  const harmon_closed::location_optional& harmon_closed::
  location () const
  {
    return this->location_;
  }

  harmon_closed::location_optional& harmon_closed::
  location ()
  {
    return this->location_;
  }

  void harmon_closed::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void harmon_closed::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void harmon_closed::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // harmon_mute
  // 

  const harmon_mute::harmon_closed_type& harmon_mute::
  harmon_closed () const
  {
    return this->harmon_closed_.get ();
  }

  harmon_mute::harmon_closed_type& harmon_mute::
  harmon_closed ()
  {
    return this->harmon_closed_.get ();
  }

  void harmon_mute::
  harmon_closed (const harmon_closed_type& x)
  {
    this->harmon_closed_.set (x);
  }

  void harmon_mute::
  harmon_closed (::std::unique_ptr< harmon_closed_type > x)
  {
    this->harmon_closed_.set (std::move (x));
  }

  const harmon_mute::default_x_optional& harmon_mute::
  default_x () const
  {
    return this->default_x_;
  }

  harmon_mute::default_x_optional& harmon_mute::
  default_x ()
  {
    return this->default_x_;
  }

  void harmon_mute::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void harmon_mute::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void harmon_mute::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const harmon_mute::default_y_optional& harmon_mute::
  default_y () const
  {
    return this->default_y_;
  }

  harmon_mute::default_y_optional& harmon_mute::
  default_y ()
  {
    return this->default_y_;
  }

  void harmon_mute::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void harmon_mute::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void harmon_mute::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const harmon_mute::relative_x_optional& harmon_mute::
  relative_x () const
  {
    return this->relative_x_;
  }

  harmon_mute::relative_x_optional& harmon_mute::
  relative_x ()
  {
    return this->relative_x_;
  }

  void harmon_mute::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void harmon_mute::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void harmon_mute::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const harmon_mute::relative_y_optional& harmon_mute::
  relative_y () const
  {
    return this->relative_y_;
  }

  harmon_mute::relative_y_optional& harmon_mute::
  relative_y ()
  {
    return this->relative_y_;
  }

  void harmon_mute::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void harmon_mute::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void harmon_mute::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const harmon_mute::font_family_optional& harmon_mute::
  font_family () const
  {
    return this->font_family_;
  }

  harmon_mute::font_family_optional& harmon_mute::
  font_family ()
  {
    return this->font_family_;
  }

  void harmon_mute::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void harmon_mute::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void harmon_mute::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const harmon_mute::font_style_optional& harmon_mute::
  font_style () const
  {
    return this->font_style_;
  }

  harmon_mute::font_style_optional& harmon_mute::
  font_style ()
  {
    return this->font_style_;
  }

  void harmon_mute::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void harmon_mute::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void harmon_mute::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const harmon_mute::font_size_optional& harmon_mute::
  font_size () const
  {
    return this->font_size_;
  }

  harmon_mute::font_size_optional& harmon_mute::
  font_size ()
  {
    return this->font_size_;
  }

  void harmon_mute::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void harmon_mute::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void harmon_mute::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const harmon_mute::font_weight_optional& harmon_mute::
  font_weight () const
  {
    return this->font_weight_;
  }

  harmon_mute::font_weight_optional& harmon_mute::
  font_weight ()
  {
    return this->font_weight_;
  }

  void harmon_mute::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void harmon_mute::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void harmon_mute::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const harmon_mute::color_optional& harmon_mute::
  color () const
  {
    return this->color_;
  }

  harmon_mute::color_optional& harmon_mute::
  color ()
  {
    return this->color_;
  }

  void harmon_mute::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void harmon_mute::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void harmon_mute::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const harmon_mute::placement_optional& harmon_mute::
  placement () const
  {
    return this->placement_;
  }

  harmon_mute::placement_optional& harmon_mute::
  placement ()
  {
    return this->placement_;
  }

  void harmon_mute::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void harmon_mute::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void harmon_mute::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // harmonic
  // 

  const harmonic::natural_optional& harmonic::
  natural () const
  {
    return this->natural_;
  }

  harmonic::natural_optional& harmonic::
  natural ()
  {
    return this->natural_;
  }

  void harmonic::
  natural (const natural_type& x)
  {
    this->natural_.set (x);
  }

  void harmonic::
  natural (const natural_optional& x)
  {
    this->natural_ = x;
  }

  void harmonic::
  natural (::std::unique_ptr< natural_type > x)
  {
    this->natural_.set (std::move (x));
  }

  const harmonic::artificial_optional& harmonic::
  artificial () const
  {
    return this->artificial_;
  }

  harmonic::artificial_optional& harmonic::
  artificial ()
  {
    return this->artificial_;
  }

  void harmonic::
  artificial (const artificial_type& x)
  {
    this->artificial_.set (x);
  }

  void harmonic::
  artificial (const artificial_optional& x)
  {
    this->artificial_ = x;
  }

  void harmonic::
  artificial (::std::unique_ptr< artificial_type > x)
  {
    this->artificial_.set (std::move (x));
  }

  const harmonic::base_pitch_optional& harmonic::
  base_pitch () const
  {
    return this->base_pitch_;
  }

  harmonic::base_pitch_optional& harmonic::
  base_pitch ()
  {
    return this->base_pitch_;
  }

  void harmonic::
  base_pitch (const base_pitch_type& x)
  {
    this->base_pitch_.set (x);
  }

  void harmonic::
  base_pitch (const base_pitch_optional& x)
  {
    this->base_pitch_ = x;
  }

  void harmonic::
  base_pitch (::std::unique_ptr< base_pitch_type > x)
  {
    this->base_pitch_.set (std::move (x));
  }

  const harmonic::touching_pitch_optional& harmonic::
  touching_pitch () const
  {
    return this->touching_pitch_;
  }

  harmonic::touching_pitch_optional& harmonic::
  touching_pitch ()
  {
    return this->touching_pitch_;
  }

  void harmonic::
  touching_pitch (const touching_pitch_type& x)
  {
    this->touching_pitch_.set (x);
  }

  void harmonic::
  touching_pitch (const touching_pitch_optional& x)
  {
    this->touching_pitch_ = x;
  }

  void harmonic::
  touching_pitch (::std::unique_ptr< touching_pitch_type > x)
  {
    this->touching_pitch_.set (std::move (x));
  }

  const harmonic::sounding_pitch_optional& harmonic::
  sounding_pitch () const
  {
    return this->sounding_pitch_;
  }

  harmonic::sounding_pitch_optional& harmonic::
  sounding_pitch ()
  {
    return this->sounding_pitch_;
  }

  void harmonic::
  sounding_pitch (const sounding_pitch_type& x)
  {
    this->sounding_pitch_.set (x);
  }

  void harmonic::
  sounding_pitch (const sounding_pitch_optional& x)
  {
    this->sounding_pitch_ = x;
  }

  void harmonic::
  sounding_pitch (::std::unique_ptr< sounding_pitch_type > x)
  {
    this->sounding_pitch_.set (std::move (x));
  }

  const harmonic::print_object_optional& harmonic::
  print_object () const
  {
    return this->print_object_;
  }

  harmonic::print_object_optional& harmonic::
  print_object ()
  {
    return this->print_object_;
  }

  void harmonic::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void harmonic::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void harmonic::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const harmonic::default_x_optional& harmonic::
  default_x () const
  {
    return this->default_x_;
  }

  harmonic::default_x_optional& harmonic::
  default_x ()
  {
    return this->default_x_;
  }

  void harmonic::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void harmonic::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void harmonic::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const harmonic::default_y_optional& harmonic::
  default_y () const
  {
    return this->default_y_;
  }

  harmonic::default_y_optional& harmonic::
  default_y ()
  {
    return this->default_y_;
  }

  void harmonic::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void harmonic::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void harmonic::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const harmonic::relative_x_optional& harmonic::
  relative_x () const
  {
    return this->relative_x_;
  }

  harmonic::relative_x_optional& harmonic::
  relative_x ()
  {
    return this->relative_x_;
  }

  void harmonic::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void harmonic::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void harmonic::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const harmonic::relative_y_optional& harmonic::
  relative_y () const
  {
    return this->relative_y_;
  }

  harmonic::relative_y_optional& harmonic::
  relative_y ()
  {
    return this->relative_y_;
  }

  void harmonic::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void harmonic::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void harmonic::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const harmonic::font_family_optional& harmonic::
  font_family () const
  {
    return this->font_family_;
  }

  harmonic::font_family_optional& harmonic::
  font_family ()
  {
    return this->font_family_;
  }

  void harmonic::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void harmonic::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void harmonic::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const harmonic::font_style_optional& harmonic::
  font_style () const
  {
    return this->font_style_;
  }

  harmonic::font_style_optional& harmonic::
  font_style ()
  {
    return this->font_style_;
  }

  void harmonic::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void harmonic::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void harmonic::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const harmonic::font_size_optional& harmonic::
  font_size () const
  {
    return this->font_size_;
  }

  harmonic::font_size_optional& harmonic::
  font_size ()
  {
    return this->font_size_;
  }

  void harmonic::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void harmonic::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void harmonic::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const harmonic::font_weight_optional& harmonic::
  font_weight () const
  {
    return this->font_weight_;
  }

  harmonic::font_weight_optional& harmonic::
  font_weight ()
  {
    return this->font_weight_;
  }

  void harmonic::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void harmonic::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void harmonic::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const harmonic::color_optional& harmonic::
  color () const
  {
    return this->color_;
  }

  harmonic::color_optional& harmonic::
  color ()
  {
    return this->color_;
  }

  void harmonic::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void harmonic::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void harmonic::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const harmonic::placement_optional& harmonic::
  placement () const
  {
    return this->placement_;
  }

  harmonic::placement_optional& harmonic::
  placement ()
  {
    return this->placement_;
  }

  void harmonic::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void harmonic::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void harmonic::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // heel_toe
  // 

  const heel_toe::substitution_optional& heel_toe::
  substitution () const
  {
    return this->substitution_;
  }

  heel_toe::substitution_optional& heel_toe::
  substitution ()
  {
    return this->substitution_;
  }

  void heel_toe::
  substitution (const substitution_type& x)
  {
    this->substitution_.set (x);
  }

  void heel_toe::
  substitution (const substitution_optional& x)
  {
    this->substitution_ = x;
  }

  void heel_toe::
  substitution (::std::unique_ptr< substitution_type > x)
  {
    this->substitution_.set (std::move (x));
  }


  // hole
  // 

  const hole::hole_type_optional& hole::
  hole_type () const
  {
    return this->hole_type_;
  }

  hole::hole_type_optional& hole::
  hole_type ()
  {
    return this->hole_type_;
  }

  void hole::
  hole_type (const hole_type_type& x)
  {
    this->hole_type_.set (x);
  }

  void hole::
  hole_type (const hole_type_optional& x)
  {
    this->hole_type_ = x;
  }

  void hole::
  hole_type (::std::unique_ptr< hole_type_type > x)
  {
    this->hole_type_.set (std::move (x));
  }

  const hole::hole_closed_type& hole::
  hole_closed () const
  {
    return this->hole_closed_.get ();
  }

  hole::hole_closed_type& hole::
  hole_closed ()
  {
    return this->hole_closed_.get ();
  }

  void hole::
  hole_closed (const hole_closed_type& x)
  {
    this->hole_closed_.set (x);
  }

  void hole::
  hole_closed (::std::unique_ptr< hole_closed_type > x)
  {
    this->hole_closed_.set (std::move (x));
  }

  const hole::hole_shape_optional& hole::
  hole_shape () const
  {
    return this->hole_shape_;
  }

  hole::hole_shape_optional& hole::
  hole_shape ()
  {
    return this->hole_shape_;
  }

  void hole::
  hole_shape (const hole_shape_type& x)
  {
    this->hole_shape_.set (x);
  }

  void hole::
  hole_shape (const hole_shape_optional& x)
  {
    this->hole_shape_ = x;
  }

  void hole::
  hole_shape (::std::unique_ptr< hole_shape_type > x)
  {
    this->hole_shape_.set (std::move (x));
  }

  const hole::default_x_optional& hole::
  default_x () const
  {
    return this->default_x_;
  }

  hole::default_x_optional& hole::
  default_x ()
  {
    return this->default_x_;
  }

  void hole::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void hole::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void hole::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const hole::default_y_optional& hole::
  default_y () const
  {
    return this->default_y_;
  }

  hole::default_y_optional& hole::
  default_y ()
  {
    return this->default_y_;
  }

  void hole::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void hole::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void hole::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const hole::relative_x_optional& hole::
  relative_x () const
  {
    return this->relative_x_;
  }

  hole::relative_x_optional& hole::
  relative_x ()
  {
    return this->relative_x_;
  }

  void hole::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void hole::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void hole::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const hole::relative_y_optional& hole::
  relative_y () const
  {
    return this->relative_y_;
  }

  hole::relative_y_optional& hole::
  relative_y ()
  {
    return this->relative_y_;
  }

  void hole::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void hole::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void hole::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const hole::font_family_optional& hole::
  font_family () const
  {
    return this->font_family_;
  }

  hole::font_family_optional& hole::
  font_family ()
  {
    return this->font_family_;
  }

  void hole::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void hole::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void hole::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const hole::font_style_optional& hole::
  font_style () const
  {
    return this->font_style_;
  }

  hole::font_style_optional& hole::
  font_style ()
  {
    return this->font_style_;
  }

  void hole::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void hole::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void hole::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const hole::font_size_optional& hole::
  font_size () const
  {
    return this->font_size_;
  }

  hole::font_size_optional& hole::
  font_size ()
  {
    return this->font_size_;
  }

  void hole::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void hole::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void hole::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const hole::font_weight_optional& hole::
  font_weight () const
  {
    return this->font_weight_;
  }

  hole::font_weight_optional& hole::
  font_weight ()
  {
    return this->font_weight_;
  }

  void hole::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void hole::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void hole::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const hole::color_optional& hole::
  color () const
  {
    return this->color_;
  }

  hole::color_optional& hole::
  color ()
  {
    return this->color_;
  }

  void hole::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void hole::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void hole::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const hole::placement_optional& hole::
  placement () const
  {
    return this->placement_;
  }

  hole::placement_optional& hole::
  placement ()
  {
    return this->placement_;
  }

  void hole::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void hole::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void hole::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // hole_closed
  // 

  const hole_closed::location_optional& hole_closed::
  location () const
  {
    return this->location_;
  }

  hole_closed::location_optional& hole_closed::
  location ()
  {
    return this->location_;
  }

  void hole_closed::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void hole_closed::
  location (const location_optional& x)
  {
    this->location_ = x;
  }

  void hole_closed::
  location (::std::unique_ptr< location_type > x)
  {
    this->location_.set (std::move (x));
  }


  // instrument
  // 

  const instrument::id_type& instrument::
  id () const
  {
    return this->id_.get ();
  }

  instrument::id_type& instrument::
  id ()
  {
    return this->id_.get ();
  }

  void instrument::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void instrument::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // listen
  // 

  const listen::assess_sequence& listen::
  assess () const
  {
    return this->assess_;
  }

  listen::assess_sequence& listen::
  assess ()
  {
    return this->assess_;
  }

  void listen::
  assess (const assess_sequence& s)
  {
    this->assess_ = s;
  }

  const listen::wait_sequence& listen::
  wait () const
  {
    return this->wait_;
  }

  listen::wait_sequence& listen::
  wait ()
  {
    return this->wait_;
  }

  void listen::
  wait (const wait_sequence& s)
  {
    this->wait_ = s;
  }

  const listen::other_listen_sequence& listen::
  other_listen () const
  {
    return this->other_listen_;
  }

  listen::other_listen_sequence& listen::
  other_listen ()
  {
    return this->other_listen_;
  }

  void listen::
  other_listen (const other_listen_sequence& s)
  {
    this->other_listen_ = s;
  }


  // lyric
  // 

  const lyric::syllabic_sequence& lyric::
  syllabic () const
  {
    return this->syllabic_;
  }

  lyric::syllabic_sequence& lyric::
  syllabic ()
  {
    return this->syllabic_;
  }

  void lyric::
  syllabic (const syllabic_sequence& s)
  {
    this->syllabic_ = s;
  }

  const lyric::text_sequence& lyric::
  text () const
  {
    return this->text_;
  }

  lyric::text_sequence& lyric::
  text ()
  {
    return this->text_;
  }

  void lyric::
  text (const text_sequence& s)
  {
    this->text_ = s;
  }

  const lyric::elision_sequence& lyric::
  elision () const
  {
    return this->elision_;
  }

  lyric::elision_sequence& lyric::
  elision ()
  {
    return this->elision_;
  }

  void lyric::
  elision (const elision_sequence& s)
  {
    this->elision_ = s;
  }

  const lyric::extend_optional& lyric::
  extend () const
  {
    return this->extend_;
  }

  lyric::extend_optional& lyric::
  extend ()
  {
    return this->extend_;
  }

  void lyric::
  extend (const extend_type& x)
  {
    this->extend_.set (x);
  }

  void lyric::
  extend (const extend_optional& x)
  {
    this->extend_ = x;
  }

  void lyric::
  extend (::std::unique_ptr< extend_type > x)
  {
    this->extend_.set (std::move (x));
  }

  const lyric::laughing_optional& lyric::
  laughing () const
  {
    return this->laughing_;
  }

  lyric::laughing_optional& lyric::
  laughing ()
  {
    return this->laughing_;
  }

  void lyric::
  laughing (const laughing_type& x)
  {
    this->laughing_.set (x);
  }

  void lyric::
  laughing (const laughing_optional& x)
  {
    this->laughing_ = x;
  }

  void lyric::
  laughing (::std::unique_ptr< laughing_type > x)
  {
    this->laughing_.set (std::move (x));
  }

  const lyric::humming_optional& lyric::
  humming () const
  {
    return this->humming_;
  }

  lyric::humming_optional& lyric::
  humming ()
  {
    return this->humming_;
  }

  void lyric::
  humming (const humming_type& x)
  {
    this->humming_.set (x);
  }

  void lyric::
  humming (const humming_optional& x)
  {
    this->humming_ = x;
  }

  void lyric::
  humming (::std::unique_ptr< humming_type > x)
  {
    this->humming_.set (std::move (x));
  }

  const lyric::end_line_optional& lyric::
  end_line () const
  {
    return this->end_line_;
  }

  lyric::end_line_optional& lyric::
  end_line ()
  {
    return this->end_line_;
  }

  void lyric::
  end_line (const end_line_type& x)
  {
    this->end_line_.set (x);
  }

  void lyric::
  end_line (const end_line_optional& x)
  {
    this->end_line_ = x;
  }

  void lyric::
  end_line (::std::unique_ptr< end_line_type > x)
  {
    this->end_line_.set (std::move (x));
  }

  const lyric::end_paragraph_optional& lyric::
  end_paragraph () const
  {
    return this->end_paragraph_;
  }

  lyric::end_paragraph_optional& lyric::
  end_paragraph ()
  {
    return this->end_paragraph_;
  }

  void lyric::
  end_paragraph (const end_paragraph_type& x)
  {
    this->end_paragraph_.set (x);
  }

  void lyric::
  end_paragraph (const end_paragraph_optional& x)
  {
    this->end_paragraph_ = x;
  }

  void lyric::
  end_paragraph (::std::unique_ptr< end_paragraph_type > x)
  {
    this->end_paragraph_.set (std::move (x));
  }

  const lyric::footnote_optional& lyric::
  footnote () const
  {
    return this->footnote_;
  }

  lyric::footnote_optional& lyric::
  footnote ()
  {
    return this->footnote_;
  }

  void lyric::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void lyric::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void lyric::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const lyric::level_optional& lyric::
  level () const
  {
    return this->level_;
  }

  lyric::level_optional& lyric::
  level ()
  {
    return this->level_;
  }

  void lyric::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void lyric::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void lyric::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const lyric::number_optional& lyric::
  number () const
  {
    return this->number_;
  }

  lyric::number_optional& lyric::
  number ()
  {
    return this->number_;
  }

  void lyric::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void lyric::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void lyric::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const lyric::name_optional& lyric::
  name () const
  {
    return this->name_;
  }

  lyric::name_optional& lyric::
  name ()
  {
    return this->name_;
  }

  void lyric::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void lyric::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void lyric::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const lyric::justify_optional& lyric::
  justify () const
  {
    return this->justify_;
  }

  lyric::justify_optional& lyric::
  justify ()
  {
    return this->justify_;
  }

  void lyric::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void lyric::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void lyric::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }

  const lyric::default_x_optional& lyric::
  default_x () const
  {
    return this->default_x_;
  }

  lyric::default_x_optional& lyric::
  default_x ()
  {
    return this->default_x_;
  }

  void lyric::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void lyric::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void lyric::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const lyric::default_y_optional& lyric::
  default_y () const
  {
    return this->default_y_;
  }

  lyric::default_y_optional& lyric::
  default_y ()
  {
    return this->default_y_;
  }

  void lyric::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void lyric::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void lyric::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const lyric::relative_x_optional& lyric::
  relative_x () const
  {
    return this->relative_x_;
  }

  lyric::relative_x_optional& lyric::
  relative_x ()
  {
    return this->relative_x_;
  }

  void lyric::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void lyric::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void lyric::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const lyric::relative_y_optional& lyric::
  relative_y () const
  {
    return this->relative_y_;
  }

  lyric::relative_y_optional& lyric::
  relative_y ()
  {
    return this->relative_y_;
  }

  void lyric::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void lyric::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void lyric::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const lyric::placement_optional& lyric::
  placement () const
  {
    return this->placement_;
  }

  lyric::placement_optional& lyric::
  placement ()
  {
    return this->placement_;
  }

  void lyric::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void lyric::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void lyric::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const lyric::color_optional& lyric::
  color () const
  {
    return this->color_;
  }

  lyric::color_optional& lyric::
  color ()
  {
    return this->color_;
  }

  void lyric::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void lyric::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void lyric::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const lyric::print_object_optional& lyric::
  print_object () const
  {
    return this->print_object_;
  }

  lyric::print_object_optional& lyric::
  print_object ()
  {
    return this->print_object_;
  }

  void lyric::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void lyric::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void lyric::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const lyric::time_only_optional& lyric::
  time_only () const
  {
    return this->time_only_;
  }

  lyric::time_only_optional& lyric::
  time_only ()
  {
    return this->time_only_;
  }

  void lyric::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void lyric::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void lyric::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }

  const lyric::id_optional& lyric::
  id () const
  {
    return this->id_;
  }

  lyric::id_optional& lyric::
  id ()
  {
    return this->id_;
  }

  void lyric::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void lyric::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void lyric::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // mordent
  // 

  const mordent::long_optional& mordent::
  long_ () const
  {
    return this->long__;
  }

  mordent::long_optional& mordent::
  long_ ()
  {
    return this->long__;
  }

  void mordent::
  long_ (const long_type& x)
  {
    this->long__.set (x);
  }

  void mordent::
  long_ (const long_optional& x)
  {
    this->long__ = x;
  }

  void mordent::
  long_ (::std::unique_ptr< long_type > x)
  {
    this->long__.set (std::move (x));
  }

  const mordent::approach_optional& mordent::
  approach () const
  {
    return this->approach_;
  }

  mordent::approach_optional& mordent::
  approach ()
  {
    return this->approach_;
  }

  void mordent::
  approach (const approach_type& x)
  {
    this->approach_.set (x);
  }

  void mordent::
  approach (const approach_optional& x)
  {
    this->approach_ = x;
  }

  void mordent::
  approach (::std::unique_ptr< approach_type > x)
  {
    this->approach_.set (std::move (x));
  }

  const mordent::departure_optional& mordent::
  departure () const
  {
    return this->departure_;
  }

  mordent::departure_optional& mordent::
  departure ()
  {
    return this->departure_;
  }

  void mordent::
  departure (const departure_type& x)
  {
    this->departure_.set (x);
  }

  void mordent::
  departure (const departure_optional& x)
  {
    this->departure_ = x;
  }

  void mordent::
  departure (::std::unique_ptr< departure_type > x)
  {
    this->departure_.set (std::move (x));
  }


  // non_arpeggiate
  // 

  const non_arpeggiate::type_type& non_arpeggiate::
  type () const
  {
    return this->type_.get ();
  }

  non_arpeggiate::type_type& non_arpeggiate::
  type ()
  {
    return this->type_.get ();
  }

  void non_arpeggiate::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void non_arpeggiate::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const non_arpeggiate::number_optional& non_arpeggiate::
  number () const
  {
    return this->number_;
  }

  non_arpeggiate::number_optional& non_arpeggiate::
  number ()
  {
    return this->number_;
  }

  void non_arpeggiate::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void non_arpeggiate::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void non_arpeggiate::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const non_arpeggiate::default_x_optional& non_arpeggiate::
  default_x () const
  {
    return this->default_x_;
  }

  non_arpeggiate::default_x_optional& non_arpeggiate::
  default_x ()
  {
    return this->default_x_;
  }

  void non_arpeggiate::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void non_arpeggiate::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void non_arpeggiate::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const non_arpeggiate::default_y_optional& non_arpeggiate::
  default_y () const
  {
    return this->default_y_;
  }

  non_arpeggiate::default_y_optional& non_arpeggiate::
  default_y ()
  {
    return this->default_y_;
  }

  void non_arpeggiate::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void non_arpeggiate::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void non_arpeggiate::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const non_arpeggiate::relative_x_optional& non_arpeggiate::
  relative_x () const
  {
    return this->relative_x_;
  }

  non_arpeggiate::relative_x_optional& non_arpeggiate::
  relative_x ()
  {
    return this->relative_x_;
  }

  void non_arpeggiate::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void non_arpeggiate::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void non_arpeggiate::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const non_arpeggiate::relative_y_optional& non_arpeggiate::
  relative_y () const
  {
    return this->relative_y_;
  }

  non_arpeggiate::relative_y_optional& non_arpeggiate::
  relative_y ()
  {
    return this->relative_y_;
  }

  void non_arpeggiate::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void non_arpeggiate::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void non_arpeggiate::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const non_arpeggiate::placement_optional& non_arpeggiate::
  placement () const
  {
    return this->placement_;
  }

  non_arpeggiate::placement_optional& non_arpeggiate::
  placement ()
  {
    return this->placement_;
  }

  void non_arpeggiate::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void non_arpeggiate::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void non_arpeggiate::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const non_arpeggiate::color_optional& non_arpeggiate::
  color () const
  {
    return this->color_;
  }

  non_arpeggiate::color_optional& non_arpeggiate::
  color ()
  {
    return this->color_;
  }

  void non_arpeggiate::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void non_arpeggiate::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void non_arpeggiate::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const non_arpeggiate::id_optional& non_arpeggiate::
  id () const
  {
    return this->id_;
  }

  non_arpeggiate::id_optional& non_arpeggiate::
  id ()
  {
    return this->id_;
  }

  void non_arpeggiate::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void non_arpeggiate::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void non_arpeggiate::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // notations
  // 

  const notations::footnote_optional& notations::
  footnote () const
  {
    return this->footnote_;
  }

  notations::footnote_optional& notations::
  footnote ()
  {
    return this->footnote_;
  }

  void notations::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void notations::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void notations::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const notations::level_optional& notations::
  level () const
  {
    return this->level_;
  }

  notations::level_optional& notations::
  level ()
  {
    return this->level_;
  }

  void notations::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void notations::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void notations::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const notations::tied_sequence& notations::
  tied () const
  {
    return this->tied_;
  }

  notations::tied_sequence& notations::
  tied ()
  {
    return this->tied_;
  }

  void notations::
  tied (const tied_sequence& s)
  {
    this->tied_ = s;
  }

  const notations::slur_sequence& notations::
  slur () const
  {
    return this->slur_;
  }

  notations::slur_sequence& notations::
  slur ()
  {
    return this->slur_;
  }

  void notations::
  slur (const slur_sequence& s)
  {
    this->slur_ = s;
  }

  const notations::tuplet_sequence& notations::
  tuplet () const
  {
    return this->tuplet_;
  }

  notations::tuplet_sequence& notations::
  tuplet ()
  {
    return this->tuplet_;
  }

  void notations::
  tuplet (const tuplet_sequence& s)
  {
    this->tuplet_ = s;
  }

  const notations::glissando_sequence& notations::
  glissando () const
  {
    return this->glissando_;
  }

  notations::glissando_sequence& notations::
  glissando ()
  {
    return this->glissando_;
  }

  void notations::
  glissando (const glissando_sequence& s)
  {
    this->glissando_ = s;
  }

  const notations::slide_sequence& notations::
  slide () const
  {
    return this->slide_;
  }

  notations::slide_sequence& notations::
  slide ()
  {
    return this->slide_;
  }

  void notations::
  slide (const slide_sequence& s)
  {
    this->slide_ = s;
  }

  const notations::ornaments_sequence& notations::
  ornaments () const
  {
    return this->ornaments_;
  }

  notations::ornaments_sequence& notations::
  ornaments ()
  {
    return this->ornaments_;
  }

  void notations::
  ornaments (const ornaments_sequence& s)
  {
    this->ornaments_ = s;
  }

  const notations::technical_sequence& notations::
  technical () const
  {
    return this->technical_;
  }

  notations::technical_sequence& notations::
  technical ()
  {
    return this->technical_;
  }

  void notations::
  technical (const technical_sequence& s)
  {
    this->technical_ = s;
  }

  const notations::articulations_sequence& notations::
  articulations () const
  {
    return this->articulations_;
  }

  notations::articulations_sequence& notations::
  articulations ()
  {
    return this->articulations_;
  }

  void notations::
  articulations (const articulations_sequence& s)
  {
    this->articulations_ = s;
  }

  const notations::dynamics_sequence& notations::
  dynamics () const
  {
    return this->dynamics_;
  }

  notations::dynamics_sequence& notations::
  dynamics ()
  {
    return this->dynamics_;
  }

  void notations::
  dynamics (const dynamics_sequence& s)
  {
    this->dynamics_ = s;
  }

  const notations::fermata_sequence& notations::
  fermata () const
  {
    return this->fermata_;
  }

  notations::fermata_sequence& notations::
  fermata ()
  {
    return this->fermata_;
  }

  void notations::
  fermata (const fermata_sequence& s)
  {
    this->fermata_ = s;
  }

  const notations::arpeggiate_sequence& notations::
  arpeggiate () const
  {
    return this->arpeggiate_;
  }

  notations::arpeggiate_sequence& notations::
  arpeggiate ()
  {
    return this->arpeggiate_;
  }

  void notations::
  arpeggiate (const arpeggiate_sequence& s)
  {
    this->arpeggiate_ = s;
  }

  const notations::non_arpeggiate_sequence& notations::
  non_arpeggiate () const
  {
    return this->non_arpeggiate_;
  }

  notations::non_arpeggiate_sequence& notations::
  non_arpeggiate ()
  {
    return this->non_arpeggiate_;
  }

  void notations::
  non_arpeggiate (const non_arpeggiate_sequence& s)
  {
    this->non_arpeggiate_ = s;
  }

  const notations::accidental_mark_sequence& notations::
  accidental_mark () const
  {
    return this->accidental_mark_;
  }

  notations::accidental_mark_sequence& notations::
  accidental_mark ()
  {
    return this->accidental_mark_;
  }

  void notations::
  accidental_mark (const accidental_mark_sequence& s)
  {
    this->accidental_mark_ = s;
  }

  const notations::other_notation_sequence& notations::
  other_notation () const
  {
    return this->other_notation_;
  }

  notations::other_notation_sequence& notations::
  other_notation ()
  {
    return this->other_notation_;
  }

  void notations::
  other_notation (const other_notation_sequence& s)
  {
    this->other_notation_ = s;
  }

  const notations::print_object_optional& notations::
  print_object () const
  {
    return this->print_object_;
  }

  notations::print_object_optional& notations::
  print_object ()
  {
    return this->print_object_;
  }

  void notations::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void notations::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void notations::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const notations::id_optional& notations::
  id () const
  {
    return this->id_;
  }

  notations::id_optional& notations::
  id ()
  {
    return this->id_;
  }

  void notations::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void notations::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void notations::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // note
  // 

  const note::grace_optional& note::
  grace () const
  {
    return this->grace_;
  }

  note::grace_optional& note::
  grace ()
  {
    return this->grace_;
  }

  void note::
  grace (const grace_type& x)
  {
    this->grace_.set (x);
  }

  void note::
  grace (const grace_optional& x)
  {
    this->grace_ = x;
  }

  void note::
  grace (::std::unique_ptr< grace_type > x)
  {
    this->grace_.set (std::move (x));
  }

  const note::chord_optional& note::
  chord () const
  {
    return this->chord_;
  }

  note::chord_optional& note::
  chord ()
  {
    return this->chord_;
  }

  void note::
  chord (const chord_type& x)
  {
    this->chord_.set (x);
  }

  void note::
  chord (const chord_optional& x)
  {
    this->chord_ = x;
  }

  void note::
  chord (::std::unique_ptr< chord_type > x)
  {
    this->chord_.set (std::move (x));
  }

  const note::pitch_optional& note::
  pitch () const
  {
    return this->pitch_;
  }

  note::pitch_optional& note::
  pitch ()
  {
    return this->pitch_;
  }

  void note::
  pitch (const pitch_type& x)
  {
    this->pitch_.set (x);
  }

  void note::
  pitch (const pitch_optional& x)
  {
    this->pitch_ = x;
  }

  void note::
  pitch (::std::unique_ptr< pitch_type > x)
  {
    this->pitch_.set (std::move (x));
  }

  const note::unpitched_optional& note::
  unpitched () const
  {
    return this->unpitched_;
  }

  note::unpitched_optional& note::
  unpitched ()
  {
    return this->unpitched_;
  }

  void note::
  unpitched (const unpitched_type& x)
  {
    this->unpitched_.set (x);
  }

  void note::
  unpitched (const unpitched_optional& x)
  {
    this->unpitched_ = x;
  }

  void note::
  unpitched (::std::unique_ptr< unpitched_type > x)
  {
    this->unpitched_.set (std::move (x));
  }

  const note::rest_optional& note::
  rest () const
  {
    return this->rest_;
  }

  note::rest_optional& note::
  rest ()
  {
    return this->rest_;
  }

  void note::
  rest (const rest_type& x)
  {
    this->rest_.set (x);
  }

  void note::
  rest (const rest_optional& x)
  {
    this->rest_ = x;
  }

  void note::
  rest (::std::unique_ptr< rest_type > x)
  {
    this->rest_.set (std::move (x));
  }

  const note::tie_sequence& note::
  tie () const
  {
    return this->tie_;
  }

  note::tie_sequence& note::
  tie ()
  {
    return this->tie_;
  }

  void note::
  tie (const tie_sequence& s)
  {
    this->tie_ = s;
  }

  const note::cue_optional& note::
  cue () const
  {
    return this->cue_;
  }

  note::cue_optional& note::
  cue ()
  {
    return this->cue_;
  }

  void note::
  cue (const cue_type& x)
  {
    this->cue_.set (x);
  }

  void note::
  cue (const cue_optional& x)
  {
    this->cue_ = x;
  }

  void note::
  cue (::std::unique_ptr< cue_type > x)
  {
    this->cue_.set (std::move (x));
  }

  const note::duration_optional& note::
  duration () const
  {
    return this->duration_;
  }

  note::duration_optional& note::
  duration ()
  {
    return this->duration_;
  }

  void note::
  duration (const duration_type& x)
  {
    this->duration_.set (x);
  }

  void note::
  duration (const duration_optional& x)
  {
    this->duration_ = x;
  }

  void note::
  duration (::std::unique_ptr< duration_type > x)
  {
    this->duration_.set (std::move (x));
  }

  const note::instrument_sequence& note::
  instrument () const
  {
    return this->instrument_;
  }

  note::instrument_sequence& note::
  instrument ()
  {
    return this->instrument_;
  }

  void note::
  instrument (const instrument_sequence& s)
  {
    this->instrument_ = s;
  }

  const note::footnote_optional& note::
  footnote () const
  {
    return this->footnote_;
  }

  note::footnote_optional& note::
  footnote ()
  {
    return this->footnote_;
  }

  void note::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void note::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void note::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const note::level_optional& note::
  level () const
  {
    return this->level_;
  }

  note::level_optional& note::
  level ()
  {
    return this->level_;
  }

  void note::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void note::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void note::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const note::voice_optional& note::
  voice () const
  {
    return this->voice_;
  }

  note::voice_optional& note::
  voice ()
  {
    return this->voice_;
  }

  void note::
  voice (const voice_type& x)
  {
    this->voice_.set (x);
  }

  void note::
  voice (const voice_optional& x)
  {
    this->voice_ = x;
  }

  void note::
  voice (::std::unique_ptr< voice_type > x)
  {
    this->voice_.set (std::move (x));
  }

  const note::type_optional& note::
  type () const
  {
    return this->type_;
  }

  note::type_optional& note::
  type ()
  {
    return this->type_;
  }

  void note::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void note::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void note::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const note::dot_sequence& note::
  dot () const
  {
    return this->dot_;
  }

  note::dot_sequence& note::
  dot ()
  {
    return this->dot_;
  }

  void note::
  dot (const dot_sequence& s)
  {
    this->dot_ = s;
  }

  const note::accidental_optional& note::
  accidental () const
  {
    return this->accidental_;
  }

  note::accidental_optional& note::
  accidental ()
  {
    return this->accidental_;
  }

  void note::
  accidental (const accidental_type& x)
  {
    this->accidental_.set (x);
  }

  void note::
  accidental (const accidental_optional& x)
  {
    this->accidental_ = x;
  }

  void note::
  accidental (::std::unique_ptr< accidental_type > x)
  {
    this->accidental_.set (std::move (x));
  }

  const note::time_modification_optional& note::
  time_modification () const
  {
    return this->time_modification_;
  }

  note::time_modification_optional& note::
  time_modification ()
  {
    return this->time_modification_;
  }

  void note::
  time_modification (const time_modification_type& x)
  {
    this->time_modification_.set (x);
  }

  void note::
  time_modification (const time_modification_optional& x)
  {
    this->time_modification_ = x;
  }

  void note::
  time_modification (::std::unique_ptr< time_modification_type > x)
  {
    this->time_modification_.set (std::move (x));
  }

  const note::stem_optional& note::
  stem () const
  {
    return this->stem_;
  }

  note::stem_optional& note::
  stem ()
  {
    return this->stem_;
  }

  void note::
  stem (const stem_type& x)
  {
    this->stem_.set (x);
  }

  void note::
  stem (const stem_optional& x)
  {
    this->stem_ = x;
  }

  void note::
  stem (::std::unique_ptr< stem_type > x)
  {
    this->stem_.set (std::move (x));
  }

  const note::notehead_optional& note::
  notehead () const
  {
    return this->notehead_;
  }

  note::notehead_optional& note::
  notehead ()
  {
    return this->notehead_;
  }

  void note::
  notehead (const notehead_type& x)
  {
    this->notehead_.set (x);
  }

  void note::
  notehead (const notehead_optional& x)
  {
    this->notehead_ = x;
  }

  void note::
  notehead (::std::unique_ptr< notehead_type > x)
  {
    this->notehead_.set (std::move (x));
  }

  const note::notehead_text_optional& note::
  notehead_text () const
  {
    return this->notehead_text_;
  }

  note::notehead_text_optional& note::
  notehead_text ()
  {
    return this->notehead_text_;
  }

  void note::
  notehead_text (const notehead_text_type& x)
  {
    this->notehead_text_.set (x);
  }

  void note::
  notehead_text (const notehead_text_optional& x)
  {
    this->notehead_text_ = x;
  }

  void note::
  notehead_text (::std::unique_ptr< notehead_text_type > x)
  {
    this->notehead_text_.set (std::move (x));
  }

  const note::staff_optional& note::
  staff () const
  {
    return this->staff_;
  }

  note::staff_optional& note::
  staff ()
  {
    return this->staff_;
  }

  void note::
  staff (const staff_type& x)
  {
    this->staff_.set (x);
  }

  void note::
  staff (const staff_optional& x)
  {
    this->staff_ = x;
  }

  const note::beam_sequence& note::
  beam () const
  {
    return this->beam_;
  }

  note::beam_sequence& note::
  beam ()
  {
    return this->beam_;
  }

  void note::
  beam (const beam_sequence& s)
  {
    this->beam_ = s;
  }

  const note::notations_sequence& note::
  notations () const
  {
    return this->notations_;
  }

  note::notations_sequence& note::
  notations ()
  {
    return this->notations_;
  }

  void note::
  notations (const notations_sequence& s)
  {
    this->notations_ = s;
  }

  const note::lyric_sequence& note::
  lyric () const
  {
    return this->lyric_;
  }

  note::lyric_sequence& note::
  lyric ()
  {
    return this->lyric_;
  }

  void note::
  lyric (const lyric_sequence& s)
  {
    this->lyric_ = s;
  }

  const note::play_optional& note::
  play () const
  {
    return this->play_;
  }

  note::play_optional& note::
  play ()
  {
    return this->play_;
  }

  void note::
  play (const play_type& x)
  {
    this->play_.set (x);
  }

  void note::
  play (const play_optional& x)
  {
    this->play_ = x;
  }

  void note::
  play (::std::unique_ptr< play_type > x)
  {
    this->play_.set (std::move (x));
  }

  const note::listen_optional& note::
  listen () const
  {
    return this->listen_;
  }

  note::listen_optional& note::
  listen ()
  {
    return this->listen_;
  }

  void note::
  listen (const listen_type& x)
  {
    this->listen_.set (x);
  }

  void note::
  listen (const listen_optional& x)
  {
    this->listen_ = x;
  }

  void note::
  listen (::std::unique_ptr< listen_type > x)
  {
    this->listen_.set (std::move (x));
  }

  const note::default_x_optional& note::
  default_x () const
  {
    return this->default_x_;
  }

  note::default_x_optional& note::
  default_x ()
  {
    return this->default_x_;
  }

  void note::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void note::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void note::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const note::default_y_optional& note::
  default_y () const
  {
    return this->default_y_;
  }

  note::default_y_optional& note::
  default_y ()
  {
    return this->default_y_;
  }

  void note::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void note::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void note::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const note::relative_x_optional& note::
  relative_x () const
  {
    return this->relative_x_;
  }

  note::relative_x_optional& note::
  relative_x ()
  {
    return this->relative_x_;
  }

  void note::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void note::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void note::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const note::relative_y_optional& note::
  relative_y () const
  {
    return this->relative_y_;
  }

  note::relative_y_optional& note::
  relative_y ()
  {
    return this->relative_y_;
  }

  void note::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void note::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void note::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const note::font_family_optional& note::
  font_family () const
  {
    return this->font_family_;
  }

  note::font_family_optional& note::
  font_family ()
  {
    return this->font_family_;
  }

  void note::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void note::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void note::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const note::font_style_optional& note::
  font_style () const
  {
    return this->font_style_;
  }

  note::font_style_optional& note::
  font_style ()
  {
    return this->font_style_;
  }

  void note::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void note::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void note::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const note::font_size_optional& note::
  font_size () const
  {
    return this->font_size_;
  }

  note::font_size_optional& note::
  font_size ()
  {
    return this->font_size_;
  }

  void note::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void note::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void note::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const note::font_weight_optional& note::
  font_weight () const
  {
    return this->font_weight_;
  }

  note::font_weight_optional& note::
  font_weight ()
  {
    return this->font_weight_;
  }

  void note::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void note::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void note::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const note::color_optional& note::
  color () const
  {
    return this->color_;
  }

  note::color_optional& note::
  color ()
  {
    return this->color_;
  }

  void note::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void note::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void note::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const note::print_object_optional& note::
  print_object () const
  {
    return this->print_object_;
  }

  note::print_object_optional& note::
  print_object ()
  {
    return this->print_object_;
  }

  void note::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void note::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void note::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const note::print_dot_optional& note::
  print_dot () const
  {
    return this->print_dot_;
  }

  note::print_dot_optional& note::
  print_dot ()
  {
    return this->print_dot_;
  }

  void note::
  print_dot (const print_dot_type& x)
  {
    this->print_dot_.set (x);
  }

  void note::
  print_dot (const print_dot_optional& x)
  {
    this->print_dot_ = x;
  }

  void note::
  print_dot (::std::unique_ptr< print_dot_type > x)
  {
    this->print_dot_.set (std::move (x));
  }

  const note::print_spacing_optional& note::
  print_spacing () const
  {
    return this->print_spacing_;
  }

  note::print_spacing_optional& note::
  print_spacing ()
  {
    return this->print_spacing_;
  }

  void note::
  print_spacing (const print_spacing_type& x)
  {
    this->print_spacing_.set (x);
  }

  void note::
  print_spacing (const print_spacing_optional& x)
  {
    this->print_spacing_ = x;
  }

  void note::
  print_spacing (::std::unique_ptr< print_spacing_type > x)
  {
    this->print_spacing_.set (std::move (x));
  }

  const note::print_lyric_optional& note::
  print_lyric () const
  {
    return this->print_lyric_;
  }

  note::print_lyric_optional& note::
  print_lyric ()
  {
    return this->print_lyric_;
  }

  void note::
  print_lyric (const print_lyric_type& x)
  {
    this->print_lyric_.set (x);
  }

  void note::
  print_lyric (const print_lyric_optional& x)
  {
    this->print_lyric_ = x;
  }

  void note::
  print_lyric (::std::unique_ptr< print_lyric_type > x)
  {
    this->print_lyric_.set (std::move (x));
  }

  const note::print_leger_optional& note::
  print_leger () const
  {
    return this->print_leger_;
  }

  note::print_leger_optional& note::
  print_leger ()
  {
    return this->print_leger_;
  }

  void note::
  print_leger (const print_leger_type& x)
  {
    this->print_leger_.set (x);
  }

  void note::
  print_leger (const print_leger_optional& x)
  {
    this->print_leger_ = x;
  }

  void note::
  print_leger (::std::unique_ptr< print_leger_type > x)
  {
    this->print_leger_.set (std::move (x));
  }

  const note::dynamics_optional& note::
  dynamics () const
  {
    return this->dynamics_;
  }

  note::dynamics_optional& note::
  dynamics ()
  {
    return this->dynamics_;
  }

  void note::
  dynamics (const dynamics_type& x)
  {
    this->dynamics_.set (x);
  }

  void note::
  dynamics (const dynamics_optional& x)
  {
    this->dynamics_ = x;
  }

  void note::
  dynamics (::std::unique_ptr< dynamics_type > x)
  {
    this->dynamics_.set (std::move (x));
  }

  const note::end_dynamics_optional& note::
  end_dynamics () const
  {
    return this->end_dynamics_;
  }

  note::end_dynamics_optional& note::
  end_dynamics ()
  {
    return this->end_dynamics_;
  }

  void note::
  end_dynamics (const end_dynamics_type& x)
  {
    this->end_dynamics_.set (x);
  }

  void note::
  end_dynamics (const end_dynamics_optional& x)
  {
    this->end_dynamics_ = x;
  }

  void note::
  end_dynamics (::std::unique_ptr< end_dynamics_type > x)
  {
    this->end_dynamics_.set (std::move (x));
  }

  const note::attack_optional& note::
  attack () const
  {
    return this->attack_;
  }

  note::attack_optional& note::
  attack ()
  {
    return this->attack_;
  }

  void note::
  attack (const attack_type& x)
  {
    this->attack_.set (x);
  }

  void note::
  attack (const attack_optional& x)
  {
    this->attack_ = x;
  }

  void note::
  attack (::std::unique_ptr< attack_type > x)
  {
    this->attack_.set (std::move (x));
  }

  const note::release_optional& note::
  release () const
  {
    return this->release_;
  }

  note::release_optional& note::
  release ()
  {
    return this->release_;
  }

  void note::
  release (const release_type& x)
  {
    this->release_.set (x);
  }

  void note::
  release (const release_optional& x)
  {
    this->release_ = x;
  }

  void note::
  release (::std::unique_ptr< release_type > x)
  {
    this->release_.set (std::move (x));
  }

  const note::time_only_optional& note::
  time_only () const
  {
    return this->time_only_;
  }

  note::time_only_optional& note::
  time_only ()
  {
    return this->time_only_;
  }

  void note::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void note::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void note::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }

  const note::pizzicato_optional& note::
  pizzicato () const
  {
    return this->pizzicato_;
  }

  note::pizzicato_optional& note::
  pizzicato ()
  {
    return this->pizzicato_;
  }

  void note::
  pizzicato (const pizzicato_type& x)
  {
    this->pizzicato_.set (x);
  }

  void note::
  pizzicato (const pizzicato_optional& x)
  {
    this->pizzicato_ = x;
  }

  void note::
  pizzicato (::std::unique_ptr< pizzicato_type > x)
  {
    this->pizzicato_.set (std::move (x));
  }

  const note::id_optional& note::
  id () const
  {
    return this->id_;
  }

  note::id_optional& note::
  id ()
  {
    return this->id_;
  }

  void note::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void note::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void note::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // note_type
  // 

  const note_type::size_optional& note_type::
  size () const
  {
    return this->size_;
  }

  note_type::size_optional& note_type::
  size ()
  {
    return this->size_;
  }

  void note_type::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void note_type::
  size (const size_optional& x)
  {
    this->size_ = x;
  }

  void note_type::
  size (::std::unique_ptr< size_type > x)
  {
    this->size_.set (std::move (x));
  }


  // notehead
  // 

  const notehead::filled_optional& notehead::
  filled () const
  {
    return this->filled_;
  }

  notehead::filled_optional& notehead::
  filled ()
  {
    return this->filled_;
  }

  void notehead::
  filled (const filled_type& x)
  {
    this->filled_.set (x);
  }

  void notehead::
  filled (const filled_optional& x)
  {
    this->filled_ = x;
  }

  void notehead::
  filled (::std::unique_ptr< filled_type > x)
  {
    this->filled_.set (std::move (x));
  }

  const notehead::parentheses_optional& notehead::
  parentheses () const
  {
    return this->parentheses_;
  }

  notehead::parentheses_optional& notehead::
  parentheses ()
  {
    return this->parentheses_;
  }

  void notehead::
  parentheses (const parentheses_type& x)
  {
    this->parentheses_.set (x);
  }

  void notehead::
  parentheses (const parentheses_optional& x)
  {
    this->parentheses_ = x;
  }

  void notehead::
  parentheses (::std::unique_ptr< parentheses_type > x)
  {
    this->parentheses_.set (std::move (x));
  }

  const notehead::font_family_optional& notehead::
  font_family () const
  {
    return this->font_family_;
  }

  notehead::font_family_optional& notehead::
  font_family ()
  {
    return this->font_family_;
  }

  void notehead::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void notehead::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void notehead::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const notehead::font_style_optional& notehead::
  font_style () const
  {
    return this->font_style_;
  }

  notehead::font_style_optional& notehead::
  font_style ()
  {
    return this->font_style_;
  }

  void notehead::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void notehead::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void notehead::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const notehead::font_size_optional& notehead::
  font_size () const
  {
    return this->font_size_;
  }

  notehead::font_size_optional& notehead::
  font_size ()
  {
    return this->font_size_;
  }

  void notehead::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void notehead::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void notehead::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const notehead::font_weight_optional& notehead::
  font_weight () const
  {
    return this->font_weight_;
  }

  notehead::font_weight_optional& notehead::
  font_weight ()
  {
    return this->font_weight_;
  }

  void notehead::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void notehead::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void notehead::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const notehead::color_optional& notehead::
  color () const
  {
    return this->color_;
  }

  notehead::color_optional& notehead::
  color ()
  {
    return this->color_;
  }

  void notehead::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void notehead::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void notehead::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const notehead::smufl_optional& notehead::
  smufl () const
  {
    return this->smufl_;
  }

  notehead::smufl_optional& notehead::
  smufl ()
  {
    return this->smufl_;
  }

  void notehead::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void notehead::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void notehead::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // notehead_text
  // 

  const notehead_text::display_text_sequence& notehead_text::
  display_text () const
  {
    return this->display_text_;
  }

  notehead_text::display_text_sequence& notehead_text::
  display_text ()
  {
    return this->display_text_;
  }

  void notehead_text::
  display_text (const display_text_sequence& s)
  {
    this->display_text_ = s;
  }

  const notehead_text::accidental_text_sequence& notehead_text::
  accidental_text () const
  {
    return this->accidental_text_;
  }

  notehead_text::accidental_text_sequence& notehead_text::
  accidental_text ()
  {
    return this->accidental_text_;
  }

  void notehead_text::
  accidental_text (const accidental_text_sequence& s)
  {
    this->accidental_text_ = s;
  }


  // ornaments
  // 

  const ornaments::trill_mark_sequence& ornaments::
  trill_mark () const
  {
    return this->trill_mark_;
  }

  ornaments::trill_mark_sequence& ornaments::
  trill_mark ()
  {
    return this->trill_mark_;
  }

  void ornaments::
  trill_mark (const trill_mark_sequence& s)
  {
    this->trill_mark_ = s;
  }

  const ornaments::turn_sequence& ornaments::
  turn () const
  {
    return this->turn_;
  }

  ornaments::turn_sequence& ornaments::
  turn ()
  {
    return this->turn_;
  }

  void ornaments::
  turn (const turn_sequence& s)
  {
    this->turn_ = s;
  }

  const ornaments::delayed_turn_sequence& ornaments::
  delayed_turn () const
  {
    return this->delayed_turn_;
  }

  ornaments::delayed_turn_sequence& ornaments::
  delayed_turn ()
  {
    return this->delayed_turn_;
  }

  void ornaments::
  delayed_turn (const delayed_turn_sequence& s)
  {
    this->delayed_turn_ = s;
  }

  const ornaments::inverted_turn_sequence& ornaments::
  inverted_turn () const
  {
    return this->inverted_turn_;
  }

  ornaments::inverted_turn_sequence& ornaments::
  inverted_turn ()
  {
    return this->inverted_turn_;
  }

  void ornaments::
  inverted_turn (const inverted_turn_sequence& s)
  {
    this->inverted_turn_ = s;
  }

  const ornaments::delayed_inverted_turn_sequence& ornaments::
  delayed_inverted_turn () const
  {
    return this->delayed_inverted_turn_;
  }

  ornaments::delayed_inverted_turn_sequence& ornaments::
  delayed_inverted_turn ()
  {
    return this->delayed_inverted_turn_;
  }

  void ornaments::
  delayed_inverted_turn (const delayed_inverted_turn_sequence& s)
  {
    this->delayed_inverted_turn_ = s;
  }

  const ornaments::vertical_turn_sequence& ornaments::
  vertical_turn () const
  {
    return this->vertical_turn_;
  }

  ornaments::vertical_turn_sequence& ornaments::
  vertical_turn ()
  {
    return this->vertical_turn_;
  }

  void ornaments::
  vertical_turn (const vertical_turn_sequence& s)
  {
    this->vertical_turn_ = s;
  }

  const ornaments::inverted_vertical_turn_sequence& ornaments::
  inverted_vertical_turn () const
  {
    return this->inverted_vertical_turn_;
  }

  ornaments::inverted_vertical_turn_sequence& ornaments::
  inverted_vertical_turn ()
  {
    return this->inverted_vertical_turn_;
  }

  void ornaments::
  inverted_vertical_turn (const inverted_vertical_turn_sequence& s)
  {
    this->inverted_vertical_turn_ = s;
  }

  const ornaments::shake_sequence& ornaments::
  shake () const
  {
    return this->shake_;
  }

  ornaments::shake_sequence& ornaments::
  shake ()
  {
    return this->shake_;
  }

  void ornaments::
  shake (const shake_sequence& s)
  {
    this->shake_ = s;
  }

  const ornaments::wavy_line_sequence& ornaments::
  wavy_line () const
  {
    return this->wavy_line_;
  }

  ornaments::wavy_line_sequence& ornaments::
  wavy_line ()
  {
    return this->wavy_line_;
  }

  void ornaments::
  wavy_line (const wavy_line_sequence& s)
  {
    this->wavy_line_ = s;
  }

  const ornaments::mordent_sequence& ornaments::
  mordent () const
  {
    return this->mordent_;
  }

  ornaments::mordent_sequence& ornaments::
  mordent ()
  {
    return this->mordent_;
  }

  void ornaments::
  mordent (const mordent_sequence& s)
  {
    this->mordent_ = s;
  }

  const ornaments::inverted_mordent_sequence& ornaments::
  inverted_mordent () const
  {
    return this->inverted_mordent_;
  }

  ornaments::inverted_mordent_sequence& ornaments::
  inverted_mordent ()
  {
    return this->inverted_mordent_;
  }

  void ornaments::
  inverted_mordent (const inverted_mordent_sequence& s)
  {
    this->inverted_mordent_ = s;
  }

  const ornaments::schleifer_sequence& ornaments::
  schleifer () const
  {
    return this->schleifer_;
  }

  ornaments::schleifer_sequence& ornaments::
  schleifer ()
  {
    return this->schleifer_;
  }

  void ornaments::
  schleifer (const schleifer_sequence& s)
  {
    this->schleifer_ = s;
  }

  const ornaments::tremolo_sequence& ornaments::
  tremolo () const
  {
    return this->tremolo_;
  }

  ornaments::tremolo_sequence& ornaments::
  tremolo ()
  {
    return this->tremolo_;
  }

  void ornaments::
  tremolo (const tremolo_sequence& s)
  {
    this->tremolo_ = s;
  }

  const ornaments::haydn_sequence& ornaments::
  haydn () const
  {
    return this->haydn_;
  }

  ornaments::haydn_sequence& ornaments::
  haydn ()
  {
    return this->haydn_;
  }

  void ornaments::
  haydn (const haydn_sequence& s)
  {
    this->haydn_ = s;
  }

  const ornaments::other_ornament_sequence& ornaments::
  other_ornament () const
  {
    return this->other_ornament_;
  }

  ornaments::other_ornament_sequence& ornaments::
  other_ornament ()
  {
    return this->other_ornament_;
  }

  void ornaments::
  other_ornament (const other_ornament_sequence& s)
  {
    this->other_ornament_ = s;
  }

  const ornaments::accidental_mark_sequence& ornaments::
  accidental_mark () const
  {
    return this->accidental_mark_;
  }

  ornaments::accidental_mark_sequence& ornaments::
  accidental_mark ()
  {
    return this->accidental_mark_;
  }

  void ornaments::
  accidental_mark (const accidental_mark_sequence& s)
  {
    this->accidental_mark_ = s;
  }

  const ornaments::id_optional& ornaments::
  id () const
  {
    return this->id_;
  }

  ornaments::id_optional& ornaments::
  id ()
  {
    return this->id_;
  }

  void ornaments::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void ornaments::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void ornaments::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // other_notation
  // 

  const other_notation::type_type& other_notation::
  type () const
  {
    return this->type_.get ();
  }

  other_notation::type_type& other_notation::
  type ()
  {
    return this->type_.get ();
  }

  void other_notation::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void other_notation::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const other_notation::number_type& other_notation::
  number () const
  {
    return this->number_.get ();
  }

  other_notation::number_type& other_notation::
  number ()
  {
    return this->number_.get ();
  }

  void other_notation::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void other_notation::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  other_notation::number_type other_notation::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const other_notation::print_object_optional& other_notation::
  print_object () const
  {
    return this->print_object_;
  }

  other_notation::print_object_optional& other_notation::
  print_object ()
  {
    return this->print_object_;
  }

  void other_notation::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void other_notation::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void other_notation::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const other_notation::default_x_optional& other_notation::
  default_x () const
  {
    return this->default_x_;
  }

  other_notation::default_x_optional& other_notation::
  default_x ()
  {
    return this->default_x_;
  }

  void other_notation::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void other_notation::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void other_notation::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const other_notation::default_y_optional& other_notation::
  default_y () const
  {
    return this->default_y_;
  }

  other_notation::default_y_optional& other_notation::
  default_y ()
  {
    return this->default_y_;
  }

  void other_notation::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void other_notation::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void other_notation::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const other_notation::relative_x_optional& other_notation::
  relative_x () const
  {
    return this->relative_x_;
  }

  other_notation::relative_x_optional& other_notation::
  relative_x ()
  {
    return this->relative_x_;
  }

  void other_notation::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void other_notation::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void other_notation::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const other_notation::relative_y_optional& other_notation::
  relative_y () const
  {
    return this->relative_y_;
  }

  other_notation::relative_y_optional& other_notation::
  relative_y ()
  {
    return this->relative_y_;
  }

  void other_notation::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void other_notation::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void other_notation::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const other_notation::font_family_optional& other_notation::
  font_family () const
  {
    return this->font_family_;
  }

  other_notation::font_family_optional& other_notation::
  font_family ()
  {
    return this->font_family_;
  }

  void other_notation::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void other_notation::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void other_notation::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const other_notation::font_style_optional& other_notation::
  font_style () const
  {
    return this->font_style_;
  }

  other_notation::font_style_optional& other_notation::
  font_style ()
  {
    return this->font_style_;
  }

  void other_notation::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void other_notation::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void other_notation::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const other_notation::font_size_optional& other_notation::
  font_size () const
  {
    return this->font_size_;
  }

  other_notation::font_size_optional& other_notation::
  font_size ()
  {
    return this->font_size_;
  }

  void other_notation::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void other_notation::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void other_notation::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const other_notation::font_weight_optional& other_notation::
  font_weight () const
  {
    return this->font_weight_;
  }

  other_notation::font_weight_optional& other_notation::
  font_weight ()
  {
    return this->font_weight_;
  }

  void other_notation::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void other_notation::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void other_notation::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const other_notation::color_optional& other_notation::
  color () const
  {
    return this->color_;
  }

  other_notation::color_optional& other_notation::
  color ()
  {
    return this->color_;
  }

  void other_notation::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void other_notation::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void other_notation::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const other_notation::placement_optional& other_notation::
  placement () const
  {
    return this->placement_;
  }

  other_notation::placement_optional& other_notation::
  placement ()
  {
    return this->placement_;
  }

  void other_notation::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void other_notation::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void other_notation::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const other_notation::smufl_optional& other_notation::
  smufl () const
  {
    return this->smufl_;
  }

  other_notation::smufl_optional& other_notation::
  smufl ()
  {
    return this->smufl_;
  }

  void other_notation::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void other_notation::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void other_notation::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }

  const other_notation::id_optional& other_notation::
  id () const
  {
    return this->id_;
  }

  other_notation::id_optional& other_notation::
  id ()
  {
    return this->id_;
  }

  void other_notation::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void other_notation::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void other_notation::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // other_placement_text
  // 

  const other_placement_text::default_x_optional& other_placement_text::
  default_x () const
  {
    return this->default_x_;
  }

  other_placement_text::default_x_optional& other_placement_text::
  default_x ()
  {
    return this->default_x_;
  }

  void other_placement_text::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void other_placement_text::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void other_placement_text::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const other_placement_text::default_y_optional& other_placement_text::
  default_y () const
  {
    return this->default_y_;
  }

  other_placement_text::default_y_optional& other_placement_text::
  default_y ()
  {
    return this->default_y_;
  }

  void other_placement_text::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void other_placement_text::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void other_placement_text::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const other_placement_text::relative_x_optional& other_placement_text::
  relative_x () const
  {
    return this->relative_x_;
  }

  other_placement_text::relative_x_optional& other_placement_text::
  relative_x ()
  {
    return this->relative_x_;
  }

  void other_placement_text::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void other_placement_text::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void other_placement_text::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const other_placement_text::relative_y_optional& other_placement_text::
  relative_y () const
  {
    return this->relative_y_;
  }

  other_placement_text::relative_y_optional& other_placement_text::
  relative_y ()
  {
    return this->relative_y_;
  }

  void other_placement_text::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void other_placement_text::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void other_placement_text::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const other_placement_text::font_family_optional& other_placement_text::
  font_family () const
  {
    return this->font_family_;
  }

  other_placement_text::font_family_optional& other_placement_text::
  font_family ()
  {
    return this->font_family_;
  }

  void other_placement_text::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void other_placement_text::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void other_placement_text::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const other_placement_text::font_style_optional& other_placement_text::
  font_style () const
  {
    return this->font_style_;
  }

  other_placement_text::font_style_optional& other_placement_text::
  font_style ()
  {
    return this->font_style_;
  }

  void other_placement_text::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void other_placement_text::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void other_placement_text::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const other_placement_text::font_size_optional& other_placement_text::
  font_size () const
  {
    return this->font_size_;
  }

  other_placement_text::font_size_optional& other_placement_text::
  font_size ()
  {
    return this->font_size_;
  }

  void other_placement_text::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void other_placement_text::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void other_placement_text::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const other_placement_text::font_weight_optional& other_placement_text::
  font_weight () const
  {
    return this->font_weight_;
  }

  other_placement_text::font_weight_optional& other_placement_text::
  font_weight ()
  {
    return this->font_weight_;
  }

  void other_placement_text::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void other_placement_text::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void other_placement_text::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const other_placement_text::color_optional& other_placement_text::
  color () const
  {
    return this->color_;
  }

  other_placement_text::color_optional& other_placement_text::
  color ()
  {
    return this->color_;
  }

  void other_placement_text::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void other_placement_text::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void other_placement_text::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const other_placement_text::placement_optional& other_placement_text::
  placement () const
  {
    return this->placement_;
  }

  other_placement_text::placement_optional& other_placement_text::
  placement ()
  {
    return this->placement_;
  }

  void other_placement_text::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void other_placement_text::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void other_placement_text::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const other_placement_text::smufl_optional& other_placement_text::
  smufl () const
  {
    return this->smufl_;
  }

  other_placement_text::smufl_optional& other_placement_text::
  smufl ()
  {
    return this->smufl_;
  }

  void other_placement_text::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void other_placement_text::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void other_placement_text::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // other_text
  // 

  const other_text::smufl_optional& other_text::
  smufl () const
  {
    return this->smufl_;
  }

  other_text::smufl_optional& other_text::
  smufl ()
  {
    return this->smufl_;
  }

  void other_text::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void other_text::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void other_text::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // pitch
  // 

  const pitch::step_type& pitch::
  step () const
  {
    return this->step_.get ();
  }

  pitch::step_type& pitch::
  step ()
  {
    return this->step_.get ();
  }

  void pitch::
  step (const step_type& x)
  {
    this->step_.set (x);
  }

  void pitch::
  step (::std::unique_ptr< step_type > x)
  {
    this->step_.set (std::move (x));
  }

  const pitch::alter_optional& pitch::
  alter () const
  {
    return this->alter_;
  }

  pitch::alter_optional& pitch::
  alter ()
  {
    return this->alter_;
  }

  void pitch::
  alter (const alter_type& x)
  {
    this->alter_.set (x);
  }

  void pitch::
  alter (const alter_optional& x)
  {
    this->alter_ = x;
  }

  void pitch::
  alter (::std::unique_ptr< alter_type > x)
  {
    this->alter_.set (std::move (x));
  }

  const pitch::octave_type& pitch::
  octave () const
  {
    return this->octave_.get ();
  }

  pitch::octave_type& pitch::
  octave ()
  {
    return this->octave_.get ();
  }

  void pitch::
  octave (const octave_type& x)
  {
    this->octave_.set (x);
  }

  void pitch::
  octave (::std::unique_ptr< octave_type > x)
  {
    this->octave_.set (std::move (x));
  }


  // placement_text
  // 

  const placement_text::default_x_optional& placement_text::
  default_x () const
  {
    return this->default_x_;
  }

  placement_text::default_x_optional& placement_text::
  default_x ()
  {
    return this->default_x_;
  }

  void placement_text::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void placement_text::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void placement_text::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const placement_text::default_y_optional& placement_text::
  default_y () const
  {
    return this->default_y_;
  }

  placement_text::default_y_optional& placement_text::
  default_y ()
  {
    return this->default_y_;
  }

  void placement_text::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void placement_text::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void placement_text::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const placement_text::relative_x_optional& placement_text::
  relative_x () const
  {
    return this->relative_x_;
  }

  placement_text::relative_x_optional& placement_text::
  relative_x ()
  {
    return this->relative_x_;
  }

  void placement_text::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void placement_text::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void placement_text::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const placement_text::relative_y_optional& placement_text::
  relative_y () const
  {
    return this->relative_y_;
  }

  placement_text::relative_y_optional& placement_text::
  relative_y ()
  {
    return this->relative_y_;
  }

  void placement_text::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void placement_text::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void placement_text::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const placement_text::font_family_optional& placement_text::
  font_family () const
  {
    return this->font_family_;
  }

  placement_text::font_family_optional& placement_text::
  font_family ()
  {
    return this->font_family_;
  }

  void placement_text::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void placement_text::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void placement_text::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const placement_text::font_style_optional& placement_text::
  font_style () const
  {
    return this->font_style_;
  }

  placement_text::font_style_optional& placement_text::
  font_style ()
  {
    return this->font_style_;
  }

  void placement_text::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void placement_text::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void placement_text::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const placement_text::font_size_optional& placement_text::
  font_size () const
  {
    return this->font_size_;
  }

  placement_text::font_size_optional& placement_text::
  font_size ()
  {
    return this->font_size_;
  }

  void placement_text::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void placement_text::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void placement_text::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const placement_text::font_weight_optional& placement_text::
  font_weight () const
  {
    return this->font_weight_;
  }

  placement_text::font_weight_optional& placement_text::
  font_weight ()
  {
    return this->font_weight_;
  }

  void placement_text::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void placement_text::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void placement_text::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const placement_text::color_optional& placement_text::
  color () const
  {
    return this->color_;
  }

  placement_text::color_optional& placement_text::
  color ()
  {
    return this->color_;
  }

  void placement_text::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void placement_text::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void placement_text::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const placement_text::placement_optional& placement_text::
  placement () const
  {
    return this->placement_;
  }

  placement_text::placement_optional& placement_text::
  placement ()
  {
    return this->placement_;
  }

  void placement_text::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void placement_text::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void placement_text::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // release
  // 

  const release::offset_optional& release::
  offset () const
  {
    return this->offset_;
  }

  release::offset_optional& release::
  offset ()
  {
    return this->offset_;
  }

  void release::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void release::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  void release::
  offset (::std::unique_ptr< offset_type > x)
  {
    this->offset_.set (std::move (x));
  }


  // rest
  // 

  const rest::display_step_optional& rest::
  display_step () const
  {
    return this->display_step_;
  }

  rest::display_step_optional& rest::
  display_step ()
  {
    return this->display_step_;
  }

  void rest::
  display_step (const display_step_type& x)
  {
    this->display_step_.set (x);
  }

  void rest::
  display_step (const display_step_optional& x)
  {
    this->display_step_ = x;
  }

  void rest::
  display_step (::std::unique_ptr< display_step_type > x)
  {
    this->display_step_.set (std::move (x));
  }

  const rest::display_octave_optional& rest::
  display_octave () const
  {
    return this->display_octave_;
  }

  rest::display_octave_optional& rest::
  display_octave ()
  {
    return this->display_octave_;
  }

  void rest::
  display_octave (const display_octave_type& x)
  {
    this->display_octave_.set (x);
  }

  void rest::
  display_octave (const display_octave_optional& x)
  {
    this->display_octave_ = x;
  }

  void rest::
  display_octave (::std::unique_ptr< display_octave_type > x)
  {
    this->display_octave_.set (std::move (x));
  }

  const rest::measure_optional& rest::
  measure () const
  {
    return this->measure_;
  }

  rest::measure_optional& rest::
  measure ()
  {
    return this->measure_;
  }

  void rest::
  measure (const measure_type& x)
  {
    this->measure_.set (x);
  }

  void rest::
  measure (const measure_optional& x)
  {
    this->measure_ = x;
  }

  void rest::
  measure (::std::unique_ptr< measure_type > x)
  {
    this->measure_.set (std::move (x));
  }


  // slide
  // 

  const slide::type_type& slide::
  type () const
  {
    return this->type_.get ();
  }

  slide::type_type& slide::
  type ()
  {
    return this->type_.get ();
  }

  void slide::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void slide::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const slide::number_type& slide::
  number () const
  {
    return this->number_.get ();
  }

  slide::number_type& slide::
  number ()
  {
    return this->number_.get ();
  }

  void slide::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void slide::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  slide::number_type slide::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const slide::line_type_optional& slide::
  line_type () const
  {
    return this->line_type_;
  }

  slide::line_type_optional& slide::
  line_type ()
  {
    return this->line_type_;
  }

  void slide::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void slide::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void slide::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const slide::dash_length_optional& slide::
  dash_length () const
  {
    return this->dash_length_;
  }

  slide::dash_length_optional& slide::
  dash_length ()
  {
    return this->dash_length_;
  }

  void slide::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void slide::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void slide::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const slide::space_length_optional& slide::
  space_length () const
  {
    return this->space_length_;
  }

  slide::space_length_optional& slide::
  space_length ()
  {
    return this->space_length_;
  }

  void slide::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void slide::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void slide::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const slide::default_x_optional& slide::
  default_x () const
  {
    return this->default_x_;
  }

  slide::default_x_optional& slide::
  default_x ()
  {
    return this->default_x_;
  }

  void slide::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void slide::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void slide::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const slide::default_y_optional& slide::
  default_y () const
  {
    return this->default_y_;
  }

  slide::default_y_optional& slide::
  default_y ()
  {
    return this->default_y_;
  }

  void slide::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void slide::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void slide::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const slide::relative_x_optional& slide::
  relative_x () const
  {
    return this->relative_x_;
  }

  slide::relative_x_optional& slide::
  relative_x ()
  {
    return this->relative_x_;
  }

  void slide::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void slide::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void slide::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const slide::relative_y_optional& slide::
  relative_y () const
  {
    return this->relative_y_;
  }

  slide::relative_y_optional& slide::
  relative_y ()
  {
    return this->relative_y_;
  }

  void slide::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void slide::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void slide::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const slide::font_family_optional& slide::
  font_family () const
  {
    return this->font_family_;
  }

  slide::font_family_optional& slide::
  font_family ()
  {
    return this->font_family_;
  }

  void slide::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void slide::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void slide::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const slide::font_style_optional& slide::
  font_style () const
  {
    return this->font_style_;
  }

  slide::font_style_optional& slide::
  font_style ()
  {
    return this->font_style_;
  }

  void slide::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void slide::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void slide::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const slide::font_size_optional& slide::
  font_size () const
  {
    return this->font_size_;
  }

  slide::font_size_optional& slide::
  font_size ()
  {
    return this->font_size_;
  }

  void slide::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void slide::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void slide::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const slide::font_weight_optional& slide::
  font_weight () const
  {
    return this->font_weight_;
  }

  slide::font_weight_optional& slide::
  font_weight ()
  {
    return this->font_weight_;
  }

  void slide::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void slide::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void slide::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const slide::color_optional& slide::
  color () const
  {
    return this->color_;
  }

  slide::color_optional& slide::
  color ()
  {
    return this->color_;
  }

  void slide::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void slide::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void slide::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const slide::accelerate_optional& slide::
  accelerate () const
  {
    return this->accelerate_;
  }

  slide::accelerate_optional& slide::
  accelerate ()
  {
    return this->accelerate_;
  }

  void slide::
  accelerate (const accelerate_type& x)
  {
    this->accelerate_.set (x);
  }

  void slide::
  accelerate (const accelerate_optional& x)
  {
    this->accelerate_ = x;
  }

  void slide::
  accelerate (::std::unique_ptr< accelerate_type > x)
  {
    this->accelerate_.set (std::move (x));
  }

  const slide::beats_optional& slide::
  beats () const
  {
    return this->beats_;
  }

  slide::beats_optional& slide::
  beats ()
  {
    return this->beats_;
  }

  void slide::
  beats (const beats_type& x)
  {
    this->beats_.set (x);
  }

  void slide::
  beats (const beats_optional& x)
  {
    this->beats_ = x;
  }

  void slide::
  beats (::std::unique_ptr< beats_type > x)
  {
    this->beats_.set (std::move (x));
  }

  const slide::first_beat_optional& slide::
  first_beat () const
  {
    return this->first_beat_;
  }

  slide::first_beat_optional& slide::
  first_beat ()
  {
    return this->first_beat_;
  }

  void slide::
  first_beat (const first_beat_type& x)
  {
    this->first_beat_.set (x);
  }

  void slide::
  first_beat (const first_beat_optional& x)
  {
    this->first_beat_ = x;
  }

  void slide::
  first_beat (::std::unique_ptr< first_beat_type > x)
  {
    this->first_beat_.set (std::move (x));
  }

  const slide::last_beat_optional& slide::
  last_beat () const
  {
    return this->last_beat_;
  }

  slide::last_beat_optional& slide::
  last_beat ()
  {
    return this->last_beat_;
  }

  void slide::
  last_beat (const last_beat_type& x)
  {
    this->last_beat_.set (x);
  }

  void slide::
  last_beat (const last_beat_optional& x)
  {
    this->last_beat_ = x;
  }

  void slide::
  last_beat (::std::unique_ptr< last_beat_type > x)
  {
    this->last_beat_.set (std::move (x));
  }

  const slide::id_optional& slide::
  id () const
  {
    return this->id_;
  }

  slide::id_optional& slide::
  id ()
  {
    return this->id_;
  }

  void slide::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void slide::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void slide::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // slur
  // 

  const slur::type_type& slur::
  type () const
  {
    return this->type_.get ();
  }

  slur::type_type& slur::
  type ()
  {
    return this->type_.get ();
  }

  void slur::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void slur::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const slur::number_type& slur::
  number () const
  {
    return this->number_.get ();
  }

  slur::number_type& slur::
  number ()
  {
    return this->number_.get ();
  }

  void slur::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void slur::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  slur::number_type slur::
  number_default_value ()
  {
    return number_type (1ULL);
  }

  const slur::line_type_optional& slur::
  line_type () const
  {
    return this->line_type_;
  }

  slur::line_type_optional& slur::
  line_type ()
  {
    return this->line_type_;
  }

  void slur::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void slur::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void slur::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const slur::dash_length_optional& slur::
  dash_length () const
  {
    return this->dash_length_;
  }

  slur::dash_length_optional& slur::
  dash_length ()
  {
    return this->dash_length_;
  }

  void slur::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void slur::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void slur::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const slur::space_length_optional& slur::
  space_length () const
  {
    return this->space_length_;
  }

  slur::space_length_optional& slur::
  space_length ()
  {
    return this->space_length_;
  }

  void slur::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void slur::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void slur::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const slur::default_x_optional& slur::
  default_x () const
  {
    return this->default_x_;
  }

  slur::default_x_optional& slur::
  default_x ()
  {
    return this->default_x_;
  }

  void slur::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void slur::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void slur::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const slur::default_y_optional& slur::
  default_y () const
  {
    return this->default_y_;
  }

  slur::default_y_optional& slur::
  default_y ()
  {
    return this->default_y_;
  }

  void slur::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void slur::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void slur::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const slur::relative_x_optional& slur::
  relative_x () const
  {
    return this->relative_x_;
  }

  slur::relative_x_optional& slur::
  relative_x ()
  {
    return this->relative_x_;
  }

  void slur::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void slur::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void slur::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const slur::relative_y_optional& slur::
  relative_y () const
  {
    return this->relative_y_;
  }

  slur::relative_y_optional& slur::
  relative_y ()
  {
    return this->relative_y_;
  }

  void slur::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void slur::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void slur::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const slur::placement_optional& slur::
  placement () const
  {
    return this->placement_;
  }

  slur::placement_optional& slur::
  placement ()
  {
    return this->placement_;
  }

  void slur::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void slur::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void slur::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const slur::orientation_optional& slur::
  orientation () const
  {
    return this->orientation_;
  }

  slur::orientation_optional& slur::
  orientation ()
  {
    return this->orientation_;
  }

  void slur::
  orientation (const orientation_type& x)
  {
    this->orientation_.set (x);
  }

  void slur::
  orientation (const orientation_optional& x)
  {
    this->orientation_ = x;
  }

  void slur::
  orientation (::std::unique_ptr< orientation_type > x)
  {
    this->orientation_.set (std::move (x));
  }

  const slur::bezier_x_optional& slur::
  bezier_x () const
  {
    return this->bezier_x_;
  }

  slur::bezier_x_optional& slur::
  bezier_x ()
  {
    return this->bezier_x_;
  }

  void slur::
  bezier_x (const bezier_x_type& x)
  {
    this->bezier_x_.set (x);
  }

  void slur::
  bezier_x (const bezier_x_optional& x)
  {
    this->bezier_x_ = x;
  }

  void slur::
  bezier_x (::std::unique_ptr< bezier_x_type > x)
  {
    this->bezier_x_.set (std::move (x));
  }

  const slur::bezier_y_optional& slur::
  bezier_y () const
  {
    return this->bezier_y_;
  }

  slur::bezier_y_optional& slur::
  bezier_y ()
  {
    return this->bezier_y_;
  }

  void slur::
  bezier_y (const bezier_y_type& x)
  {
    this->bezier_y_.set (x);
  }

  void slur::
  bezier_y (const bezier_y_optional& x)
  {
    this->bezier_y_ = x;
  }

  void slur::
  bezier_y (::std::unique_ptr< bezier_y_type > x)
  {
    this->bezier_y_.set (std::move (x));
  }

  const slur::bezier_x2_optional& slur::
  bezier_x2 () const
  {
    return this->bezier_x2_;
  }

  slur::bezier_x2_optional& slur::
  bezier_x2 ()
  {
    return this->bezier_x2_;
  }

  void slur::
  bezier_x2 (const bezier_x2_type& x)
  {
    this->bezier_x2_.set (x);
  }

  void slur::
  bezier_x2 (const bezier_x2_optional& x)
  {
    this->bezier_x2_ = x;
  }

  void slur::
  bezier_x2 (::std::unique_ptr< bezier_x2_type > x)
  {
    this->bezier_x2_.set (std::move (x));
  }

  const slur::bezier_y2_optional& slur::
  bezier_y2 () const
  {
    return this->bezier_y2_;
  }

  slur::bezier_y2_optional& slur::
  bezier_y2 ()
  {
    return this->bezier_y2_;
  }

  void slur::
  bezier_y2 (const bezier_y2_type& x)
  {
    this->bezier_y2_.set (x);
  }

  void slur::
  bezier_y2 (const bezier_y2_optional& x)
  {
    this->bezier_y2_ = x;
  }

  void slur::
  bezier_y2 (::std::unique_ptr< bezier_y2_type > x)
  {
    this->bezier_y2_.set (std::move (x));
  }

  const slur::bezier_offset_optional& slur::
  bezier_offset () const
  {
    return this->bezier_offset_;
  }

  slur::bezier_offset_optional& slur::
  bezier_offset ()
  {
    return this->bezier_offset_;
  }

  void slur::
  bezier_offset (const bezier_offset_type& x)
  {
    this->bezier_offset_.set (x);
  }

  void slur::
  bezier_offset (const bezier_offset_optional& x)
  {
    this->bezier_offset_ = x;
  }

  void slur::
  bezier_offset (::std::unique_ptr< bezier_offset_type > x)
  {
    this->bezier_offset_.set (std::move (x));
  }

  const slur::bezier_offset2_optional& slur::
  bezier_offset2 () const
  {
    return this->bezier_offset2_;
  }

  slur::bezier_offset2_optional& slur::
  bezier_offset2 ()
  {
    return this->bezier_offset2_;
  }

  void slur::
  bezier_offset2 (const bezier_offset2_type& x)
  {
    this->bezier_offset2_.set (x);
  }

  void slur::
  bezier_offset2 (const bezier_offset2_optional& x)
  {
    this->bezier_offset2_ = x;
  }

  void slur::
  bezier_offset2 (::std::unique_ptr< bezier_offset2_type > x)
  {
    this->bezier_offset2_.set (std::move (x));
  }

  const slur::color_optional& slur::
  color () const
  {
    return this->color_;
  }

  slur::color_optional& slur::
  color ()
  {
    return this->color_;
  }

  void slur::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void slur::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void slur::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const slur::id_optional& slur::
  id () const
  {
    return this->id_;
  }

  slur::id_optional& slur::
  id ()
  {
    return this->id_;
  }

  void slur::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void slur::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void slur::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // stem
  // 

  const stem::default_x_optional& stem::
  default_x () const
  {
    return this->default_x_;
  }

  stem::default_x_optional& stem::
  default_x ()
  {
    return this->default_x_;
  }

  void stem::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void stem::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void stem::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const stem::default_y_optional& stem::
  default_y () const
  {
    return this->default_y_;
  }

  stem::default_y_optional& stem::
  default_y ()
  {
    return this->default_y_;
  }

  void stem::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void stem::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void stem::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const stem::relative_x_optional& stem::
  relative_x () const
  {
    return this->relative_x_;
  }

  stem::relative_x_optional& stem::
  relative_x ()
  {
    return this->relative_x_;
  }

  void stem::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void stem::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void stem::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const stem::relative_y_optional& stem::
  relative_y () const
  {
    return this->relative_y_;
  }

  stem::relative_y_optional& stem::
  relative_y ()
  {
    return this->relative_y_;
  }

  void stem::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void stem::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void stem::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const stem::color_optional& stem::
  color () const
  {
    return this->color_;
  }

  stem::color_optional& stem::
  color ()
  {
    return this->color_;
  }

  void stem::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void stem::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void stem::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // strong_accent
  // 

  const strong_accent::type_type& strong_accent::
  type () const
  {
    return this->type_.get ();
  }

  strong_accent::type_type& strong_accent::
  type ()
  {
    return this->type_.get ();
  }

  void strong_accent::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void strong_accent::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const strong_accent::type_type& strong_accent::
  type_default_value ()
  {
    return type_default_value_;
  }


  // style_text
  // 

  const style_text::default_x_optional& style_text::
  default_x () const
  {
    return this->default_x_;
  }

  style_text::default_x_optional& style_text::
  default_x ()
  {
    return this->default_x_;
  }

  void style_text::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void style_text::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void style_text::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const style_text::default_y_optional& style_text::
  default_y () const
  {
    return this->default_y_;
  }

  style_text::default_y_optional& style_text::
  default_y ()
  {
    return this->default_y_;
  }

  void style_text::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void style_text::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void style_text::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const style_text::relative_x_optional& style_text::
  relative_x () const
  {
    return this->relative_x_;
  }

  style_text::relative_x_optional& style_text::
  relative_x ()
  {
    return this->relative_x_;
  }

  void style_text::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void style_text::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void style_text::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const style_text::relative_y_optional& style_text::
  relative_y () const
  {
    return this->relative_y_;
  }

  style_text::relative_y_optional& style_text::
  relative_y ()
  {
    return this->relative_y_;
  }

  void style_text::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void style_text::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void style_text::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const style_text::font_family_optional& style_text::
  font_family () const
  {
    return this->font_family_;
  }

  style_text::font_family_optional& style_text::
  font_family ()
  {
    return this->font_family_;
  }

  void style_text::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void style_text::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void style_text::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const style_text::font_style_optional& style_text::
  font_style () const
  {
    return this->font_style_;
  }

  style_text::font_style_optional& style_text::
  font_style ()
  {
    return this->font_style_;
  }

  void style_text::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void style_text::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void style_text::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const style_text::font_size_optional& style_text::
  font_size () const
  {
    return this->font_size_;
  }

  style_text::font_size_optional& style_text::
  font_size ()
  {
    return this->font_size_;
  }

  void style_text::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void style_text::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void style_text::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const style_text::font_weight_optional& style_text::
  font_weight () const
  {
    return this->font_weight_;
  }

  style_text::font_weight_optional& style_text::
  font_weight ()
  {
    return this->font_weight_;
  }

  void style_text::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void style_text::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void style_text::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const style_text::color_optional& style_text::
  color () const
  {
    return this->color_;
  }

  style_text::color_optional& style_text::
  color ()
  {
    return this->color_;
  }

  void style_text::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void style_text::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void style_text::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // tap
  // 

  const tap::hand_optional& tap::
  hand () const
  {
    return this->hand_;
  }

  tap::hand_optional& tap::
  hand ()
  {
    return this->hand_;
  }

  void tap::
  hand (const hand_type& x)
  {
    this->hand_.set (x);
  }

  void tap::
  hand (const hand_optional& x)
  {
    this->hand_ = x;
  }

  void tap::
  hand (::std::unique_ptr< hand_type > x)
  {
    this->hand_.set (std::move (x));
  }

  const tap::default_x_optional& tap::
  default_x () const
  {
    return this->default_x_;
  }

  tap::default_x_optional& tap::
  default_x ()
  {
    return this->default_x_;
  }

  void tap::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void tap::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void tap::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const tap::default_y_optional& tap::
  default_y () const
  {
    return this->default_y_;
  }

  tap::default_y_optional& tap::
  default_y ()
  {
    return this->default_y_;
  }

  void tap::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void tap::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void tap::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const tap::relative_x_optional& tap::
  relative_x () const
  {
    return this->relative_x_;
  }

  tap::relative_x_optional& tap::
  relative_x ()
  {
    return this->relative_x_;
  }

  void tap::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void tap::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void tap::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const tap::relative_y_optional& tap::
  relative_y () const
  {
    return this->relative_y_;
  }

  tap::relative_y_optional& tap::
  relative_y ()
  {
    return this->relative_y_;
  }

  void tap::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void tap::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void tap::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const tap::font_family_optional& tap::
  font_family () const
  {
    return this->font_family_;
  }

  tap::font_family_optional& tap::
  font_family ()
  {
    return this->font_family_;
  }

  void tap::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void tap::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void tap::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const tap::font_style_optional& tap::
  font_style () const
  {
    return this->font_style_;
  }

  tap::font_style_optional& tap::
  font_style ()
  {
    return this->font_style_;
  }

  void tap::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void tap::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void tap::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const tap::font_size_optional& tap::
  font_size () const
  {
    return this->font_size_;
  }

  tap::font_size_optional& tap::
  font_size ()
  {
    return this->font_size_;
  }

  void tap::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void tap::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void tap::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const tap::font_weight_optional& tap::
  font_weight () const
  {
    return this->font_weight_;
  }

  tap::font_weight_optional& tap::
  font_weight ()
  {
    return this->font_weight_;
  }

  void tap::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void tap::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void tap::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const tap::color_optional& tap::
  color () const
  {
    return this->color_;
  }

  tap::color_optional& tap::
  color ()
  {
    return this->color_;
  }

  void tap::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tap::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tap::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const tap::placement_optional& tap::
  placement () const
  {
    return this->placement_;
  }

  tap::placement_optional& tap::
  placement ()
  {
    return this->placement_;
  }

  void tap::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void tap::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void tap::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }


  // technical
  // 

  const technical::up_bow_sequence& technical::
  up_bow () const
  {
    return this->up_bow_;
  }

  technical::up_bow_sequence& technical::
  up_bow ()
  {
    return this->up_bow_;
  }

  void technical::
  up_bow (const up_bow_sequence& s)
  {
    this->up_bow_ = s;
  }

  const technical::down_bow_sequence& technical::
  down_bow () const
  {
    return this->down_bow_;
  }

  technical::down_bow_sequence& technical::
  down_bow ()
  {
    return this->down_bow_;
  }

  void technical::
  down_bow (const down_bow_sequence& s)
  {
    this->down_bow_ = s;
  }

  const technical::harmonic_sequence& technical::
  harmonic () const
  {
    return this->harmonic_;
  }

  technical::harmonic_sequence& technical::
  harmonic ()
  {
    return this->harmonic_;
  }

  void technical::
  harmonic (const harmonic_sequence& s)
  {
    this->harmonic_ = s;
  }

  const technical::open_string_sequence& technical::
  open_string () const
  {
    return this->open_string_;
  }

  technical::open_string_sequence& technical::
  open_string ()
  {
    return this->open_string_;
  }

  void technical::
  open_string (const open_string_sequence& s)
  {
    this->open_string_ = s;
  }

  const technical::thumb_position_sequence& technical::
  thumb_position () const
  {
    return this->thumb_position_;
  }

  technical::thumb_position_sequence& technical::
  thumb_position ()
  {
    return this->thumb_position_;
  }

  void technical::
  thumb_position (const thumb_position_sequence& s)
  {
    this->thumb_position_ = s;
  }

  const technical::fingering_sequence& technical::
  fingering () const
  {
    return this->fingering_;
  }

  technical::fingering_sequence& technical::
  fingering ()
  {
    return this->fingering_;
  }

  void technical::
  fingering (const fingering_sequence& s)
  {
    this->fingering_ = s;
  }

  const technical::pluck_sequence& technical::
  pluck () const
  {
    return this->pluck_;
  }

  technical::pluck_sequence& technical::
  pluck ()
  {
    return this->pluck_;
  }

  void technical::
  pluck (const pluck_sequence& s)
  {
    this->pluck_ = s;
  }

  const technical::double_tongue_sequence& technical::
  double_tongue () const
  {
    return this->double_tongue_;
  }

  technical::double_tongue_sequence& technical::
  double_tongue ()
  {
    return this->double_tongue_;
  }

  void technical::
  double_tongue (const double_tongue_sequence& s)
  {
    this->double_tongue_ = s;
  }

  const technical::triple_tongue_sequence& technical::
  triple_tongue () const
  {
    return this->triple_tongue_;
  }

  technical::triple_tongue_sequence& technical::
  triple_tongue ()
  {
    return this->triple_tongue_;
  }

  void technical::
  triple_tongue (const triple_tongue_sequence& s)
  {
    this->triple_tongue_ = s;
  }

  const technical::stopped_sequence& technical::
  stopped () const
  {
    return this->stopped_;
  }

  technical::stopped_sequence& technical::
  stopped ()
  {
    return this->stopped_;
  }

  void technical::
  stopped (const stopped_sequence& s)
  {
    this->stopped_ = s;
  }

  const technical::snap_pizzicato_sequence& technical::
  snap_pizzicato () const
  {
    return this->snap_pizzicato_;
  }

  technical::snap_pizzicato_sequence& technical::
  snap_pizzicato ()
  {
    return this->snap_pizzicato_;
  }

  void technical::
  snap_pizzicato (const snap_pizzicato_sequence& s)
  {
    this->snap_pizzicato_ = s;
  }

  const technical::fret_sequence& technical::
  fret () const
  {
    return this->fret_;
  }

  technical::fret_sequence& technical::
  fret ()
  {
    return this->fret_;
  }

  void technical::
  fret (const fret_sequence& s)
  {
    this->fret_ = s;
  }

  const technical::string_sequence& technical::
  string () const
  {
    return this->string_;
  }

  technical::string_sequence& technical::
  string ()
  {
    return this->string_;
  }

  void technical::
  string (const string_sequence& s)
  {
    this->string_ = s;
  }

  const technical::hammer_on_sequence& technical::
  hammer_on () const
  {
    return this->hammer_on_;
  }

  technical::hammer_on_sequence& technical::
  hammer_on ()
  {
    return this->hammer_on_;
  }

  void technical::
  hammer_on (const hammer_on_sequence& s)
  {
    this->hammer_on_ = s;
  }

  const technical::pull_off_sequence& technical::
  pull_off () const
  {
    return this->pull_off_;
  }

  technical::pull_off_sequence& technical::
  pull_off ()
  {
    return this->pull_off_;
  }

  void technical::
  pull_off (const pull_off_sequence& s)
  {
    this->pull_off_ = s;
  }

  const technical::bend_sequence& technical::
  bend () const
  {
    return this->bend_;
  }

  technical::bend_sequence& technical::
  bend ()
  {
    return this->bend_;
  }

  void technical::
  bend (const bend_sequence& s)
  {
    this->bend_ = s;
  }

  const technical::tap_sequence& technical::
  tap () const
  {
    return this->tap_;
  }

  technical::tap_sequence& technical::
  tap ()
  {
    return this->tap_;
  }

  void technical::
  tap (const tap_sequence& s)
  {
    this->tap_ = s;
  }

  const technical::heel_sequence& technical::
  heel () const
  {
    return this->heel_;
  }

  technical::heel_sequence& technical::
  heel ()
  {
    return this->heel_;
  }

  void technical::
  heel (const heel_sequence& s)
  {
    this->heel_ = s;
  }

  const technical::toe_sequence& technical::
  toe () const
  {
    return this->toe_;
  }

  technical::toe_sequence& technical::
  toe ()
  {
    return this->toe_;
  }

  void technical::
  toe (const toe_sequence& s)
  {
    this->toe_ = s;
  }

  const technical::fingernails_sequence& technical::
  fingernails () const
  {
    return this->fingernails_;
  }

  technical::fingernails_sequence& technical::
  fingernails ()
  {
    return this->fingernails_;
  }

  void technical::
  fingernails (const fingernails_sequence& s)
  {
    this->fingernails_ = s;
  }

  const technical::hole_sequence& technical::
  hole () const
  {
    return this->hole_;
  }

  technical::hole_sequence& technical::
  hole ()
  {
    return this->hole_;
  }

  void technical::
  hole (const hole_sequence& s)
  {
    this->hole_ = s;
  }

  const technical::arrow_sequence& technical::
  arrow () const
  {
    return this->arrow_;
  }

  technical::arrow_sequence& technical::
  arrow ()
  {
    return this->arrow_;
  }

  void technical::
  arrow (const arrow_sequence& s)
  {
    this->arrow_ = s;
  }

  const technical::handbell_sequence& technical::
  handbell () const
  {
    return this->handbell_;
  }

  technical::handbell_sequence& technical::
  handbell ()
  {
    return this->handbell_;
  }

  void technical::
  handbell (const handbell_sequence& s)
  {
    this->handbell_ = s;
  }

  const technical::brass_bend_sequence& technical::
  brass_bend () const
  {
    return this->brass_bend_;
  }

  technical::brass_bend_sequence& technical::
  brass_bend ()
  {
    return this->brass_bend_;
  }

  void technical::
  brass_bend (const brass_bend_sequence& s)
  {
    this->brass_bend_ = s;
  }

  const technical::flip_sequence& technical::
  flip () const
  {
    return this->flip_;
  }

  technical::flip_sequence& technical::
  flip ()
  {
    return this->flip_;
  }

  void technical::
  flip (const flip_sequence& s)
  {
    this->flip_ = s;
  }

  const technical::smear_sequence& technical::
  smear () const
  {
    return this->smear_;
  }

  technical::smear_sequence& technical::
  smear ()
  {
    return this->smear_;
  }

  void technical::
  smear (const smear_sequence& s)
  {
    this->smear_ = s;
  }

  const technical::open_sequence& technical::
  open () const
  {
    return this->open_;
  }

  technical::open_sequence& technical::
  open ()
  {
    return this->open_;
  }

  void technical::
  open (const open_sequence& s)
  {
    this->open_ = s;
  }

  const technical::half_muted_sequence& technical::
  half_muted () const
  {
    return this->half_muted_;
  }

  technical::half_muted_sequence& technical::
  half_muted ()
  {
    return this->half_muted_;
  }

  void technical::
  half_muted (const half_muted_sequence& s)
  {
    this->half_muted_ = s;
  }

  const technical::harmon_mute_sequence& technical::
  harmon_mute () const
  {
    return this->harmon_mute_;
  }

  technical::harmon_mute_sequence& technical::
  harmon_mute ()
  {
    return this->harmon_mute_;
  }

  void technical::
  harmon_mute (const harmon_mute_sequence& s)
  {
    this->harmon_mute_ = s;
  }

  const technical::golpe_sequence& technical::
  golpe () const
  {
    return this->golpe_;
  }

  technical::golpe_sequence& technical::
  golpe ()
  {
    return this->golpe_;
  }

  void technical::
  golpe (const golpe_sequence& s)
  {
    this->golpe_ = s;
  }

  const technical::other_technical_sequence& technical::
  other_technical () const
  {
    return this->other_technical_;
  }

  technical::other_technical_sequence& technical::
  other_technical ()
  {
    return this->other_technical_;
  }

  void technical::
  other_technical (const other_technical_sequence& s)
  {
    this->other_technical_ = s;
  }

  const technical::id_optional& technical::
  id () const
  {
    return this->id_;
  }

  technical::id_optional& technical::
  id ()
  {
    return this->id_;
  }

  void technical::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void technical::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void technical::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // text_element_data
  // 

  const text_element_data::font_family_optional& text_element_data::
  font_family () const
  {
    return this->font_family_;
  }

  text_element_data::font_family_optional& text_element_data::
  font_family ()
  {
    return this->font_family_;
  }

  void text_element_data::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void text_element_data::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void text_element_data::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const text_element_data::font_style_optional& text_element_data::
  font_style () const
  {
    return this->font_style_;
  }

  text_element_data::font_style_optional& text_element_data::
  font_style ()
  {
    return this->font_style_;
  }

  void text_element_data::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void text_element_data::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void text_element_data::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const text_element_data::font_size_optional& text_element_data::
  font_size () const
  {
    return this->font_size_;
  }

  text_element_data::font_size_optional& text_element_data::
  font_size ()
  {
    return this->font_size_;
  }

  void text_element_data::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void text_element_data::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void text_element_data::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const text_element_data::font_weight_optional& text_element_data::
  font_weight () const
  {
    return this->font_weight_;
  }

  text_element_data::font_weight_optional& text_element_data::
  font_weight ()
  {
    return this->font_weight_;
  }

  void text_element_data::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void text_element_data::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void text_element_data::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const text_element_data::color_optional& text_element_data::
  color () const
  {
    return this->color_;
  }

  text_element_data::color_optional& text_element_data::
  color ()
  {
    return this->color_;
  }

  void text_element_data::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void text_element_data::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void text_element_data::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const text_element_data::underline_optional& text_element_data::
  underline () const
  {
    return this->underline_;
  }

  text_element_data::underline_optional& text_element_data::
  underline ()
  {
    return this->underline_;
  }

  void text_element_data::
  underline (const underline_type& x)
  {
    this->underline_.set (x);
  }

  void text_element_data::
  underline (const underline_optional& x)
  {
    this->underline_ = x;
  }

  void text_element_data::
  underline (::std::unique_ptr< underline_type > x)
  {
    this->underline_.set (std::move (x));
  }

  const text_element_data::overline_optional& text_element_data::
  overline () const
  {
    return this->overline_;
  }

  text_element_data::overline_optional& text_element_data::
  overline ()
  {
    return this->overline_;
  }

  void text_element_data::
  overline (const overline_type& x)
  {
    this->overline_.set (x);
  }

  void text_element_data::
  overline (const overline_optional& x)
  {
    this->overline_ = x;
  }

  void text_element_data::
  overline (::std::unique_ptr< overline_type > x)
  {
    this->overline_.set (std::move (x));
  }

  const text_element_data::line_through_optional& text_element_data::
  line_through () const
  {
    return this->line_through_;
  }

  text_element_data::line_through_optional& text_element_data::
  line_through ()
  {
    return this->line_through_;
  }

  void text_element_data::
  line_through (const line_through_type& x)
  {
    this->line_through_.set (x);
  }

  void text_element_data::
  line_through (const line_through_optional& x)
  {
    this->line_through_ = x;
  }

  void text_element_data::
  line_through (::std::unique_ptr< line_through_type > x)
  {
    this->line_through_.set (std::move (x));
  }

  const text_element_data::rotation_optional& text_element_data::
  rotation () const
  {
    return this->rotation_;
  }

  text_element_data::rotation_optional& text_element_data::
  rotation ()
  {
    return this->rotation_;
  }

  void text_element_data::
  rotation (const rotation_type& x)
  {
    this->rotation_.set (x);
  }

  void text_element_data::
  rotation (const rotation_optional& x)
  {
    this->rotation_ = x;
  }

  void text_element_data::
  rotation (::std::unique_ptr< rotation_type > x)
  {
    this->rotation_.set (std::move (x));
  }

  const text_element_data::letter_spacing_optional& text_element_data::
  letter_spacing () const
  {
    return this->letter_spacing_;
  }

  text_element_data::letter_spacing_optional& text_element_data::
  letter_spacing ()
  {
    return this->letter_spacing_;
  }

  void text_element_data::
  letter_spacing (const letter_spacing_type& x)
  {
    this->letter_spacing_.set (x);
  }

  void text_element_data::
  letter_spacing (const letter_spacing_optional& x)
  {
    this->letter_spacing_ = x;
  }

  void text_element_data::
  letter_spacing (::std::unique_ptr< letter_spacing_type > x)
  {
    this->letter_spacing_.set (std::move (x));
  }

  const text_element_data::lang_optional& text_element_data::
  lang () const
  {
    return this->lang_;
  }

  text_element_data::lang_optional& text_element_data::
  lang ()
  {
    return this->lang_;
  }

  void text_element_data::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void text_element_data::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void text_element_data::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }

  const text_element_data::dir_optional& text_element_data::
  dir () const
  {
    return this->dir_;
  }

  text_element_data::dir_optional& text_element_data::
  dir ()
  {
    return this->dir_;
  }

  void text_element_data::
  dir (const dir_type& x)
  {
    this->dir_.set (x);
  }

  void text_element_data::
  dir (const dir_optional& x)
  {
    this->dir_ = x;
  }

  void text_element_data::
  dir (::std::unique_ptr< dir_type > x)
  {
    this->dir_.set (std::move (x));
  }


  // tie
  // 

  const tie::type_type& tie::
  type () const
  {
    return this->type_.get ();
  }

  tie::type_type& tie::
  type ()
  {
    return this->type_.get ();
  }

  void tie::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tie::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const tie::time_only_optional& tie::
  time_only () const
  {
    return this->time_only_;
  }

  tie::time_only_optional& tie::
  time_only ()
  {
    return this->time_only_;
  }

  void tie::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void tie::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void tie::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }


  // tied
  // 

  const tied::type_type& tied::
  type () const
  {
    return this->type_.get ();
  }

  tied::type_type& tied::
  type ()
  {
    return this->type_.get ();
  }

  void tied::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tied::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const tied::number_optional& tied::
  number () const
  {
    return this->number_;
  }

  tied::number_optional& tied::
  number ()
  {
    return this->number_;
  }

  void tied::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void tied::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void tied::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const tied::line_type_optional& tied::
  line_type () const
  {
    return this->line_type_;
  }

  tied::line_type_optional& tied::
  line_type ()
  {
    return this->line_type_;
  }

  void tied::
  line_type (const line_type_type& x)
  {
    this->line_type_.set (x);
  }

  void tied::
  line_type (const line_type_optional& x)
  {
    this->line_type_ = x;
  }

  void tied::
  line_type (::std::unique_ptr< line_type_type > x)
  {
    this->line_type_.set (std::move (x));
  }

  const tied::dash_length_optional& tied::
  dash_length () const
  {
    return this->dash_length_;
  }

  tied::dash_length_optional& tied::
  dash_length ()
  {
    return this->dash_length_;
  }

  void tied::
  dash_length (const dash_length_type& x)
  {
    this->dash_length_.set (x);
  }

  void tied::
  dash_length (const dash_length_optional& x)
  {
    this->dash_length_ = x;
  }

  void tied::
  dash_length (::std::unique_ptr< dash_length_type > x)
  {
    this->dash_length_.set (std::move (x));
  }

  const tied::space_length_optional& tied::
  space_length () const
  {
    return this->space_length_;
  }

  tied::space_length_optional& tied::
  space_length ()
  {
    return this->space_length_;
  }

  void tied::
  space_length (const space_length_type& x)
  {
    this->space_length_.set (x);
  }

  void tied::
  space_length (const space_length_optional& x)
  {
    this->space_length_ = x;
  }

  void tied::
  space_length (::std::unique_ptr< space_length_type > x)
  {
    this->space_length_.set (std::move (x));
  }

  const tied::default_x_optional& tied::
  default_x () const
  {
    return this->default_x_;
  }

  tied::default_x_optional& tied::
  default_x ()
  {
    return this->default_x_;
  }

  void tied::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void tied::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void tied::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const tied::default_y_optional& tied::
  default_y () const
  {
    return this->default_y_;
  }

  tied::default_y_optional& tied::
  default_y ()
  {
    return this->default_y_;
  }

  void tied::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void tied::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void tied::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const tied::relative_x_optional& tied::
  relative_x () const
  {
    return this->relative_x_;
  }

  tied::relative_x_optional& tied::
  relative_x ()
  {
    return this->relative_x_;
  }

  void tied::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void tied::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void tied::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const tied::relative_y_optional& tied::
  relative_y () const
  {
    return this->relative_y_;
  }

  tied::relative_y_optional& tied::
  relative_y ()
  {
    return this->relative_y_;
  }

  void tied::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void tied::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void tied::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const tied::placement_optional& tied::
  placement () const
  {
    return this->placement_;
  }

  tied::placement_optional& tied::
  placement ()
  {
    return this->placement_;
  }

  void tied::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void tied::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void tied::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const tied::orientation_optional& tied::
  orientation () const
  {
    return this->orientation_;
  }

  tied::orientation_optional& tied::
  orientation ()
  {
    return this->orientation_;
  }

  void tied::
  orientation (const orientation_type& x)
  {
    this->orientation_.set (x);
  }

  void tied::
  orientation (const orientation_optional& x)
  {
    this->orientation_ = x;
  }

  void tied::
  orientation (::std::unique_ptr< orientation_type > x)
  {
    this->orientation_.set (std::move (x));
  }

  const tied::bezier_x_optional& tied::
  bezier_x () const
  {
    return this->bezier_x_;
  }

  tied::bezier_x_optional& tied::
  bezier_x ()
  {
    return this->bezier_x_;
  }

  void tied::
  bezier_x (const bezier_x_type& x)
  {
    this->bezier_x_.set (x);
  }

  void tied::
  bezier_x (const bezier_x_optional& x)
  {
    this->bezier_x_ = x;
  }

  void tied::
  bezier_x (::std::unique_ptr< bezier_x_type > x)
  {
    this->bezier_x_.set (std::move (x));
  }

  const tied::bezier_y_optional& tied::
  bezier_y () const
  {
    return this->bezier_y_;
  }

  tied::bezier_y_optional& tied::
  bezier_y ()
  {
    return this->bezier_y_;
  }

  void tied::
  bezier_y (const bezier_y_type& x)
  {
    this->bezier_y_.set (x);
  }

  void tied::
  bezier_y (const bezier_y_optional& x)
  {
    this->bezier_y_ = x;
  }

  void tied::
  bezier_y (::std::unique_ptr< bezier_y_type > x)
  {
    this->bezier_y_.set (std::move (x));
  }

  const tied::bezier_x2_optional& tied::
  bezier_x2 () const
  {
    return this->bezier_x2_;
  }

  tied::bezier_x2_optional& tied::
  bezier_x2 ()
  {
    return this->bezier_x2_;
  }

  void tied::
  bezier_x2 (const bezier_x2_type& x)
  {
    this->bezier_x2_.set (x);
  }

  void tied::
  bezier_x2 (const bezier_x2_optional& x)
  {
    this->bezier_x2_ = x;
  }

  void tied::
  bezier_x2 (::std::unique_ptr< bezier_x2_type > x)
  {
    this->bezier_x2_.set (std::move (x));
  }

  const tied::bezier_y2_optional& tied::
  bezier_y2 () const
  {
    return this->bezier_y2_;
  }

  tied::bezier_y2_optional& tied::
  bezier_y2 ()
  {
    return this->bezier_y2_;
  }

  void tied::
  bezier_y2 (const bezier_y2_type& x)
  {
    this->bezier_y2_.set (x);
  }

  void tied::
  bezier_y2 (const bezier_y2_optional& x)
  {
    this->bezier_y2_ = x;
  }

  void tied::
  bezier_y2 (::std::unique_ptr< bezier_y2_type > x)
  {
    this->bezier_y2_.set (std::move (x));
  }

  const tied::bezier_offset_optional& tied::
  bezier_offset () const
  {
    return this->bezier_offset_;
  }

  tied::bezier_offset_optional& tied::
  bezier_offset ()
  {
    return this->bezier_offset_;
  }

  void tied::
  bezier_offset (const bezier_offset_type& x)
  {
    this->bezier_offset_.set (x);
  }

  void tied::
  bezier_offset (const bezier_offset_optional& x)
  {
    this->bezier_offset_ = x;
  }

  void tied::
  bezier_offset (::std::unique_ptr< bezier_offset_type > x)
  {
    this->bezier_offset_.set (std::move (x));
  }

  const tied::bezier_offset2_optional& tied::
  bezier_offset2 () const
  {
    return this->bezier_offset2_;
  }

  tied::bezier_offset2_optional& tied::
  bezier_offset2 ()
  {
    return this->bezier_offset2_;
  }

  void tied::
  bezier_offset2 (const bezier_offset2_type& x)
  {
    this->bezier_offset2_.set (x);
  }

  void tied::
  bezier_offset2 (const bezier_offset2_optional& x)
  {
    this->bezier_offset2_ = x;
  }

  void tied::
  bezier_offset2 (::std::unique_ptr< bezier_offset2_type > x)
  {
    this->bezier_offset2_.set (std::move (x));
  }

  const tied::color_optional& tied::
  color () const
  {
    return this->color_;
  }

  tied::color_optional& tied::
  color ()
  {
    return this->color_;
  }

  void tied::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tied::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tied::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const tied::id_optional& tied::
  id () const
  {
    return this->id_;
  }

  tied::id_optional& tied::
  id ()
  {
    return this->id_;
  }

  void tied::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void tied::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void tied::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // tremolo
  // 

  const tremolo::type_type& tremolo::
  type () const
  {
    return this->type_.get ();
  }

  tremolo::type_type& tremolo::
  type ()
  {
    return this->type_.get ();
  }

  void tremolo::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tremolo::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const tremolo::type_type& tremolo::
  type_default_value ()
  {
    return type_default_value_;
  }

  const tremolo::default_x_optional& tremolo::
  default_x () const
  {
    return this->default_x_;
  }

  tremolo::default_x_optional& tremolo::
  default_x ()
  {
    return this->default_x_;
  }

  void tremolo::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void tremolo::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void tremolo::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const tremolo::default_y_optional& tremolo::
  default_y () const
  {
    return this->default_y_;
  }

  tremolo::default_y_optional& tremolo::
  default_y ()
  {
    return this->default_y_;
  }

  void tremolo::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void tremolo::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void tremolo::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const tremolo::relative_x_optional& tremolo::
  relative_x () const
  {
    return this->relative_x_;
  }

  tremolo::relative_x_optional& tremolo::
  relative_x ()
  {
    return this->relative_x_;
  }

  void tremolo::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void tremolo::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void tremolo::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const tremolo::relative_y_optional& tremolo::
  relative_y () const
  {
    return this->relative_y_;
  }

  tremolo::relative_y_optional& tremolo::
  relative_y ()
  {
    return this->relative_y_;
  }

  void tremolo::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void tremolo::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void tremolo::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const tremolo::font_family_optional& tremolo::
  font_family () const
  {
    return this->font_family_;
  }

  tremolo::font_family_optional& tremolo::
  font_family ()
  {
    return this->font_family_;
  }

  void tremolo::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void tremolo::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void tremolo::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const tremolo::font_style_optional& tremolo::
  font_style () const
  {
    return this->font_style_;
  }

  tremolo::font_style_optional& tremolo::
  font_style ()
  {
    return this->font_style_;
  }

  void tremolo::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void tremolo::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void tremolo::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const tremolo::font_size_optional& tremolo::
  font_size () const
  {
    return this->font_size_;
  }

  tremolo::font_size_optional& tremolo::
  font_size ()
  {
    return this->font_size_;
  }

  void tremolo::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void tremolo::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void tremolo::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const tremolo::font_weight_optional& tremolo::
  font_weight () const
  {
    return this->font_weight_;
  }

  tremolo::font_weight_optional& tremolo::
  font_weight ()
  {
    return this->font_weight_;
  }

  void tremolo::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void tremolo::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void tremolo::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const tremolo::color_optional& tremolo::
  color () const
  {
    return this->color_;
  }

  tremolo::color_optional& tremolo::
  color ()
  {
    return this->color_;
  }

  void tremolo::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tremolo::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tremolo::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const tremolo::placement_optional& tremolo::
  placement () const
  {
    return this->placement_;
  }

  tremolo::placement_optional& tremolo::
  placement ()
  {
    return this->placement_;
  }

  void tremolo::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void tremolo::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void tremolo::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const tremolo::smufl_optional& tremolo::
  smufl () const
  {
    return this->smufl_;
  }

  tremolo::smufl_optional& tremolo::
  smufl ()
  {
    return this->smufl_;
  }

  void tremolo::
  smufl (const smufl_type& x)
  {
    this->smufl_.set (x);
  }

  void tremolo::
  smufl (const smufl_optional& x)
  {
    this->smufl_ = x;
  }

  void tremolo::
  smufl (::std::unique_ptr< smufl_type > x)
  {
    this->smufl_.set (std::move (x));
  }


  // tuplet
  // 

  const tuplet::tuplet_actual_optional& tuplet::
  tuplet_actual () const
  {
    return this->tuplet_actual_;
  }

  tuplet::tuplet_actual_optional& tuplet::
  tuplet_actual ()
  {
    return this->tuplet_actual_;
  }

  void tuplet::
  tuplet_actual (const tuplet_actual_type& x)
  {
    this->tuplet_actual_.set (x);
  }

  void tuplet::
  tuplet_actual (const tuplet_actual_optional& x)
  {
    this->tuplet_actual_ = x;
  }

  void tuplet::
  tuplet_actual (::std::unique_ptr< tuplet_actual_type > x)
  {
    this->tuplet_actual_.set (std::move (x));
  }

  const tuplet::tuplet_normal_optional& tuplet::
  tuplet_normal () const
  {
    return this->tuplet_normal_;
  }

  tuplet::tuplet_normal_optional& tuplet::
  tuplet_normal ()
  {
    return this->tuplet_normal_;
  }

  void tuplet::
  tuplet_normal (const tuplet_normal_type& x)
  {
    this->tuplet_normal_.set (x);
  }

  void tuplet::
  tuplet_normal (const tuplet_normal_optional& x)
  {
    this->tuplet_normal_ = x;
  }

  void tuplet::
  tuplet_normal (::std::unique_ptr< tuplet_normal_type > x)
  {
    this->tuplet_normal_.set (std::move (x));
  }

  const tuplet::type_type& tuplet::
  type () const
  {
    return this->type_.get ();
  }

  tuplet::type_type& tuplet::
  type ()
  {
    return this->type_.get ();
  }

  void tuplet::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void tuplet::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const tuplet::number_optional& tuplet::
  number () const
  {
    return this->number_;
  }

  tuplet::number_optional& tuplet::
  number ()
  {
    return this->number_;
  }

  void tuplet::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void tuplet::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void tuplet::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const tuplet::bracket_optional& tuplet::
  bracket () const
  {
    return this->bracket_;
  }

  tuplet::bracket_optional& tuplet::
  bracket ()
  {
    return this->bracket_;
  }

  void tuplet::
  bracket (const bracket_type& x)
  {
    this->bracket_.set (x);
  }

  void tuplet::
  bracket (const bracket_optional& x)
  {
    this->bracket_ = x;
  }

  void tuplet::
  bracket (::std::unique_ptr< bracket_type > x)
  {
    this->bracket_.set (std::move (x));
  }

  const tuplet::show_number_optional& tuplet::
  show_number () const
  {
    return this->show_number_;
  }

  tuplet::show_number_optional& tuplet::
  show_number ()
  {
    return this->show_number_;
  }

  void tuplet::
  show_number (const show_number_type& x)
  {
    this->show_number_.set (x);
  }

  void tuplet::
  show_number (const show_number_optional& x)
  {
    this->show_number_ = x;
  }

  void tuplet::
  show_number (::std::unique_ptr< show_number_type > x)
  {
    this->show_number_.set (std::move (x));
  }

  const tuplet::show_type_optional& tuplet::
  show_type () const
  {
    return this->show_type_;
  }

  tuplet::show_type_optional& tuplet::
  show_type ()
  {
    return this->show_type_;
  }

  void tuplet::
  show_type (const show_type_type& x)
  {
    this->show_type_.set (x);
  }

  void tuplet::
  show_type (const show_type_optional& x)
  {
    this->show_type_ = x;
  }

  void tuplet::
  show_type (::std::unique_ptr< show_type_type > x)
  {
    this->show_type_.set (std::move (x));
  }

  const tuplet::line_shape_optional& tuplet::
  line_shape () const
  {
    return this->line_shape_;
  }

  tuplet::line_shape_optional& tuplet::
  line_shape ()
  {
    return this->line_shape_;
  }

  void tuplet::
  line_shape (const line_shape_type& x)
  {
    this->line_shape_.set (x);
  }

  void tuplet::
  line_shape (const line_shape_optional& x)
  {
    this->line_shape_ = x;
  }

  void tuplet::
  line_shape (::std::unique_ptr< line_shape_type > x)
  {
    this->line_shape_.set (std::move (x));
  }

  const tuplet::default_x_optional& tuplet::
  default_x () const
  {
    return this->default_x_;
  }

  tuplet::default_x_optional& tuplet::
  default_x ()
  {
    return this->default_x_;
  }

  void tuplet::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void tuplet::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void tuplet::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const tuplet::default_y_optional& tuplet::
  default_y () const
  {
    return this->default_y_;
  }

  tuplet::default_y_optional& tuplet::
  default_y ()
  {
    return this->default_y_;
  }

  void tuplet::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void tuplet::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void tuplet::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const tuplet::relative_x_optional& tuplet::
  relative_x () const
  {
    return this->relative_x_;
  }

  tuplet::relative_x_optional& tuplet::
  relative_x ()
  {
    return this->relative_x_;
  }

  void tuplet::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void tuplet::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void tuplet::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const tuplet::relative_y_optional& tuplet::
  relative_y () const
  {
    return this->relative_y_;
  }

  tuplet::relative_y_optional& tuplet::
  relative_y ()
  {
    return this->relative_y_;
  }

  void tuplet::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void tuplet::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void tuplet::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const tuplet::placement_optional& tuplet::
  placement () const
  {
    return this->placement_;
  }

  tuplet::placement_optional& tuplet::
  placement ()
  {
    return this->placement_;
  }

  void tuplet::
  placement (const placement_type& x)
  {
    this->placement_.set (x);
  }

  void tuplet::
  placement (const placement_optional& x)
  {
    this->placement_ = x;
  }

  void tuplet::
  placement (::std::unique_ptr< placement_type > x)
  {
    this->placement_.set (std::move (x));
  }

  const tuplet::id_optional& tuplet::
  id () const
  {
    return this->id_;
  }

  tuplet::id_optional& tuplet::
  id ()
  {
    return this->id_;
  }

  void tuplet::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void tuplet::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void tuplet::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // tuplet_dot
  // 

  const tuplet_dot::font_family_optional& tuplet_dot::
  font_family () const
  {
    return this->font_family_;
  }

  tuplet_dot::font_family_optional& tuplet_dot::
  font_family ()
  {
    return this->font_family_;
  }

  void tuplet_dot::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void tuplet_dot::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void tuplet_dot::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const tuplet_dot::font_style_optional& tuplet_dot::
  font_style () const
  {
    return this->font_style_;
  }

  tuplet_dot::font_style_optional& tuplet_dot::
  font_style ()
  {
    return this->font_style_;
  }

  void tuplet_dot::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void tuplet_dot::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void tuplet_dot::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const tuplet_dot::font_size_optional& tuplet_dot::
  font_size () const
  {
    return this->font_size_;
  }

  tuplet_dot::font_size_optional& tuplet_dot::
  font_size ()
  {
    return this->font_size_;
  }

  void tuplet_dot::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void tuplet_dot::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void tuplet_dot::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const tuplet_dot::font_weight_optional& tuplet_dot::
  font_weight () const
  {
    return this->font_weight_;
  }

  tuplet_dot::font_weight_optional& tuplet_dot::
  font_weight ()
  {
    return this->font_weight_;
  }

  void tuplet_dot::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void tuplet_dot::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void tuplet_dot::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const tuplet_dot::color_optional& tuplet_dot::
  color () const
  {
    return this->color_;
  }

  tuplet_dot::color_optional& tuplet_dot::
  color ()
  {
    return this->color_;
  }

  void tuplet_dot::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tuplet_dot::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tuplet_dot::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // tuplet_number
  // 

  const tuplet_number::font_family_optional& tuplet_number::
  font_family () const
  {
    return this->font_family_;
  }

  tuplet_number::font_family_optional& tuplet_number::
  font_family ()
  {
    return this->font_family_;
  }

  void tuplet_number::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void tuplet_number::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void tuplet_number::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const tuplet_number::font_style_optional& tuplet_number::
  font_style () const
  {
    return this->font_style_;
  }

  tuplet_number::font_style_optional& tuplet_number::
  font_style ()
  {
    return this->font_style_;
  }

  void tuplet_number::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void tuplet_number::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void tuplet_number::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const tuplet_number::font_size_optional& tuplet_number::
  font_size () const
  {
    return this->font_size_;
  }

  tuplet_number::font_size_optional& tuplet_number::
  font_size ()
  {
    return this->font_size_;
  }

  void tuplet_number::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void tuplet_number::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void tuplet_number::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const tuplet_number::font_weight_optional& tuplet_number::
  font_weight () const
  {
    return this->font_weight_;
  }

  tuplet_number::font_weight_optional& tuplet_number::
  font_weight ()
  {
    return this->font_weight_;
  }

  void tuplet_number::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void tuplet_number::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void tuplet_number::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const tuplet_number::color_optional& tuplet_number::
  color () const
  {
    return this->color_;
  }

  tuplet_number::color_optional& tuplet_number::
  color ()
  {
    return this->color_;
  }

  void tuplet_number::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tuplet_number::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tuplet_number::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // tuplet_portion
  // 

  const tuplet_portion::tuplet_number_optional& tuplet_portion::
  tuplet_number () const
  {
    return this->tuplet_number_;
  }

  tuplet_portion::tuplet_number_optional& tuplet_portion::
  tuplet_number ()
  {
    return this->tuplet_number_;
  }

  void tuplet_portion::
  tuplet_number (const tuplet_number_type& x)
  {
    this->tuplet_number_.set (x);
  }

  void tuplet_portion::
  tuplet_number (const tuplet_number_optional& x)
  {
    this->tuplet_number_ = x;
  }

  void tuplet_portion::
  tuplet_number (::std::unique_ptr< tuplet_number_type > x)
  {
    this->tuplet_number_.set (std::move (x));
  }

  const tuplet_portion::tuplet_type_optional& tuplet_portion::
  tuplet_type () const
  {
    return this->tuplet_type_;
  }

  tuplet_portion::tuplet_type_optional& tuplet_portion::
  tuplet_type ()
  {
    return this->tuplet_type_;
  }

  void tuplet_portion::
  tuplet_type (const tuplet_type_type& x)
  {
    this->tuplet_type_.set (x);
  }

  void tuplet_portion::
  tuplet_type (const tuplet_type_optional& x)
  {
    this->tuplet_type_ = x;
  }

  void tuplet_portion::
  tuplet_type (::std::unique_ptr< tuplet_type_type > x)
  {
    this->tuplet_type_.set (std::move (x));
  }

  const tuplet_portion::tuplet_dot_sequence& tuplet_portion::
  tuplet_dot () const
  {
    return this->tuplet_dot_;
  }

  tuplet_portion::tuplet_dot_sequence& tuplet_portion::
  tuplet_dot ()
  {
    return this->tuplet_dot_;
  }

  void tuplet_portion::
  tuplet_dot (const tuplet_dot_sequence& s)
  {
    this->tuplet_dot_ = s;
  }


  // tuplet_type
  // 

  const tuplet_type::font_family_optional& tuplet_type::
  font_family () const
  {
    return this->font_family_;
  }

  tuplet_type::font_family_optional& tuplet_type::
  font_family ()
  {
    return this->font_family_;
  }

  void tuplet_type::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void tuplet_type::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void tuplet_type::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const tuplet_type::font_style_optional& tuplet_type::
  font_style () const
  {
    return this->font_style_;
  }

  tuplet_type::font_style_optional& tuplet_type::
  font_style ()
  {
    return this->font_style_;
  }

  void tuplet_type::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void tuplet_type::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void tuplet_type::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const tuplet_type::font_size_optional& tuplet_type::
  font_size () const
  {
    return this->font_size_;
  }

  tuplet_type::font_size_optional& tuplet_type::
  font_size ()
  {
    return this->font_size_;
  }

  void tuplet_type::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void tuplet_type::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void tuplet_type::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const tuplet_type::font_weight_optional& tuplet_type::
  font_weight () const
  {
    return this->font_weight_;
  }

  tuplet_type::font_weight_optional& tuplet_type::
  font_weight ()
  {
    return this->font_weight_;
  }

  void tuplet_type::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void tuplet_type::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void tuplet_type::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const tuplet_type::color_optional& tuplet_type::
  color () const
  {
    return this->color_;
  }

  tuplet_type::color_optional& tuplet_type::
  color ()
  {
    return this->color_;
  }

  void tuplet_type::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void tuplet_type::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void tuplet_type::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // unpitched
  // 

  const unpitched::display_step_optional& unpitched::
  display_step () const
  {
    return this->display_step_;
  }

  unpitched::display_step_optional& unpitched::
  display_step ()
  {
    return this->display_step_;
  }

  void unpitched::
  display_step (const display_step_type& x)
  {
    this->display_step_.set (x);
  }

  void unpitched::
  display_step (const display_step_optional& x)
  {
    this->display_step_ = x;
  }

  void unpitched::
  display_step (::std::unique_ptr< display_step_type > x)
  {
    this->display_step_.set (std::move (x));
  }

  const unpitched::display_octave_optional& unpitched::
  display_octave () const
  {
    return this->display_octave_;
  }

  unpitched::display_octave_optional& unpitched::
  display_octave ()
  {
    return this->display_octave_;
  }

  void unpitched::
  display_octave (const display_octave_type& x)
  {
    this->display_octave_.set (x);
  }

  void unpitched::
  display_octave (const display_octave_optional& x)
  {
    this->display_octave_ = x;
  }

  void unpitched::
  display_octave (::std::unique_ptr< display_octave_type > x)
  {
    this->display_octave_.set (std::move (x));
  }


  // wait
  // 

  const wait::player_optional& wait::
  player () const
  {
    return this->player_;
  }

  wait::player_optional& wait::
  player ()
  {
    return this->player_;
  }

  void wait::
  player (const player_type& x)
  {
    this->player_.set (x);
  }

  void wait::
  player (const player_optional& x)
  {
    this->player_ = x;
  }

  void wait::
  player (::std::unique_ptr< player_type > x)
  {
    this->player_.set (std::move (x));
  }

  const wait::time_only_optional& wait::
  time_only () const
  {
    return this->time_only_;
  }

  wait::time_only_optional& wait::
  time_only ()
  {
    return this->time_only_;
  }

  void wait::
  time_only (const time_only_type& x)
  {
    this->time_only_.set (x);
  }

  void wait::
  time_only (const time_only_optional& x)
  {
    this->time_only_ = x;
  }

  void wait::
  time_only (::std::unique_ptr< time_only_type > x)
  {
    this->time_only_.set (std::move (x));
  }


  // credit
  // 

  const credit::credit_type_sequence& credit::
  credit_type () const
  {
    return this->credit_type_;
  }

  credit::credit_type_sequence& credit::
  credit_type ()
  {
    return this->credit_type_;
  }

  void credit::
  credit_type (const credit_type_sequence& s)
  {
    this->credit_type_ = s;
  }

  const credit::link_sequence& credit::
  link () const
  {
    return this->link_;
  }

  credit::link_sequence& credit::
  link ()
  {
    return this->link_;
  }

  void credit::
  link (const link_sequence& s)
  {
    this->link_ = s;
  }

  const credit::bookmark_sequence& credit::
  bookmark () const
  {
    return this->bookmark_;
  }

  credit::bookmark_sequence& credit::
  bookmark ()
  {
    return this->bookmark_;
  }

  void credit::
  bookmark (const bookmark_sequence& s)
  {
    this->bookmark_ = s;
  }

  const credit::credit_image_optional& credit::
  credit_image () const
  {
    return this->credit_image_;
  }

  credit::credit_image_optional& credit::
  credit_image ()
  {
    return this->credit_image_;
  }

  void credit::
  credit_image (const credit_image_type& x)
  {
    this->credit_image_.set (x);
  }

  void credit::
  credit_image (const credit_image_optional& x)
  {
    this->credit_image_ = x;
  }

  void credit::
  credit_image (::std::unique_ptr< credit_image_type > x)
  {
    this->credit_image_.set (std::move (x));
  }

  const credit::credit_words_sequence& credit::
  credit_words () const
  {
    return this->credit_words_;
  }

  credit::credit_words_sequence& credit::
  credit_words ()
  {
    return this->credit_words_;
  }

  void credit::
  credit_words (const credit_words_sequence& s)
  {
    this->credit_words_ = s;
  }

  const credit::credit_symbol_sequence& credit::
  credit_symbol () const
  {
    return this->credit_symbol_;
  }

  credit::credit_symbol_sequence& credit::
  credit_symbol ()
  {
    return this->credit_symbol_;
  }

  void credit::
  credit_symbol (const credit_symbol_sequence& s)
  {
    this->credit_symbol_ = s;
  }

  const credit::page_optional& credit::
  page () const
  {
    return this->page_;
  }

  credit::page_optional& credit::
  page ()
  {
    return this->page_;
  }

  void credit::
  page (const page_type& x)
  {
    this->page_.set (x);
  }

  void credit::
  page (const page_optional& x)
  {
    this->page_ = x;
  }

  const credit::id_optional& credit::
  id () const
  {
    return this->id_;
  }

  credit::id_optional& credit::
  id ()
  {
    return this->id_;
  }

  void credit::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void credit::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void credit::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // defaults
  // 

  const defaults::scaling_optional& defaults::
  scaling () const
  {
    return this->scaling_;
  }

  defaults::scaling_optional& defaults::
  scaling ()
  {
    return this->scaling_;
  }

  void defaults::
  scaling (const scaling_type& x)
  {
    this->scaling_.set (x);
  }

  void defaults::
  scaling (const scaling_optional& x)
  {
    this->scaling_ = x;
  }

  void defaults::
  scaling (::std::unique_ptr< scaling_type > x)
  {
    this->scaling_.set (std::move (x));
  }

  const defaults::concert_score_optional& defaults::
  concert_score () const
  {
    return this->concert_score_;
  }

  defaults::concert_score_optional& defaults::
  concert_score ()
  {
    return this->concert_score_;
  }

  void defaults::
  concert_score (const concert_score_type& x)
  {
    this->concert_score_.set (x);
  }

  void defaults::
  concert_score (const concert_score_optional& x)
  {
    this->concert_score_ = x;
  }

  void defaults::
  concert_score (::std::unique_ptr< concert_score_type > x)
  {
    this->concert_score_.set (std::move (x));
  }

  const defaults::page_layout_optional& defaults::
  page_layout () const
  {
    return this->page_layout_;
  }

  defaults::page_layout_optional& defaults::
  page_layout ()
  {
    return this->page_layout_;
  }

  void defaults::
  page_layout (const page_layout_type& x)
  {
    this->page_layout_.set (x);
  }

  void defaults::
  page_layout (const page_layout_optional& x)
  {
    this->page_layout_ = x;
  }

  void defaults::
  page_layout (::std::unique_ptr< page_layout_type > x)
  {
    this->page_layout_.set (std::move (x));
  }

  const defaults::system_layout_optional& defaults::
  system_layout () const
  {
    return this->system_layout_;
  }

  defaults::system_layout_optional& defaults::
  system_layout ()
  {
    return this->system_layout_;
  }

  void defaults::
  system_layout (const system_layout_type& x)
  {
    this->system_layout_.set (x);
  }

  void defaults::
  system_layout (const system_layout_optional& x)
  {
    this->system_layout_ = x;
  }

  void defaults::
  system_layout (::std::unique_ptr< system_layout_type > x)
  {
    this->system_layout_.set (std::move (x));
  }

  const defaults::staff_layout_sequence& defaults::
  staff_layout () const
  {
    return this->staff_layout_;
  }

  defaults::staff_layout_sequence& defaults::
  staff_layout ()
  {
    return this->staff_layout_;
  }

  void defaults::
  staff_layout (const staff_layout_sequence& s)
  {
    this->staff_layout_ = s;
  }

  const defaults::appearance_optional& defaults::
  appearance () const
  {
    return this->appearance_;
  }

  defaults::appearance_optional& defaults::
  appearance ()
  {
    return this->appearance_;
  }

  void defaults::
  appearance (const appearance_type& x)
  {
    this->appearance_.set (x);
  }

  void defaults::
  appearance (const appearance_optional& x)
  {
    this->appearance_ = x;
  }

  void defaults::
  appearance (::std::unique_ptr< appearance_type > x)
  {
    this->appearance_.set (std::move (x));
  }

  const defaults::music_font_optional& defaults::
  music_font () const
  {
    return this->music_font_;
  }

  defaults::music_font_optional& defaults::
  music_font ()
  {
    return this->music_font_;
  }

  void defaults::
  music_font (const music_font_type& x)
  {
    this->music_font_.set (x);
  }

  void defaults::
  music_font (const music_font_optional& x)
  {
    this->music_font_ = x;
  }

  void defaults::
  music_font (::std::unique_ptr< music_font_type > x)
  {
    this->music_font_.set (std::move (x));
  }

  const defaults::word_font_optional& defaults::
  word_font () const
  {
    return this->word_font_;
  }

  defaults::word_font_optional& defaults::
  word_font ()
  {
    return this->word_font_;
  }

  void defaults::
  word_font (const word_font_type& x)
  {
    this->word_font_.set (x);
  }

  void defaults::
  word_font (const word_font_optional& x)
  {
    this->word_font_ = x;
  }

  void defaults::
  word_font (::std::unique_ptr< word_font_type > x)
  {
    this->word_font_.set (std::move (x));
  }

  const defaults::lyric_font_sequence& defaults::
  lyric_font () const
  {
    return this->lyric_font_;
  }

  defaults::lyric_font_sequence& defaults::
  lyric_font ()
  {
    return this->lyric_font_;
  }

  void defaults::
  lyric_font (const lyric_font_sequence& s)
  {
    this->lyric_font_ = s;
  }

  const defaults::lyric_language_sequence& defaults::
  lyric_language () const
  {
    return this->lyric_language_;
  }

  defaults::lyric_language_sequence& defaults::
  lyric_language ()
  {
    return this->lyric_language_;
  }

  void defaults::
  lyric_language (const lyric_language_sequence& s)
  {
    this->lyric_language_ = s;
  }


  // empty_font
  // 

  const empty_font::font_family_optional& empty_font::
  font_family () const
  {
    return this->font_family_;
  }

  empty_font::font_family_optional& empty_font::
  font_family ()
  {
    return this->font_family_;
  }

  void empty_font::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void empty_font::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void empty_font::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const empty_font::font_style_optional& empty_font::
  font_style () const
  {
    return this->font_style_;
  }

  empty_font::font_style_optional& empty_font::
  font_style ()
  {
    return this->font_style_;
  }

  void empty_font::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void empty_font::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void empty_font::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const empty_font::font_size_optional& empty_font::
  font_size () const
  {
    return this->font_size_;
  }

  empty_font::font_size_optional& empty_font::
  font_size ()
  {
    return this->font_size_;
  }

  void empty_font::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void empty_font::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void empty_font::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const empty_font::font_weight_optional& empty_font::
  font_weight () const
  {
    return this->font_weight_;
  }

  empty_font::font_weight_optional& empty_font::
  font_weight ()
  {
    return this->font_weight_;
  }

  void empty_font::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void empty_font::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void empty_font::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }


  // group_barline
  // 

  const group_barline::color_optional& group_barline::
  color () const
  {
    return this->color_;
  }

  group_barline::color_optional& group_barline::
  color ()
  {
    return this->color_;
  }

  void group_barline::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void group_barline::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void group_barline::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // group_name
  // 

  const group_name::default_x_optional& group_name::
  default_x () const
  {
    return this->default_x_;
  }

  group_name::default_x_optional& group_name::
  default_x ()
  {
    return this->default_x_;
  }

  void group_name::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void group_name::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void group_name::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const group_name::default_y_optional& group_name::
  default_y () const
  {
    return this->default_y_;
  }

  group_name::default_y_optional& group_name::
  default_y ()
  {
    return this->default_y_;
  }

  void group_name::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void group_name::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void group_name::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const group_name::relative_x_optional& group_name::
  relative_x () const
  {
    return this->relative_x_;
  }

  group_name::relative_x_optional& group_name::
  relative_x ()
  {
    return this->relative_x_;
  }

  void group_name::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void group_name::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void group_name::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const group_name::relative_y_optional& group_name::
  relative_y () const
  {
    return this->relative_y_;
  }

  group_name::relative_y_optional& group_name::
  relative_y ()
  {
    return this->relative_y_;
  }

  void group_name::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void group_name::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void group_name::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const group_name::font_family_optional& group_name::
  font_family () const
  {
    return this->font_family_;
  }

  group_name::font_family_optional& group_name::
  font_family ()
  {
    return this->font_family_;
  }

  void group_name::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void group_name::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void group_name::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const group_name::font_style_optional& group_name::
  font_style () const
  {
    return this->font_style_;
  }

  group_name::font_style_optional& group_name::
  font_style ()
  {
    return this->font_style_;
  }

  void group_name::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void group_name::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void group_name::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const group_name::font_size_optional& group_name::
  font_size () const
  {
    return this->font_size_;
  }

  group_name::font_size_optional& group_name::
  font_size ()
  {
    return this->font_size_;
  }

  void group_name::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void group_name::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void group_name::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const group_name::font_weight_optional& group_name::
  font_weight () const
  {
    return this->font_weight_;
  }

  group_name::font_weight_optional& group_name::
  font_weight ()
  {
    return this->font_weight_;
  }

  void group_name::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void group_name::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void group_name::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const group_name::color_optional& group_name::
  color () const
  {
    return this->color_;
  }

  group_name::color_optional& group_name::
  color ()
  {
    return this->color_;
  }

  void group_name::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void group_name::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void group_name::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const group_name::justify_optional& group_name::
  justify () const
  {
    return this->justify_;
  }

  group_name::justify_optional& group_name::
  justify ()
  {
    return this->justify_;
  }

  void group_name::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void group_name::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void group_name::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }


  // group_symbol
  // 

  const group_symbol::default_x_optional& group_symbol::
  default_x () const
  {
    return this->default_x_;
  }

  group_symbol::default_x_optional& group_symbol::
  default_x ()
  {
    return this->default_x_;
  }

  void group_symbol::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void group_symbol::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void group_symbol::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const group_symbol::default_y_optional& group_symbol::
  default_y () const
  {
    return this->default_y_;
  }

  group_symbol::default_y_optional& group_symbol::
  default_y ()
  {
    return this->default_y_;
  }

  void group_symbol::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void group_symbol::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void group_symbol::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const group_symbol::relative_x_optional& group_symbol::
  relative_x () const
  {
    return this->relative_x_;
  }

  group_symbol::relative_x_optional& group_symbol::
  relative_x ()
  {
    return this->relative_x_;
  }

  void group_symbol::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void group_symbol::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void group_symbol::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const group_symbol::relative_y_optional& group_symbol::
  relative_y () const
  {
    return this->relative_y_;
  }

  group_symbol::relative_y_optional& group_symbol::
  relative_y ()
  {
    return this->relative_y_;
  }

  void group_symbol::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void group_symbol::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void group_symbol::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const group_symbol::color_optional& group_symbol::
  color () const
  {
    return this->color_;
  }

  group_symbol::color_optional& group_symbol::
  color ()
  {
    return this->color_;
  }

  void group_symbol::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void group_symbol::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void group_symbol::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }


  // instrument_link
  // 

  const instrument_link::id_type& instrument_link::
  id () const
  {
    return this->id_.get ();
  }

  instrument_link::id_type& instrument_link::
  id ()
  {
    return this->id_.get ();
  }

  void instrument_link::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void instrument_link::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // lyric_font
  // 

  const lyric_font::number_optional& lyric_font::
  number () const
  {
    return this->number_;
  }

  lyric_font::number_optional& lyric_font::
  number ()
  {
    return this->number_;
  }

  void lyric_font::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void lyric_font::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void lyric_font::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const lyric_font::name_optional& lyric_font::
  name () const
  {
    return this->name_;
  }

  lyric_font::name_optional& lyric_font::
  name ()
  {
    return this->name_;
  }

  void lyric_font::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void lyric_font::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void lyric_font::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const lyric_font::font_family_optional& lyric_font::
  font_family () const
  {
    return this->font_family_;
  }

  lyric_font::font_family_optional& lyric_font::
  font_family ()
  {
    return this->font_family_;
  }

  void lyric_font::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void lyric_font::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void lyric_font::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const lyric_font::font_style_optional& lyric_font::
  font_style () const
  {
    return this->font_style_;
  }

  lyric_font::font_style_optional& lyric_font::
  font_style ()
  {
    return this->font_style_;
  }

  void lyric_font::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void lyric_font::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void lyric_font::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const lyric_font::font_size_optional& lyric_font::
  font_size () const
  {
    return this->font_size_;
  }

  lyric_font::font_size_optional& lyric_font::
  font_size ()
  {
    return this->font_size_;
  }

  void lyric_font::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void lyric_font::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void lyric_font::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const lyric_font::font_weight_optional& lyric_font::
  font_weight () const
  {
    return this->font_weight_;
  }

  lyric_font::font_weight_optional& lyric_font::
  font_weight ()
  {
    return this->font_weight_;
  }

  void lyric_font::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void lyric_font::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void lyric_font::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }


  // lyric_language
  // 

  const lyric_language::number_optional& lyric_language::
  number () const
  {
    return this->number_;
  }

  lyric_language::number_optional& lyric_language::
  number ()
  {
    return this->number_;
  }

  void lyric_language::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void lyric_language::
  number (const number_optional& x)
  {
    this->number_ = x;
  }

  void lyric_language::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const lyric_language::name_optional& lyric_language::
  name () const
  {
    return this->name_;
  }

  lyric_language::name_optional& lyric_language::
  name ()
  {
    return this->name_;
  }

  void lyric_language::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void lyric_language::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void lyric_language::
  name (::std::unique_ptr< name_type > x)
  {
    this->name_.set (std::move (x));
  }

  const lyric_language::lang_type& lyric_language::
  lang () const
  {
    return this->lang_.get ();
  }

  lyric_language::lang_type& lyric_language::
  lang ()
  {
    return this->lang_.get ();
  }

  void lyric_language::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void lyric_language::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }


  // opus
  // 

  const opus::href_type& opus::
  href () const
  {
    return this->href_.get ();
  }

  opus::href_type& opus::
  href ()
  {
    return this->href_.get ();
  }

  void opus::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void opus::
  href (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }

  const opus::type_type& opus::
  type () const
  {
    return this->type_.get ();
  }

  const opus::type_type& opus::
  type_default_value ()
  {
    return type_default_value_;
  }

  const opus::role_optional& opus::
  role () const
  {
    return this->role_;
  }

  opus::role_optional& opus::
  role ()
  {
    return this->role_;
  }

  void opus::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void opus::
  role (const role_optional& x)
  {
    this->role_ = x;
  }

  void opus::
  role (::std::unique_ptr< role_type > x)
  {
    this->role_.set (std::move (x));
  }

  const opus::title_optional& opus::
  title () const
  {
    return this->title_;
  }

  opus::title_optional& opus::
  title ()
  {
    return this->title_;
  }

  void opus::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void opus::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void opus::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const opus::show_type& opus::
  show () const
  {
    return this->show_.get ();
  }

  opus::show_type& opus::
  show ()
  {
    return this->show_.get ();
  }

  void opus::
  show (const show_type& x)
  {
    this->show_.set (x);
  }

  void opus::
  show (::std::unique_ptr< show_type > x)
  {
    this->show_.set (std::move (x));
  }

  const opus::show_type& opus::
  show_default_value ()
  {
    return show_default_value_;
  }

  const opus::actuate_type& opus::
  actuate () const
  {
    return this->actuate_.get ();
  }

  opus::actuate_type& opus::
  actuate ()
  {
    return this->actuate_.get ();
  }

  void opus::
  actuate (const actuate_type& x)
  {
    this->actuate_.set (x);
  }

  void opus::
  actuate (::std::unique_ptr< actuate_type > x)
  {
    this->actuate_.set (std::move (x));
  }

  const opus::actuate_type& opus::
  actuate_default_value ()
  {
    return actuate_default_value_;
  }


  // part_group
  // 

  const part_group::group_name_optional& part_group::
  group_name () const
  {
    return this->group_name_;
  }

  part_group::group_name_optional& part_group::
  group_name ()
  {
    return this->group_name_;
  }

  void part_group::
  group_name (const group_name_type& x)
  {
    this->group_name_.set (x);
  }

  void part_group::
  group_name (const group_name_optional& x)
  {
    this->group_name_ = x;
  }

  void part_group::
  group_name (::std::unique_ptr< group_name_type > x)
  {
    this->group_name_.set (std::move (x));
  }

  const part_group::group_name_display_optional& part_group::
  group_name_display () const
  {
    return this->group_name_display_;
  }

  part_group::group_name_display_optional& part_group::
  group_name_display ()
  {
    return this->group_name_display_;
  }

  void part_group::
  group_name_display (const group_name_display_type& x)
  {
    this->group_name_display_.set (x);
  }

  void part_group::
  group_name_display (const group_name_display_optional& x)
  {
    this->group_name_display_ = x;
  }

  void part_group::
  group_name_display (::std::unique_ptr< group_name_display_type > x)
  {
    this->group_name_display_.set (std::move (x));
  }

  const part_group::group_abbreviation_optional& part_group::
  group_abbreviation () const
  {
    return this->group_abbreviation_;
  }

  part_group::group_abbreviation_optional& part_group::
  group_abbreviation ()
  {
    return this->group_abbreviation_;
  }

  void part_group::
  group_abbreviation (const group_abbreviation_type& x)
  {
    this->group_abbreviation_.set (x);
  }

  void part_group::
  group_abbreviation (const group_abbreviation_optional& x)
  {
    this->group_abbreviation_ = x;
  }

  void part_group::
  group_abbreviation (::std::unique_ptr< group_abbreviation_type > x)
  {
    this->group_abbreviation_.set (std::move (x));
  }

  const part_group::group_abbreviation_display_optional& part_group::
  group_abbreviation_display () const
  {
    return this->group_abbreviation_display_;
  }

  part_group::group_abbreviation_display_optional& part_group::
  group_abbreviation_display ()
  {
    return this->group_abbreviation_display_;
  }

  void part_group::
  group_abbreviation_display (const group_abbreviation_display_type& x)
  {
    this->group_abbreviation_display_.set (x);
  }

  void part_group::
  group_abbreviation_display (const group_abbreviation_display_optional& x)
  {
    this->group_abbreviation_display_ = x;
  }

  void part_group::
  group_abbreviation_display (::std::unique_ptr< group_abbreviation_display_type > x)
  {
    this->group_abbreviation_display_.set (std::move (x));
  }

  const part_group::group_symbol_optional& part_group::
  group_symbol () const
  {
    return this->group_symbol_;
  }

  part_group::group_symbol_optional& part_group::
  group_symbol ()
  {
    return this->group_symbol_;
  }

  void part_group::
  group_symbol (const group_symbol_type& x)
  {
    this->group_symbol_.set (x);
  }

  void part_group::
  group_symbol (const group_symbol_optional& x)
  {
    this->group_symbol_ = x;
  }

  void part_group::
  group_symbol (::std::unique_ptr< group_symbol_type > x)
  {
    this->group_symbol_.set (std::move (x));
  }

  const part_group::group_barline_optional& part_group::
  group_barline () const
  {
    return this->group_barline_;
  }

  part_group::group_barline_optional& part_group::
  group_barline ()
  {
    return this->group_barline_;
  }

  void part_group::
  group_barline (const group_barline_type& x)
  {
    this->group_barline_.set (x);
  }

  void part_group::
  group_barline (const group_barline_optional& x)
  {
    this->group_barline_ = x;
  }

  void part_group::
  group_barline (::std::unique_ptr< group_barline_type > x)
  {
    this->group_barline_.set (std::move (x));
  }

  const part_group::group_time_optional& part_group::
  group_time () const
  {
    return this->group_time_;
  }

  part_group::group_time_optional& part_group::
  group_time ()
  {
    return this->group_time_;
  }

  void part_group::
  group_time (const group_time_type& x)
  {
    this->group_time_.set (x);
  }

  void part_group::
  group_time (const group_time_optional& x)
  {
    this->group_time_ = x;
  }

  void part_group::
  group_time (::std::unique_ptr< group_time_type > x)
  {
    this->group_time_.set (std::move (x));
  }

  const part_group::footnote_optional& part_group::
  footnote () const
  {
    return this->footnote_;
  }

  part_group::footnote_optional& part_group::
  footnote ()
  {
    return this->footnote_;
  }

  void part_group::
  footnote (const footnote_type& x)
  {
    this->footnote_.set (x);
  }

  void part_group::
  footnote (const footnote_optional& x)
  {
    this->footnote_ = x;
  }

  void part_group::
  footnote (::std::unique_ptr< footnote_type > x)
  {
    this->footnote_.set (std::move (x));
  }

  const part_group::level_optional& part_group::
  level () const
  {
    return this->level_;
  }

  part_group::level_optional& part_group::
  level ()
  {
    return this->level_;
  }

  void part_group::
  level (const level_type& x)
  {
    this->level_.set (x);
  }

  void part_group::
  level (const level_optional& x)
  {
    this->level_ = x;
  }

  void part_group::
  level (::std::unique_ptr< level_type > x)
  {
    this->level_.set (std::move (x));
  }

  const part_group::type_type& part_group::
  type () const
  {
    return this->type_.get ();
  }

  part_group::type_type& part_group::
  type ()
  {
    return this->type_.get ();
  }

  void part_group::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void part_group::
  type (::std::unique_ptr< type_type > x)
  {
    this->type_.set (std::move (x));
  }

  const part_group::number_type& part_group::
  number () const
  {
    return this->number_.get ();
  }

  part_group::number_type& part_group::
  number ()
  {
    return this->number_.get ();
  }

  void part_group::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void part_group::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const part_group::number_type& part_group::
  number_default_value ()
  {
    return number_default_value_;
  }


  // part_link
  // 

  const part_link::instrument_link_sequence& part_link::
  instrument_link () const
  {
    return this->instrument_link_;
  }

  part_link::instrument_link_sequence& part_link::
  instrument_link ()
  {
    return this->instrument_link_;
  }

  void part_link::
  instrument_link (const instrument_link_sequence& s)
  {
    this->instrument_link_ = s;
  }

  const part_link::group_link_sequence& part_link::
  group_link () const
  {
    return this->group_link_;
  }

  part_link::group_link_sequence& part_link::
  group_link ()
  {
    return this->group_link_;
  }

  void part_link::
  group_link (const group_link_sequence& s)
  {
    this->group_link_ = s;
  }

  const part_link::href_type& part_link::
  href () const
  {
    return this->href_.get ();
  }

  part_link::href_type& part_link::
  href ()
  {
    return this->href_.get ();
  }

  void part_link::
  href (const href_type& x)
  {
    this->href_.set (x);
  }

  void part_link::
  href (::std::unique_ptr< href_type > x)
  {
    this->href_.set (std::move (x));
  }

  const part_link::type_type& part_link::
  type () const
  {
    return this->type_.get ();
  }

  const part_link::type_type& part_link::
  type_default_value ()
  {
    return type_default_value_;
  }

  const part_link::role_optional& part_link::
  role () const
  {
    return this->role_;
  }

  part_link::role_optional& part_link::
  role ()
  {
    return this->role_;
  }

  void part_link::
  role (const role_type& x)
  {
    this->role_.set (x);
  }

  void part_link::
  role (const role_optional& x)
  {
    this->role_ = x;
  }

  void part_link::
  role (::std::unique_ptr< role_type > x)
  {
    this->role_.set (std::move (x));
  }

  const part_link::title_optional& part_link::
  title () const
  {
    return this->title_;
  }

  part_link::title_optional& part_link::
  title ()
  {
    return this->title_;
  }

  void part_link::
  title (const title_type& x)
  {
    this->title_.set (x);
  }

  void part_link::
  title (const title_optional& x)
  {
    this->title_ = x;
  }

  void part_link::
  title (::std::unique_ptr< title_type > x)
  {
    this->title_.set (std::move (x));
  }

  const part_link::show_type& part_link::
  show () const
  {
    return this->show_.get ();
  }

  part_link::show_type& part_link::
  show ()
  {
    return this->show_.get ();
  }

  void part_link::
  show (const show_type& x)
  {
    this->show_.set (x);
  }

  void part_link::
  show (::std::unique_ptr< show_type > x)
  {
    this->show_.set (std::move (x));
  }

  const part_link::show_type& part_link::
  show_default_value ()
  {
    return show_default_value_;
  }

  const part_link::actuate_type& part_link::
  actuate () const
  {
    return this->actuate_.get ();
  }

  part_link::actuate_type& part_link::
  actuate ()
  {
    return this->actuate_.get ();
  }

  void part_link::
  actuate (const actuate_type& x)
  {
    this->actuate_.set (x);
  }

  void part_link::
  actuate (::std::unique_ptr< actuate_type > x)
  {
    this->actuate_.set (std::move (x));
  }

  const part_link::actuate_type& part_link::
  actuate_default_value ()
  {
    return actuate_default_value_;
  }


  // part_list
  // 

  const part_list::part_group_sequence& part_list::
  part_group () const
  {
    return this->part_group_;
  }

  part_list::part_group_sequence& part_list::
  part_group ()
  {
    return this->part_group_;
  }

  void part_list::
  part_group (const part_group_sequence& s)
  {
    this->part_group_ = s;
  }

  const part_list::score_part_sequence& part_list::
  score_part () const
  {
    return this->score_part_;
  }

  part_list::score_part_sequence& part_list::
  score_part ()
  {
    return this->score_part_;
  }

  void part_list::
  score_part (const score_part_sequence& s)
  {
    this->score_part_ = s;
  }

  const part_list::content_order_sequence& part_list::
  content_order () const
  {
    return this->content_order_;
  }

  part_list::content_order_sequence& part_list::
  content_order ()
  {
    return this->content_order_;
  }

  void part_list::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // part_name
  // 

  const part_name::default_x_optional& part_name::
  default_x () const
  {
    return this->default_x_;
  }

  part_name::default_x_optional& part_name::
  default_x ()
  {
    return this->default_x_;
  }

  void part_name::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void part_name::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void part_name::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const part_name::default_y_optional& part_name::
  default_y () const
  {
    return this->default_y_;
  }

  part_name::default_y_optional& part_name::
  default_y ()
  {
    return this->default_y_;
  }

  void part_name::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void part_name::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void part_name::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const part_name::relative_x_optional& part_name::
  relative_x () const
  {
    return this->relative_x_;
  }

  part_name::relative_x_optional& part_name::
  relative_x ()
  {
    return this->relative_x_;
  }

  void part_name::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void part_name::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void part_name::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const part_name::relative_y_optional& part_name::
  relative_y () const
  {
    return this->relative_y_;
  }

  part_name::relative_y_optional& part_name::
  relative_y ()
  {
    return this->relative_y_;
  }

  void part_name::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void part_name::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void part_name::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const part_name::font_family_optional& part_name::
  font_family () const
  {
    return this->font_family_;
  }

  part_name::font_family_optional& part_name::
  font_family ()
  {
    return this->font_family_;
  }

  void part_name::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void part_name::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void part_name::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const part_name::font_style_optional& part_name::
  font_style () const
  {
    return this->font_style_;
  }

  part_name::font_style_optional& part_name::
  font_style ()
  {
    return this->font_style_;
  }

  void part_name::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void part_name::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void part_name::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const part_name::font_size_optional& part_name::
  font_size () const
  {
    return this->font_size_;
  }

  part_name::font_size_optional& part_name::
  font_size ()
  {
    return this->font_size_;
  }

  void part_name::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void part_name::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void part_name::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const part_name::font_weight_optional& part_name::
  font_weight () const
  {
    return this->font_weight_;
  }

  part_name::font_weight_optional& part_name::
  font_weight ()
  {
    return this->font_weight_;
  }

  void part_name::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void part_name::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void part_name::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const part_name::color_optional& part_name::
  color () const
  {
    return this->color_;
  }

  part_name::color_optional& part_name::
  color ()
  {
    return this->color_;
  }

  void part_name::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void part_name::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void part_name::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const part_name::print_object_optional& part_name::
  print_object () const
  {
    return this->print_object_;
  }

  part_name::print_object_optional& part_name::
  print_object ()
  {
    return this->print_object_;
  }

  void part_name::
  print_object (const print_object_type& x)
  {
    this->print_object_.set (x);
  }

  void part_name::
  print_object (const print_object_optional& x)
  {
    this->print_object_ = x;
  }

  void part_name::
  print_object (::std::unique_ptr< print_object_type > x)
  {
    this->print_object_.set (std::move (x));
  }

  const part_name::justify_optional& part_name::
  justify () const
  {
    return this->justify_;
  }

  part_name::justify_optional& part_name::
  justify ()
  {
    return this->justify_;
  }

  void part_name::
  justify (const justify_type& x)
  {
    this->justify_.set (x);
  }

  void part_name::
  justify (const justify_optional& x)
  {
    this->justify_ = x;
  }

  void part_name::
  justify (::std::unique_ptr< justify_type > x)
  {
    this->justify_.set (std::move (x));
  }


  // player
  // 

  const player::player_name_type& player::
  player_name () const
  {
    return this->player_name_.get ();
  }

  player::player_name_type& player::
  player_name ()
  {
    return this->player_name_.get ();
  }

  void player::
  player_name (const player_name_type& x)
  {
    this->player_name_.set (x);
  }

  void player::
  player_name (::std::unique_ptr< player_name_type > x)
  {
    this->player_name_.set (std::move (x));
  }

  const player::id_type& player::
  id () const
  {
    return this->id_.get ();
  }

  player::id_type& player::
  id ()
  {
    return this->id_.get ();
  }

  void player::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void player::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // score_instrument
  // 

  const score_instrument::instrument_name_type& score_instrument::
  instrument_name () const
  {
    return this->instrument_name_.get ();
  }

  score_instrument::instrument_name_type& score_instrument::
  instrument_name ()
  {
    return this->instrument_name_.get ();
  }

  void score_instrument::
  instrument_name (const instrument_name_type& x)
  {
    this->instrument_name_.set (x);
  }

  void score_instrument::
  instrument_name (::std::unique_ptr< instrument_name_type > x)
  {
    this->instrument_name_.set (std::move (x));
  }

  const score_instrument::instrument_abbreviation_optional& score_instrument::
  instrument_abbreviation () const
  {
    return this->instrument_abbreviation_;
  }

  score_instrument::instrument_abbreviation_optional& score_instrument::
  instrument_abbreviation ()
  {
    return this->instrument_abbreviation_;
  }

  void score_instrument::
  instrument_abbreviation (const instrument_abbreviation_type& x)
  {
    this->instrument_abbreviation_.set (x);
  }

  void score_instrument::
  instrument_abbreviation (const instrument_abbreviation_optional& x)
  {
    this->instrument_abbreviation_ = x;
  }

  void score_instrument::
  instrument_abbreviation (::std::unique_ptr< instrument_abbreviation_type > x)
  {
    this->instrument_abbreviation_.set (std::move (x));
  }

  const score_instrument::instrument_sound_optional& score_instrument::
  instrument_sound () const
  {
    return this->instrument_sound_;
  }

  score_instrument::instrument_sound_optional& score_instrument::
  instrument_sound ()
  {
    return this->instrument_sound_;
  }

  void score_instrument::
  instrument_sound (const instrument_sound_type& x)
  {
    this->instrument_sound_.set (x);
  }

  void score_instrument::
  instrument_sound (const instrument_sound_optional& x)
  {
    this->instrument_sound_ = x;
  }

  void score_instrument::
  instrument_sound (::std::unique_ptr< instrument_sound_type > x)
  {
    this->instrument_sound_.set (std::move (x));
  }

  const score_instrument::solo_optional& score_instrument::
  solo () const
  {
    return this->solo_;
  }

  score_instrument::solo_optional& score_instrument::
  solo ()
  {
    return this->solo_;
  }

  void score_instrument::
  solo (const solo_type& x)
  {
    this->solo_.set (x);
  }

  void score_instrument::
  solo (const solo_optional& x)
  {
    this->solo_ = x;
  }

  void score_instrument::
  solo (::std::unique_ptr< solo_type > x)
  {
    this->solo_.set (std::move (x));
  }

  const score_instrument::ensemble_optional& score_instrument::
  ensemble () const
  {
    return this->ensemble_;
  }

  score_instrument::ensemble_optional& score_instrument::
  ensemble ()
  {
    return this->ensemble_;
  }

  void score_instrument::
  ensemble (const ensemble_type& x)
  {
    this->ensemble_.set (x);
  }

  void score_instrument::
  ensemble (const ensemble_optional& x)
  {
    this->ensemble_ = x;
  }

  void score_instrument::
  ensemble (::std::unique_ptr< ensemble_type > x)
  {
    this->ensemble_.set (std::move (x));
  }

  const score_instrument::virtual_instrument_optional& score_instrument::
  virtual_instrument () const
  {
    return this->virtual_instrument_;
  }

  score_instrument::virtual_instrument_optional& score_instrument::
  virtual_instrument ()
  {
    return this->virtual_instrument_;
  }

  void score_instrument::
  virtual_instrument (const virtual_instrument_type& x)
  {
    this->virtual_instrument_.set (x);
  }

  void score_instrument::
  virtual_instrument (const virtual_instrument_optional& x)
  {
    this->virtual_instrument_ = x;
  }

  void score_instrument::
  virtual_instrument (::std::unique_ptr< virtual_instrument_type > x)
  {
    this->virtual_instrument_.set (std::move (x));
  }

  const score_instrument::id_type& score_instrument::
  id () const
  {
    return this->id_.get ();
  }

  score_instrument::id_type& score_instrument::
  id ()
  {
    return this->id_.get ();
  }

  void score_instrument::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void score_instrument::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // score_part
  // 

  const score_part::identification_optional& score_part::
  identification () const
  {
    return this->identification_;
  }

  score_part::identification_optional& score_part::
  identification ()
  {
    return this->identification_;
  }

  void score_part::
  identification (const identification_type& x)
  {
    this->identification_.set (x);
  }

  void score_part::
  identification (const identification_optional& x)
  {
    this->identification_ = x;
  }

  void score_part::
  identification (::std::unique_ptr< identification_type > x)
  {
    this->identification_.set (std::move (x));
  }

  const score_part::part_link_sequence& score_part::
  part_link () const
  {
    return this->part_link_;
  }

  score_part::part_link_sequence& score_part::
  part_link ()
  {
    return this->part_link_;
  }

  void score_part::
  part_link (const part_link_sequence& s)
  {
    this->part_link_ = s;
  }

  const score_part::part_name_type& score_part::
  part_name () const
  {
    return this->part_name_.get ();
  }

  score_part::part_name_type& score_part::
  part_name ()
  {
    return this->part_name_.get ();
  }

  void score_part::
  part_name (const part_name_type& x)
  {
    this->part_name_.set (x);
  }

  void score_part::
  part_name (::std::unique_ptr< part_name_type > x)
  {
    this->part_name_.set (std::move (x));
  }

  const score_part::part_name_display_optional& score_part::
  part_name_display () const
  {
    return this->part_name_display_;
  }

  score_part::part_name_display_optional& score_part::
  part_name_display ()
  {
    return this->part_name_display_;
  }

  void score_part::
  part_name_display (const part_name_display_type& x)
  {
    this->part_name_display_.set (x);
  }

  void score_part::
  part_name_display (const part_name_display_optional& x)
  {
    this->part_name_display_ = x;
  }

  void score_part::
  part_name_display (::std::unique_ptr< part_name_display_type > x)
  {
    this->part_name_display_.set (std::move (x));
  }

  const score_part::part_abbreviation_optional& score_part::
  part_abbreviation () const
  {
    return this->part_abbreviation_;
  }

  score_part::part_abbreviation_optional& score_part::
  part_abbreviation ()
  {
    return this->part_abbreviation_;
  }

  void score_part::
  part_abbreviation (const part_abbreviation_type& x)
  {
    this->part_abbreviation_.set (x);
  }

  void score_part::
  part_abbreviation (const part_abbreviation_optional& x)
  {
    this->part_abbreviation_ = x;
  }

  void score_part::
  part_abbreviation (::std::unique_ptr< part_abbreviation_type > x)
  {
    this->part_abbreviation_.set (std::move (x));
  }

  const score_part::part_abbreviation_display_optional& score_part::
  part_abbreviation_display () const
  {
    return this->part_abbreviation_display_;
  }

  score_part::part_abbreviation_display_optional& score_part::
  part_abbreviation_display ()
  {
    return this->part_abbreviation_display_;
  }

  void score_part::
  part_abbreviation_display (const part_abbreviation_display_type& x)
  {
    this->part_abbreviation_display_.set (x);
  }

  void score_part::
  part_abbreviation_display (const part_abbreviation_display_optional& x)
  {
    this->part_abbreviation_display_ = x;
  }

  void score_part::
  part_abbreviation_display (::std::unique_ptr< part_abbreviation_display_type > x)
  {
    this->part_abbreviation_display_.set (std::move (x));
  }

  const score_part::group_sequence& score_part::
  group () const
  {
    return this->group_;
  }

  score_part::group_sequence& score_part::
  group ()
  {
    return this->group_;
  }

  void score_part::
  group (const group_sequence& s)
  {
    this->group_ = s;
  }

  const score_part::score_instrument_sequence& score_part::
  score_instrument () const
  {
    return this->score_instrument_;
  }

  score_part::score_instrument_sequence& score_part::
  score_instrument ()
  {
    return this->score_instrument_;
  }

  void score_part::
  score_instrument (const score_instrument_sequence& s)
  {
    this->score_instrument_ = s;
  }

  const score_part::player_sequence& score_part::
  player () const
  {
    return this->player_;
  }

  score_part::player_sequence& score_part::
  player ()
  {
    return this->player_;
  }

  void score_part::
  player (const player_sequence& s)
  {
    this->player_ = s;
  }

  const score_part::midi_device_sequence& score_part::
  midi_device () const
  {
    return this->midi_device_;
  }

  score_part::midi_device_sequence& score_part::
  midi_device ()
  {
    return this->midi_device_;
  }

  void score_part::
  midi_device (const midi_device_sequence& s)
  {
    this->midi_device_ = s;
  }

  const score_part::midi_instrument_sequence& score_part::
  midi_instrument () const
  {
    return this->midi_instrument_;
  }

  score_part::midi_instrument_sequence& score_part::
  midi_instrument ()
  {
    return this->midi_instrument_;
  }

  void score_part::
  midi_instrument (const midi_instrument_sequence& s)
  {
    this->midi_instrument_ = s;
  }

  const score_part::id_type& score_part::
  id () const
  {
    return this->id_.get ();
  }

  score_part::id_type& score_part::
  id ()
  {
    return this->id_.get ();
  }

  void score_part::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void score_part::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // virtual_instrument
  // 

  const virtual_instrument::virtual_library_optional& virtual_instrument::
  virtual_library () const
  {
    return this->virtual_library_;
  }

  virtual_instrument::virtual_library_optional& virtual_instrument::
  virtual_library ()
  {
    return this->virtual_library_;
  }

  void virtual_instrument::
  virtual_library (const virtual_library_type& x)
  {
    this->virtual_library_.set (x);
  }

  void virtual_instrument::
  virtual_library (const virtual_library_optional& x)
  {
    this->virtual_library_ = x;
  }

  void virtual_instrument::
  virtual_library (::std::unique_ptr< virtual_library_type > x)
  {
    this->virtual_library_.set (std::move (x));
  }

  const virtual_instrument::virtual_name_optional& virtual_instrument::
  virtual_name () const
  {
    return this->virtual_name_;
  }

  virtual_instrument::virtual_name_optional& virtual_instrument::
  virtual_name ()
  {
    return this->virtual_name_;
  }

  void virtual_instrument::
  virtual_name (const virtual_name_type& x)
  {
    this->virtual_name_.set (x);
  }

  void virtual_instrument::
  virtual_name (const virtual_name_optional& x)
  {
    this->virtual_name_ = x;
  }

  void virtual_instrument::
  virtual_name (::std::unique_ptr< virtual_name_type > x)
  {
    this->virtual_name_.set (std::move (x));
  }


  // work
  // 

  const work::work_number_optional& work::
  work_number () const
  {
    return this->work_number_;
  }

  work::work_number_optional& work::
  work_number ()
  {
    return this->work_number_;
  }

  void work::
  work_number (const work_number_type& x)
  {
    this->work_number_.set (x);
  }

  void work::
  work_number (const work_number_optional& x)
  {
    this->work_number_ = x;
  }

  void work::
  work_number (::std::unique_ptr< work_number_type > x)
  {
    this->work_number_.set (std::move (x));
  }

  const work::work_title_optional& work::
  work_title () const
  {
    return this->work_title_;
  }

  work::work_title_optional& work::
  work_title ()
  {
    return this->work_title_;
  }

  void work::
  work_title (const work_title_type& x)
  {
    this->work_title_.set (x);
  }

  void work::
  work_title (const work_title_optional& x)
  {
    this->work_title_ = x;
  }

  void work::
  work_title (::std::unique_ptr< work_title_type > x)
  {
    this->work_title_.set (std::move (x));
  }

  const work::opus_optional& work::
  opus () const
  {
    return this->opus_;
  }

  work::opus_optional& work::
  opus ()
  {
    return this->opus_;
  }

  void work::
  opus (const opus_type& x)
  {
    this->opus_.set (x);
  }

  void work::
  opus (const opus_optional& x)
  {
    this->opus_ = x;
  }

  void work::
  opus (::std::unique_ptr< opus_type > x)
  {
    this->opus_.set (std::move (x));
  }


  // number_or_normal_member
  // 

  number_or_normal_member::
  number_or_normal_member (value v)
  : ::xml_schema::token (_xsd_number_or_normal_member_literals_[v])
  {
  }

  number_or_normal_member::
  number_or_normal_member (const char* v)
  : ::xml_schema::token (v)
  {
  }

  number_or_normal_member::
  number_or_normal_member (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  number_or_normal_member::
  number_or_normal_member (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  number_or_normal_member::
  number_or_normal_member (const number_or_normal_member& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  number_or_normal_member& number_or_normal_member::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_number_or_normal_member_literals_[v]);

    return *this;
  }


  // positive_integer_or_empty_member
  // 

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (value v)
  : ::xml_schema::string (_xsd_positive_integer_or_empty_member_literals_[v])
  {
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const char* v)
  : ::xml_schema::string (v)
  {
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const positive_integer_or_empty_member& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  positive_integer_or_empty_member& positive_integer_or_empty_member::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_positive_integer_or_empty_member_literals_[v]);

    return *this;
  }


  // directive
  // 

  const directive::default_x_optional& directive::
  default_x () const
  {
    return this->default_x_;
  }

  directive::default_x_optional& directive::
  default_x ()
  {
    return this->default_x_;
  }

  void directive::
  default_x (const default_x_type& x)
  {
    this->default_x_.set (x);
  }

  void directive::
  default_x (const default_x_optional& x)
  {
    this->default_x_ = x;
  }

  void directive::
  default_x (::std::unique_ptr< default_x_type > x)
  {
    this->default_x_.set (std::move (x));
  }

  const directive::default_y_optional& directive::
  default_y () const
  {
    return this->default_y_;
  }

  directive::default_y_optional& directive::
  default_y ()
  {
    return this->default_y_;
  }

  void directive::
  default_y (const default_y_type& x)
  {
    this->default_y_.set (x);
  }

  void directive::
  default_y (const default_y_optional& x)
  {
    this->default_y_ = x;
  }

  void directive::
  default_y (::std::unique_ptr< default_y_type > x)
  {
    this->default_y_.set (std::move (x));
  }

  const directive::relative_x_optional& directive::
  relative_x () const
  {
    return this->relative_x_;
  }

  directive::relative_x_optional& directive::
  relative_x ()
  {
    return this->relative_x_;
  }

  void directive::
  relative_x (const relative_x_type& x)
  {
    this->relative_x_.set (x);
  }

  void directive::
  relative_x (const relative_x_optional& x)
  {
    this->relative_x_ = x;
  }

  void directive::
  relative_x (::std::unique_ptr< relative_x_type > x)
  {
    this->relative_x_.set (std::move (x));
  }

  const directive::relative_y_optional& directive::
  relative_y () const
  {
    return this->relative_y_;
  }

  directive::relative_y_optional& directive::
  relative_y ()
  {
    return this->relative_y_;
  }

  void directive::
  relative_y (const relative_y_type& x)
  {
    this->relative_y_.set (x);
  }

  void directive::
  relative_y (const relative_y_optional& x)
  {
    this->relative_y_ = x;
  }

  void directive::
  relative_y (::std::unique_ptr< relative_y_type > x)
  {
    this->relative_y_.set (std::move (x));
  }

  const directive::font_family_optional& directive::
  font_family () const
  {
    return this->font_family_;
  }

  directive::font_family_optional& directive::
  font_family ()
  {
    return this->font_family_;
  }

  void directive::
  font_family (const font_family_type& x)
  {
    this->font_family_.set (x);
  }

  void directive::
  font_family (const font_family_optional& x)
  {
    this->font_family_ = x;
  }

  void directive::
  font_family (::std::unique_ptr< font_family_type > x)
  {
    this->font_family_.set (std::move (x));
  }

  const directive::font_style_optional& directive::
  font_style () const
  {
    return this->font_style_;
  }

  directive::font_style_optional& directive::
  font_style ()
  {
    return this->font_style_;
  }

  void directive::
  font_style (const font_style_type& x)
  {
    this->font_style_.set (x);
  }

  void directive::
  font_style (const font_style_optional& x)
  {
    this->font_style_ = x;
  }

  void directive::
  font_style (::std::unique_ptr< font_style_type > x)
  {
    this->font_style_.set (std::move (x));
  }

  const directive::font_size_optional& directive::
  font_size () const
  {
    return this->font_size_;
  }

  directive::font_size_optional& directive::
  font_size ()
  {
    return this->font_size_;
  }

  void directive::
  font_size (const font_size_type& x)
  {
    this->font_size_.set (x);
  }

  void directive::
  font_size (const font_size_optional& x)
  {
    this->font_size_ = x;
  }

  void directive::
  font_size (::std::unique_ptr< font_size_type > x)
  {
    this->font_size_.set (std::move (x));
  }

  const directive::font_weight_optional& directive::
  font_weight () const
  {
    return this->font_weight_;
  }

  directive::font_weight_optional& directive::
  font_weight ()
  {
    return this->font_weight_;
  }

  void directive::
  font_weight (const font_weight_type& x)
  {
    this->font_weight_.set (x);
  }

  void directive::
  font_weight (const font_weight_optional& x)
  {
    this->font_weight_ = x;
  }

  void directive::
  font_weight (::std::unique_ptr< font_weight_type > x)
  {
    this->font_weight_.set (std::move (x));
  }

  const directive::color_optional& directive::
  color () const
  {
    return this->color_;
  }

  directive::color_optional& directive::
  color ()
  {
    return this->color_;
  }

  void directive::
  color (const color_type& x)
  {
    this->color_.set (x);
  }

  void directive::
  color (const color_optional& x)
  {
    this->color_ = x;
  }

  void directive::
  color (::std::unique_ptr< color_type > x)
  {
    this->color_.set (std::move (x));
  }

  const directive::lang_optional& directive::
  lang () const
  {
    return this->lang_;
  }

  directive::lang_optional& directive::
  lang ()
  {
    return this->lang_;
  }

  void directive::
  lang (const lang_type& x)
  {
    this->lang_.set (x);
  }

  void directive::
  lang (const lang_optional& x)
  {
    this->lang_ = x;
  }

  void directive::
  lang (::std::unique_ptr< lang_type > x)
  {
    this->lang_.set (std::move (x));
  }


  // score_partwise
  // 

  const score_partwise::work_optional& score_partwise::
  work () const
  {
    return this->work_;
  }

  score_partwise::work_optional& score_partwise::
  work ()
  {
    return this->work_;
  }

  void score_partwise::
  work (const work_type& x)
  {
    this->work_.set (x);
  }

  void score_partwise::
  work (const work_optional& x)
  {
    this->work_ = x;
  }

  void score_partwise::
  work (::std::unique_ptr< work_type > x)
  {
    this->work_.set (std::move (x));
  }

  const score_partwise::movement_number_optional& score_partwise::
  movement_number () const
  {
    return this->movement_number_;
  }

  score_partwise::movement_number_optional& score_partwise::
  movement_number ()
  {
    return this->movement_number_;
  }

  void score_partwise::
  movement_number (const movement_number_type& x)
  {
    this->movement_number_.set (x);
  }

  void score_partwise::
  movement_number (const movement_number_optional& x)
  {
    this->movement_number_ = x;
  }

  void score_partwise::
  movement_number (::std::unique_ptr< movement_number_type > x)
  {
    this->movement_number_.set (std::move (x));
  }

  const score_partwise::movement_title_optional& score_partwise::
  movement_title () const
  {
    return this->movement_title_;
  }

  score_partwise::movement_title_optional& score_partwise::
  movement_title ()
  {
    return this->movement_title_;
  }

  void score_partwise::
  movement_title (const movement_title_type& x)
  {
    this->movement_title_.set (x);
  }

  void score_partwise::
  movement_title (const movement_title_optional& x)
  {
    this->movement_title_ = x;
  }

  void score_partwise::
  movement_title (::std::unique_ptr< movement_title_type > x)
  {
    this->movement_title_.set (std::move (x));
  }

  const score_partwise::identification_optional& score_partwise::
  identification () const
  {
    return this->identification_;
  }

  score_partwise::identification_optional& score_partwise::
  identification ()
  {
    return this->identification_;
  }

  void score_partwise::
  identification (const identification_type& x)
  {
    this->identification_.set (x);
  }

  void score_partwise::
  identification (const identification_optional& x)
  {
    this->identification_ = x;
  }

  void score_partwise::
  identification (::std::unique_ptr< identification_type > x)
  {
    this->identification_.set (std::move (x));
  }

  const score_partwise::defaults_optional& score_partwise::
  defaults () const
  {
    return this->defaults_;
  }

  score_partwise::defaults_optional& score_partwise::
  defaults ()
  {
    return this->defaults_;
  }

  void score_partwise::
  defaults (const defaults_type& x)
  {
    this->defaults_.set (x);
  }

  void score_partwise::
  defaults (const defaults_optional& x)
  {
    this->defaults_ = x;
  }

  void score_partwise::
  defaults (::std::unique_ptr< defaults_type > x)
  {
    this->defaults_.set (std::move (x));
  }

  const score_partwise::credit_sequence& score_partwise::
  credit () const
  {
    return this->credit_;
  }

  score_partwise::credit_sequence& score_partwise::
  credit ()
  {
    return this->credit_;
  }

  void score_partwise::
  credit (const credit_sequence& s)
  {
    this->credit_ = s;
  }

  const score_partwise::part_list_type& score_partwise::
  part_list () const
  {
    return this->part_list_.get ();
  }

  score_partwise::part_list_type& score_partwise::
  part_list ()
  {
    return this->part_list_.get ();
  }

  void score_partwise::
  part_list (const part_list_type& x)
  {
    this->part_list_.set (x);
  }

  void score_partwise::
  part_list (::std::unique_ptr< part_list_type > x)
  {
    this->part_list_.set (std::move (x));
  }

  const score_partwise::part_sequence& score_partwise::
  part () const
  {
    return this->part_;
  }

  score_partwise::part_sequence& score_partwise::
  part ()
  {
    return this->part_;
  }

  void score_partwise::
  part (const part_sequence& s)
  {
    this->part_ = s;
  }

  const score_partwise::version_type& score_partwise::
  version () const
  {
    return this->version_.get ();
  }

  score_partwise::version_type& score_partwise::
  version ()
  {
    return this->version_.get ();
  }

  void score_partwise::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void score_partwise::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const score_partwise::version_type& score_partwise::
  version_default_value ()
  {
    return version_default_value_;
  }


  // score_timewise
  // 

  const score_timewise::work_optional& score_timewise::
  work () const
  {
    return this->work_;
  }

  score_timewise::work_optional& score_timewise::
  work ()
  {
    return this->work_;
  }

  void score_timewise::
  work (const work_type& x)
  {
    this->work_.set (x);
  }

  void score_timewise::
  work (const work_optional& x)
  {
    this->work_ = x;
  }

  void score_timewise::
  work (::std::unique_ptr< work_type > x)
  {
    this->work_.set (std::move (x));
  }

  const score_timewise::movement_number_optional& score_timewise::
  movement_number () const
  {
    return this->movement_number_;
  }

  score_timewise::movement_number_optional& score_timewise::
  movement_number ()
  {
    return this->movement_number_;
  }

  void score_timewise::
  movement_number (const movement_number_type& x)
  {
    this->movement_number_.set (x);
  }

  void score_timewise::
  movement_number (const movement_number_optional& x)
  {
    this->movement_number_ = x;
  }

  void score_timewise::
  movement_number (::std::unique_ptr< movement_number_type > x)
  {
    this->movement_number_.set (std::move (x));
  }

  const score_timewise::movement_title_optional& score_timewise::
  movement_title () const
  {
    return this->movement_title_;
  }

  score_timewise::movement_title_optional& score_timewise::
  movement_title ()
  {
    return this->movement_title_;
  }

  void score_timewise::
  movement_title (const movement_title_type& x)
  {
    this->movement_title_.set (x);
  }

  void score_timewise::
  movement_title (const movement_title_optional& x)
  {
    this->movement_title_ = x;
  }

  void score_timewise::
  movement_title (::std::unique_ptr< movement_title_type > x)
  {
    this->movement_title_.set (std::move (x));
  }

  const score_timewise::identification_optional& score_timewise::
  identification () const
  {
    return this->identification_;
  }

  score_timewise::identification_optional& score_timewise::
  identification ()
  {
    return this->identification_;
  }

  void score_timewise::
  identification (const identification_type& x)
  {
    this->identification_.set (x);
  }

  void score_timewise::
  identification (const identification_optional& x)
  {
    this->identification_ = x;
  }

  void score_timewise::
  identification (::std::unique_ptr< identification_type > x)
  {
    this->identification_.set (std::move (x));
  }

  const score_timewise::defaults_optional& score_timewise::
  defaults () const
  {
    return this->defaults_;
  }

  score_timewise::defaults_optional& score_timewise::
  defaults ()
  {
    return this->defaults_;
  }

  void score_timewise::
  defaults (const defaults_type& x)
  {
    this->defaults_.set (x);
  }

  void score_timewise::
  defaults (const defaults_optional& x)
  {
    this->defaults_ = x;
  }

  void score_timewise::
  defaults (::std::unique_ptr< defaults_type > x)
  {
    this->defaults_.set (std::move (x));
  }

  const score_timewise::credit_sequence& score_timewise::
  credit () const
  {
    return this->credit_;
  }

  score_timewise::credit_sequence& score_timewise::
  credit ()
  {
    return this->credit_;
  }

  void score_timewise::
  credit (const credit_sequence& s)
  {
    this->credit_ = s;
  }

  const score_timewise::part_list_type& score_timewise::
  part_list () const
  {
    return this->part_list_.get ();
  }

  score_timewise::part_list_type& score_timewise::
  part_list ()
  {
    return this->part_list_.get ();
  }

  void score_timewise::
  part_list (const part_list_type& x)
  {
    this->part_list_.set (x);
  }

  void score_timewise::
  part_list (::std::unique_ptr< part_list_type > x)
  {
    this->part_list_.set (std::move (x));
  }

  const score_timewise::measure_sequence& score_timewise::
  measure () const
  {
    return this->measure_;
  }

  score_timewise::measure_sequence& score_timewise::
  measure ()
  {
    return this->measure_;
  }

  void score_timewise::
  measure (const measure_sequence& s)
  {
    this->measure_ = s;
  }

  const score_timewise::version_type& score_timewise::
  version () const
  {
    return this->version_.get ();
  }

  score_timewise::version_type& score_timewise::
  version ()
  {
    return this->version_.get ();
  }

  void score_timewise::
  version (const version_type& x)
  {
    this->version_.set (x);
  }

  void score_timewise::
  version (::std::unique_ptr< version_type > x)
  {
    this->version_.set (std::move (x));
  }

  const score_timewise::version_type& score_timewise::
  version_default_value ()
  {
    return version_default_value_;
  }


  // part
  // 

  const part::measure_sequence& part::
  measure () const
  {
    return this->measure_;
  }

  part::measure_sequence& part::
  measure ()
  {
    return this->measure_;
  }

  void part::
  measure (const measure_sequence& s)
  {
    this->measure_ = s;
  }

  const part::id_type& part::
  id () const
  {
    return this->id_.get ();
  }

  part::id_type& part::
  id ()
  {
    return this->id_.get ();
  }

  void part::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void part::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // measure
  // 

  const measure::part_sequence& measure::
  part () const
  {
    return this->part_;
  }

  measure::part_sequence& measure::
  part ()
  {
    return this->part_;
  }

  void measure::
  part (const part_sequence& s)
  {
    this->part_ = s;
  }

  const measure::number_type& measure::
  number () const
  {
    return this->number_.get ();
  }

  measure::number_type& measure::
  number ()
  {
    return this->number_.get ();
  }

  void measure::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void measure::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const measure::text_optional& measure::
  text () const
  {
    return this->text_;
  }

  measure::text_optional& measure::
  text ()
  {
    return this->text_;
  }

  void measure::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void measure::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void measure::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const measure::implicit_optional& measure::
  implicit () const
  {
    return this->implicit_;
  }

  measure::implicit_optional& measure::
  implicit ()
  {
    return this->implicit_;
  }

  void measure::
  implicit (const implicit_type& x)
  {
    this->implicit_.set (x);
  }

  void measure::
  implicit (const implicit_optional& x)
  {
    this->implicit_ = x;
  }

  void measure::
  implicit (::std::unique_ptr< implicit_type > x)
  {
    this->implicit_.set (std::move (x));
  }

  const measure::non_controlling_optional& measure::
  non_controlling () const
  {
    return this->non_controlling_;
  }

  measure::non_controlling_optional& measure::
  non_controlling ()
  {
    return this->non_controlling_;
  }

  void measure::
  non_controlling (const non_controlling_type& x)
  {
    this->non_controlling_.set (x);
  }

  void measure::
  non_controlling (const non_controlling_optional& x)
  {
    this->non_controlling_ = x;
  }

  void measure::
  non_controlling (::std::unique_ptr< non_controlling_type > x)
  {
    this->non_controlling_.set (std::move (x));
  }

  const measure::width_optional& measure::
  width () const
  {
    return this->width_;
  }

  measure::width_optional& measure::
  width ()
  {
    return this->width_;
  }

  void measure::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void measure::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void measure::
  width (::std::unique_ptr< width_type > x)
  {
    this->width_.set (std::move (x));
  }

  const measure::id_optional& measure::
  id () const
  {
    return this->id_;
  }

  measure::id_optional& measure::
  id ()
  {
    return this->id_;
  }

  void measure::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void measure::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void measure::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }


  // measure1
  // 

  const measure1::note_sequence& measure1::
  note () const
  {
    return this->note_;
  }

  measure1::note_sequence& measure1::
  note ()
  {
    return this->note_;
  }

  void measure1::
  note (const note_sequence& s)
  {
    this->note_ = s;
  }

  const measure1::backup_sequence& measure1::
  backup () const
  {
    return this->backup_;
  }

  measure1::backup_sequence& measure1::
  backup ()
  {
    return this->backup_;
  }

  void measure1::
  backup (const backup_sequence& s)
  {
    this->backup_ = s;
  }

  const measure1::forward_sequence& measure1::
  forward () const
  {
    return this->forward_;
  }

  measure1::forward_sequence& measure1::
  forward ()
  {
    return this->forward_;
  }

  void measure1::
  forward (const forward_sequence& s)
  {
    this->forward_ = s;
  }

  const measure1::direction_sequence& measure1::
  direction () const
  {
    return this->direction_;
  }

  measure1::direction_sequence& measure1::
  direction ()
  {
    return this->direction_;
  }

  void measure1::
  direction (const direction_sequence& s)
  {
    this->direction_ = s;
  }

  const measure1::attributes_sequence& measure1::
  attributes () const
  {
    return this->attributes_;
  }

  measure1::attributes_sequence& measure1::
  attributes ()
  {
    return this->attributes_;
  }

  void measure1::
  attributes (const attributes_sequence& s)
  {
    this->attributes_ = s;
  }

  const measure1::harmony_sequence& measure1::
  harmony () const
  {
    return this->harmony_;
  }

  measure1::harmony_sequence& measure1::
  harmony ()
  {
    return this->harmony_;
  }

  void measure1::
  harmony (const harmony_sequence& s)
  {
    this->harmony_ = s;
  }

  const measure1::figured_bass_sequence& measure1::
  figured_bass () const
  {
    return this->figured_bass_;
  }

  measure1::figured_bass_sequence& measure1::
  figured_bass ()
  {
    return this->figured_bass_;
  }

  void measure1::
  figured_bass (const figured_bass_sequence& s)
  {
    this->figured_bass_ = s;
  }

  const measure1::print_sequence& measure1::
  print () const
  {
    return this->print_;
  }

  measure1::print_sequence& measure1::
  print ()
  {
    return this->print_;
  }

  void measure1::
  print (const print_sequence& s)
  {
    this->print_ = s;
  }

  const measure1::sound_sequence& measure1::
  sound () const
  {
    return this->sound_;
  }

  measure1::sound_sequence& measure1::
  sound ()
  {
    return this->sound_;
  }

  void measure1::
  sound (const sound_sequence& s)
  {
    this->sound_ = s;
  }

  const measure1::listening_sequence& measure1::
  listening () const
  {
    return this->listening_;
  }

  measure1::listening_sequence& measure1::
  listening ()
  {
    return this->listening_;
  }

  void measure1::
  listening (const listening_sequence& s)
  {
    this->listening_ = s;
  }

  const measure1::barline_sequence& measure1::
  barline () const
  {
    return this->barline_;
  }

  measure1::barline_sequence& measure1::
  barline ()
  {
    return this->barline_;
  }

  void measure1::
  barline (const barline_sequence& s)
  {
    this->barline_ = s;
  }

  const measure1::grouping_sequence& measure1::
  grouping () const
  {
    return this->grouping_;
  }

  measure1::grouping_sequence& measure1::
  grouping ()
  {
    return this->grouping_;
  }

  void measure1::
  grouping (const grouping_sequence& s)
  {
    this->grouping_ = s;
  }

  const measure1::link_sequence& measure1::
  link () const
  {
    return this->link_;
  }

  measure1::link_sequence& measure1::
  link ()
  {
    return this->link_;
  }

  void measure1::
  link (const link_sequence& s)
  {
    this->link_ = s;
  }

  const measure1::bookmark_sequence& measure1::
  bookmark () const
  {
    return this->bookmark_;
  }

  measure1::bookmark_sequence& measure1::
  bookmark ()
  {
    return this->bookmark_;
  }

  void measure1::
  bookmark (const bookmark_sequence& s)
  {
    this->bookmark_ = s;
  }

  const measure1::number_type& measure1::
  number () const
  {
    return this->number_.get ();
  }

  measure1::number_type& measure1::
  number ()
  {
    return this->number_.get ();
  }

  void measure1::
  number (const number_type& x)
  {
    this->number_.set (x);
  }

  void measure1::
  number (::std::unique_ptr< number_type > x)
  {
    this->number_.set (std::move (x));
  }

  const measure1::text_optional& measure1::
  text () const
  {
    return this->text_;
  }

  measure1::text_optional& measure1::
  text ()
  {
    return this->text_;
  }

  void measure1::
  text (const text_type& x)
  {
    this->text_.set (x);
  }

  void measure1::
  text (const text_optional& x)
  {
    this->text_ = x;
  }

  void measure1::
  text (::std::unique_ptr< text_type > x)
  {
    this->text_.set (std::move (x));
  }

  const measure1::implicit_optional& measure1::
  implicit () const
  {
    return this->implicit_;
  }

  measure1::implicit_optional& measure1::
  implicit ()
  {
    return this->implicit_;
  }

  void measure1::
  implicit (const implicit_type& x)
  {
    this->implicit_.set (x);
  }

  void measure1::
  implicit (const implicit_optional& x)
  {
    this->implicit_ = x;
  }

  void measure1::
  implicit (::std::unique_ptr< implicit_type > x)
  {
    this->implicit_.set (std::move (x));
  }

  const measure1::non_controlling_optional& measure1::
  non_controlling () const
  {
    return this->non_controlling_;
  }

  measure1::non_controlling_optional& measure1::
  non_controlling ()
  {
    return this->non_controlling_;
  }

  void measure1::
  non_controlling (const non_controlling_type& x)
  {
    this->non_controlling_.set (x);
  }

  void measure1::
  non_controlling (const non_controlling_optional& x)
  {
    this->non_controlling_ = x;
  }

  void measure1::
  non_controlling (::std::unique_ptr< non_controlling_type > x)
  {
    this->non_controlling_.set (std::move (x));
  }

  const measure1::width_optional& measure1::
  width () const
  {
    return this->width_;
  }

  measure1::width_optional& measure1::
  width ()
  {
    return this->width_;
  }

  void measure1::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  void measure1::
  width (const width_optional& x)
  {
    this->width_ = x;
  }

  void measure1::
  width (::std::unique_ptr< width_type > x)
  {
    this->width_.set (std::move (x));
  }

  const measure1::id_optional& measure1::
  id () const
  {
    return this->id_;
  }

  measure1::id_optional& measure1::
  id ()
  {
    return this->id_;
  }

  void measure1::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void measure1::
  id (const id_optional& x)
  {
    this->id_ = x;
  }

  void measure1::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }

  const measure1::content_order_sequence& measure1::
  content_order () const
  {
    return this->content_order_;
  }

  measure1::content_order_sequence& measure1::
  content_order ()
  {
    return this->content_order_;
  }

  void measure1::
  content_order (const content_order_sequence& s)
  {
    this->content_order_ = s;
  }


  // part1
  // 

  const part1::note_sequence& part1::
  note () const
  {
    return this->note_;
  }

  part1::note_sequence& part1::
  note ()
  {
    return this->note_;
  }

  void part1::
  note (const note_sequence& s)
  {
    this->note_ = s;
  }

  const part1::backup_sequence& part1::
  backup () const
  {
    return this->backup_;
  }

  part1::backup_sequence& part1::
  backup ()
  {
    return this->backup_;
  }

  void part1::
  backup (const backup_sequence& s)
  {
    this->backup_ = s;
  }

  const part1::forward_sequence& part1::
  forward () const
  {
    return this->forward_;
  }

  part1::forward_sequence& part1::
  forward ()
  {
    return this->forward_;
  }

  void part1::
  forward (const forward_sequence& s)
  {
    this->forward_ = s;
  }

  const part1::direction_sequence& part1::
  direction () const
  {
    return this->direction_;
  }

  part1::direction_sequence& part1::
  direction ()
  {
    return this->direction_;
  }

  void part1::
  direction (const direction_sequence& s)
  {
    this->direction_ = s;
  }

  const part1::attributes_sequence& part1::
  attributes () const
  {
    return this->attributes_;
  }

  part1::attributes_sequence& part1::
  attributes ()
  {
    return this->attributes_;
  }

  void part1::
  attributes (const attributes_sequence& s)
  {
    this->attributes_ = s;
  }

  const part1::harmony_sequence& part1::
  harmony () const
  {
    return this->harmony_;
  }

  part1::harmony_sequence& part1::
  harmony ()
  {
    return this->harmony_;
  }

  void part1::
  harmony (const harmony_sequence& s)
  {
    this->harmony_ = s;
  }

  const part1::figured_bass_sequence& part1::
  figured_bass () const
  {
    return this->figured_bass_;
  }

  part1::figured_bass_sequence& part1::
  figured_bass ()
  {
    return this->figured_bass_;
  }

  void part1::
  figured_bass (const figured_bass_sequence& s)
  {
    this->figured_bass_ = s;
  }

  const part1::print_sequence& part1::
  print () const
  {
    return this->print_;
  }

  part1::print_sequence& part1::
  print ()
  {
    return this->print_;
  }

  void part1::
  print (const print_sequence& s)
  {
    this->print_ = s;
  }

  const part1::sound_sequence& part1::
  sound () const
  {
    return this->sound_;
  }

  part1::sound_sequence& part1::
  sound ()
  {
    return this->sound_;
  }

  void part1::
  sound (const sound_sequence& s)
  {
    this->sound_ = s;
  }

  const part1::listening_sequence& part1::
  listening () const
  {
    return this->listening_;
  }

  part1::listening_sequence& part1::
  listening ()
  {
    return this->listening_;
  }

  void part1::
  listening (const listening_sequence& s)
  {
    this->listening_ = s;
  }

  const part1::barline_sequence& part1::
  barline () const
  {
    return this->barline_;
  }

  part1::barline_sequence& part1::
  barline ()
  {
    return this->barline_;
  }

  void part1::
  barline (const barline_sequence& s)
  {
    this->barline_ = s;
  }

  const part1::grouping_sequence& part1::
  grouping () const
  {
    return this->grouping_;
  }

  part1::grouping_sequence& part1::
  grouping ()
  {
    return this->grouping_;
  }

  void part1::
  grouping (const grouping_sequence& s)
  {
    this->grouping_ = s;
  }

  const part1::link_sequence& part1::
  link () const
  {
    return this->link_;
  }

  part1::link_sequence& part1::
  link ()
  {
    return this->link_;
  }

  void part1::
  link (const link_sequence& s)
  {
    this->link_ = s;
  }

  const part1::bookmark_sequence& part1::
  bookmark () const
  {
    return this->bookmark_;
  }

  part1::bookmark_sequence& part1::
  bookmark ()
  {
    return this->bookmark_;
  }

  void part1::
  bookmark (const bookmark_sequence& s)
  {
    this->bookmark_ = s;
  }

  const part1::id_type& part1::
  id () const
  {
    return this->id_.get ();
  }

  part1::id_type& part1::
  id ()
  {
    return this->id_.get ();
  }

  void part1::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void part1::
  id (::std::unique_ptr< id_type > x)
  {
    this->id_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace musicxml
{
  // above_below
  //

  above_below::
  above_below (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_above_below_convert ();
  }

  above_below::
  above_below (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_above_below_convert ();
  }

  above_below::
  above_below (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_above_below_convert ();
  }

  above_below* above_below::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class above_below (*this, f, c);
  }

  above_below::value above_below::
  _xsd_above_below_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_above_below_literals_);
    const value* i (::std::lower_bound (
                      _xsd_above_below_indexes_,
                      _xsd_above_below_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_above_below_indexes_ + 2 || _xsd_above_below_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const above_below::
  _xsd_above_below_literals_[2] =
  {
    "above",
    "below"
  };

  const above_below::value above_below::
  _xsd_above_below_indexes_[2] =
  {
    ::musicxml::above_below::above,
    ::musicxml::above_below::below
  };

  // beam_level
  //

  beam_level::
  beam_level (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  beam_level::
  beam_level (const beam_level& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  beam_level::
  beam_level (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  beam_level::
  beam_level (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  beam_level::
  beam_level (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  beam_level* beam_level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beam_level (*this, f, c);
  }

  beam_level::
  ~beam_level ()
  {
  }

  // color
  //

  color::
  color ()
  : ::xml_schema::token ()
  {
  }

  color::
  color (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  color::
  color (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  color::
  color (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  color::
  color (const color& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  color::
  color (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  color::
  color (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  color::
  color (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  color* color::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class color (*this, f, c);
  }

  color::
  ~color ()
  {
  }

  // comma_separated_text
  //

  comma_separated_text::
  comma_separated_text ()
  : ::xml_schema::token ()
  {
  }

  comma_separated_text::
  comma_separated_text (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  comma_separated_text::
  comma_separated_text (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  comma_separated_text::
  comma_separated_text (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  comma_separated_text::
  comma_separated_text (const comma_separated_text& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  comma_separated_text::
  comma_separated_text (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  comma_separated_text::
  comma_separated_text (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  comma_separated_text::
  comma_separated_text (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  comma_separated_text* comma_separated_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class comma_separated_text (*this, f, c);
  }

  comma_separated_text::
  ~comma_separated_text ()
  {
  }

  // css_font_size
  //

  css_font_size::
  css_font_size (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_css_font_size_convert ();
  }

  css_font_size::
  css_font_size (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_css_font_size_convert ();
  }

  css_font_size::
  css_font_size (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_css_font_size_convert ();
  }

  css_font_size* css_font_size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class css_font_size (*this, f, c);
  }

  css_font_size::value css_font_size::
  _xsd_css_font_size_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_css_font_size_literals_);
    const value* i (::std::lower_bound (
                      _xsd_css_font_size_indexes_,
                      _xsd_css_font_size_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_css_font_size_indexes_ + 7 || _xsd_css_font_size_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const css_font_size::
  _xsd_css_font_size_literals_[7] =
  {
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "xx-large"
  };

  const css_font_size::value css_font_size::
  _xsd_css_font_size_indexes_[7] =
  {
    ::musicxml::css_font_size::large,
    ::musicxml::css_font_size::medium,
    ::musicxml::css_font_size::small,
    ::musicxml::css_font_size::x_large,
    ::musicxml::css_font_size::x_small,
    ::musicxml::css_font_size::xx_large,
    ::musicxml::css_font_size::xx_small
  };

  // divisions
  //

  divisions::
  divisions (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  divisions::
  divisions (const divisions& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  divisions::
  divisions (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  divisions::
  divisions (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  divisions::
  divisions (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  divisions* divisions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class divisions (*this, f, c);
  }

  divisions::
  ~divisions ()
  {
  }

  // enclosure_shape
  //

  enclosure_shape::
  enclosure_shape (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_enclosure_shape_convert ();
  }

  enclosure_shape::
  enclosure_shape (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_enclosure_shape_convert ();
  }

  enclosure_shape::
  enclosure_shape (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_enclosure_shape_convert ();
  }

  enclosure_shape* enclosure_shape::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class enclosure_shape (*this, f, c);
  }

  enclosure_shape::value enclosure_shape::
  _xsd_enclosure_shape_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_enclosure_shape_literals_);
    const value* i (::std::lower_bound (
                      _xsd_enclosure_shape_indexes_,
                      _xsd_enclosure_shape_indexes_ + 15,
                      *this,
                      c));

    if (i == _xsd_enclosure_shape_indexes_ + 15 || _xsd_enclosure_shape_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const enclosure_shape::
  _xsd_enclosure_shape_literals_[15] =
  {
    "rectangle",
    "square",
    "oval",
    "circle",
    "bracket",
    "inverted-bracket",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "heptagon",
    "octagon",
    "nonagon",
    "decagon",
    "none"
  };

  const enclosure_shape::value enclosure_shape::
  _xsd_enclosure_shape_indexes_[15] =
  {
    ::musicxml::enclosure_shape::bracket,
    ::musicxml::enclosure_shape::circle,
    ::musicxml::enclosure_shape::decagon,
    ::musicxml::enclosure_shape::diamond,
    ::musicxml::enclosure_shape::heptagon,
    ::musicxml::enclosure_shape::hexagon,
    ::musicxml::enclosure_shape::inverted_bracket,
    ::musicxml::enclosure_shape::nonagon,
    ::musicxml::enclosure_shape::none,
    ::musicxml::enclosure_shape::octagon,
    ::musicxml::enclosure_shape::oval,
    ::musicxml::enclosure_shape::pentagon,
    ::musicxml::enclosure_shape::rectangle,
    ::musicxml::enclosure_shape::square,
    ::musicxml::enclosure_shape::triangle
  };

  // fermata_shape
  //

  fermata_shape::
  fermata_shape (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_fermata_shape_convert ();
  }

  fermata_shape::
  fermata_shape (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_fermata_shape_convert ();
  }

  fermata_shape::
  fermata_shape (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_fermata_shape_convert ();
  }

  fermata_shape* fermata_shape::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fermata_shape (*this, f, c);
  }

  fermata_shape::value fermata_shape::
  _xsd_fermata_shape_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fermata_shape_literals_);
    const value* i (::std::lower_bound (
                      _xsd_fermata_shape_indexes_,
                      _xsd_fermata_shape_indexes_ + 9,
                      *this,
                      c));

    if (i == _xsd_fermata_shape_indexes_ + 9 || _xsd_fermata_shape_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const fermata_shape::
  _xsd_fermata_shape_literals_[9] =
  {
    "normal",
    "angled",
    "square",
    "double-angled",
    "double-square",
    "double-dot",
    "half-curve",
    "curlew",
    ""
  };

  const fermata_shape::value fermata_shape::
  _xsd_fermata_shape_indexes_[9] =
  {
    ::musicxml::fermata_shape::empty,
    ::musicxml::fermata_shape::angled,
    ::musicxml::fermata_shape::curlew,
    ::musicxml::fermata_shape::double_angled,
    ::musicxml::fermata_shape::double_dot,
    ::musicxml::fermata_shape::double_square,
    ::musicxml::fermata_shape::half_curve,
    ::musicxml::fermata_shape::normal,
    ::musicxml::fermata_shape::square
  };

  // font_family
  //

  font_family::
  font_family ()
  : ::musicxml::comma_separated_text ()
  {
  }

  font_family::
  font_family (const char* _xsd_token_base)
  : ::musicxml::comma_separated_text (_xsd_token_base)
  {
  }

  font_family::
  font_family (const ::std::string& _xsd_token_base)
  : ::musicxml::comma_separated_text (_xsd_token_base)
  {
  }

  font_family::
  font_family (const ::xml_schema::token& _xsd_token_base)
  : ::musicxml::comma_separated_text (_xsd_token_base)
  {
  }

  font_family::
  font_family (const font_family& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::comma_separated_text (x, f, c)
  {
  }

  font_family::
  font_family (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::comma_separated_text (e, f, c)
  {
  }

  font_family::
  font_family (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::comma_separated_text (a, f, c)
  {
  }

  font_family::
  font_family (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::comma_separated_text (s, e, f, c)
  {
  }

  font_family* font_family::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class font_family (*this, f, c);
  }

  font_family::
  ~font_family ()
  {
  }

  // font_size
  //

  font_size::
  font_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  font_size::
  font_size (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  font_size::
  font_size (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  font_size* font_size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class font_size (*this, f, c);
  }

  // font_style
  //

  font_style::
  font_style (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_font_style_convert ();
  }

  font_style::
  font_style (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_font_style_convert ();
  }

  font_style::
  font_style (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_font_style_convert ();
  }

  font_style* font_style::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class font_style (*this, f, c);
  }

  font_style::value font_style::
  _xsd_font_style_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_font_style_literals_);
    const value* i (::std::lower_bound (
                      _xsd_font_style_indexes_,
                      _xsd_font_style_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_font_style_indexes_ + 2 || _xsd_font_style_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const font_style::
  _xsd_font_style_literals_[2] =
  {
    "normal",
    "italic"
  };

  const font_style::value font_style::
  _xsd_font_style_indexes_[2] =
  {
    ::musicxml::font_style::italic,
    ::musicxml::font_style::normal
  };

  // font_weight
  //

  font_weight::
  font_weight (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_font_weight_convert ();
  }

  font_weight::
  font_weight (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_font_weight_convert ();
  }

  font_weight::
  font_weight (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_font_weight_convert ();
  }

  font_weight* font_weight::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class font_weight (*this, f, c);
  }

  font_weight::value font_weight::
  _xsd_font_weight_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_font_weight_literals_);
    const value* i (::std::lower_bound (
                      _xsd_font_weight_indexes_,
                      _xsd_font_weight_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_font_weight_indexes_ + 2 || _xsd_font_weight_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const font_weight::
  _xsd_font_weight_literals_[2] =
  {
    "normal",
    "bold"
  };

  const font_weight::value font_weight::
  _xsd_font_weight_indexes_[2] =
  {
    ::musicxml::font_weight::bold,
    ::musicxml::font_weight::normal
  };

  // left_center_right
  //

  left_center_right::
  left_center_right (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_left_center_right_convert ();
  }

  left_center_right::
  left_center_right (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_left_center_right_convert ();
  }

  left_center_right::
  left_center_right (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_left_center_right_convert ();
  }

  left_center_right* left_center_right::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class left_center_right (*this, f, c);
  }

  left_center_right::value left_center_right::
  _xsd_left_center_right_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_left_center_right_literals_);
    const value* i (::std::lower_bound (
                      _xsd_left_center_right_indexes_,
                      _xsd_left_center_right_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_left_center_right_indexes_ + 3 || _xsd_left_center_right_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const left_center_right::
  _xsd_left_center_right_literals_[3] =
  {
    "left",
    "center",
    "right"
  };

  const left_center_right::value left_center_right::
  _xsd_left_center_right_indexes_[3] =
  {
    ::musicxml::left_center_right::center,
    ::musicxml::left_center_right::left,
    ::musicxml::left_center_right::right
  };

  // left_right
  //

  left_right::
  left_right (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_left_right_convert ();
  }

  left_right::
  left_right (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_left_right_convert ();
  }

  left_right::
  left_right (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_left_right_convert ();
  }

  left_right* left_right::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class left_right (*this, f, c);
  }

  left_right::value left_right::
  _xsd_left_right_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_left_right_literals_);
    const value* i (::std::lower_bound (
                      _xsd_left_right_indexes_,
                      _xsd_left_right_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_left_right_indexes_ + 2 || _xsd_left_right_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const left_right::
  _xsd_left_right_literals_[2] =
  {
    "left",
    "right"
  };

  const left_right::value left_right::
  _xsd_left_right_indexes_[2] =
  {
    ::musicxml::left_right::left,
    ::musicxml::left_right::right
  };

  // line_length
  //

  line_length::
  line_length (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_line_length_convert ();
  }

  line_length::
  line_length (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_line_length_convert ();
  }

  line_length::
  line_length (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_line_length_convert ();
  }

  line_length* line_length::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_length (*this, f, c);
  }

  line_length::value line_length::
  _xsd_line_length_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_line_length_literals_);
    const value* i (::std::lower_bound (
                      _xsd_line_length_indexes_,
                      _xsd_line_length_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_line_length_indexes_ + 3 || _xsd_line_length_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const line_length::
  _xsd_line_length_literals_[3] =
  {
    "short",
    "medium",
    "long"
  };

  const line_length::value line_length::
  _xsd_line_length_indexes_[3] =
  {
    ::musicxml::line_length::long_,
    ::musicxml::line_length::medium,
    ::musicxml::line_length::short_
  };

  // line_shape
  //

  line_shape::
  line_shape (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_line_shape_convert ();
  }

  line_shape::
  line_shape (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_line_shape_convert ();
  }

  line_shape::
  line_shape (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_line_shape_convert ();
  }

  line_shape* line_shape::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_shape (*this, f, c);
  }

  line_shape::value line_shape::
  _xsd_line_shape_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_line_shape_literals_);
    const value* i (::std::lower_bound (
                      _xsd_line_shape_indexes_,
                      _xsd_line_shape_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_line_shape_indexes_ + 2 || _xsd_line_shape_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const line_shape::
  _xsd_line_shape_literals_[2] =
  {
    "straight",
    "curved"
  };

  const line_shape::value line_shape::
  _xsd_line_shape_indexes_[2] =
  {
    ::musicxml::line_shape::curved,
    ::musicxml::line_shape::straight
  };

  // line_type
  //

  line_type::
  line_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_line_type_convert ();
  }

  line_type::
  line_type (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_line_type_convert ();
  }

  line_type::
  line_type (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_line_type_convert ();
  }

  line_type* line_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_type (*this, f, c);
  }

  line_type::value line_type::
  _xsd_line_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_line_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_line_type_indexes_,
                      _xsd_line_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_line_type_indexes_ + 4 || _xsd_line_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const line_type::
  _xsd_line_type_literals_[4] =
  {
    "solid",
    "dashed",
    "dotted",
    "wavy"
  };

  const line_type::value line_type::
  _xsd_line_type_indexes_[4] =
  {
    ::musicxml::line_type::dashed,
    ::musicxml::line_type::dotted,
    ::musicxml::line_type::solid,
    ::musicxml::line_type::wavy
  };

  // midi_16
  //

  midi_16::
  midi_16 (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  midi_16::
  midi_16 (const midi_16& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  midi_16::
  midi_16 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  midi_16::
  midi_16 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  midi_16::
  midi_16 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  midi_16* midi_16::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class midi_16 (*this, f, c);
  }

  midi_16::
  ~midi_16 ()
  {
  }

  // midi_128
  //

  midi_128::
  midi_128 (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  midi_128::
  midi_128 (const midi_128& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  midi_128::
  midi_128 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  midi_128::
  midi_128 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  midi_128::
  midi_128 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  midi_128* midi_128::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class midi_128 (*this, f, c);
  }

  midi_128::
  ~midi_128 ()
  {
  }

  // midi_16384
  //

  midi_16384::
  midi_16384 (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  midi_16384::
  midi_16384 (const midi_16384& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  midi_16384::
  midi_16384 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  midi_16384::
  midi_16384 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  midi_16384::
  midi_16384 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  midi_16384* midi_16384::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class midi_16384 (*this, f, c);
  }

  midi_16384::
  ~midi_16384 ()
  {
  }

  // mute
  //

  mute::
  mute (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_mute_convert ();
  }

  mute::
  mute (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_mute_convert ();
  }

  mute::
  mute (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_mute_convert ();
  }

  mute* mute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mute (*this, f, c);
  }

  mute::value mute::
  _xsd_mute_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_mute_literals_);
    const value* i (::std::lower_bound (
                      _xsd_mute_indexes_,
                      _xsd_mute_indexes_ + 15,
                      *this,
                      c));

    if (i == _xsd_mute_indexes_ + 15 || _xsd_mute_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const mute::
  _xsd_mute_literals_[15] =
  {
    "on",
    "off",
    "straight",
    "cup",
    "harmon-no-stem",
    "harmon-stem",
    "bucket",
    "plunger",
    "hat",
    "solotone",
    "practice",
    "stop-mute",
    "stop-hand",
    "echo",
    "palm"
  };

  const mute::value mute::
  _xsd_mute_indexes_[15] =
  {
    ::musicxml::mute::bucket,
    ::musicxml::mute::cup,
    ::musicxml::mute::echo,
    ::musicxml::mute::harmon_no_stem,
    ::musicxml::mute::harmon_stem,
    ::musicxml::mute::hat,
    ::musicxml::mute::off,
    ::musicxml::mute::on,
    ::musicxml::mute::palm,
    ::musicxml::mute::plunger,
    ::musicxml::mute::practice,
    ::musicxml::mute::solotone,
    ::musicxml::mute::stop_hand,
    ::musicxml::mute::stop_mute,
    ::musicxml::mute::straight
  };

  // non_negative_decimal
  //

  non_negative_decimal::
  non_negative_decimal (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  non_negative_decimal::
  non_negative_decimal (const non_negative_decimal& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  non_negative_decimal::
  non_negative_decimal (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  non_negative_decimal::
  non_negative_decimal (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  non_negative_decimal::
  non_negative_decimal (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  non_negative_decimal* non_negative_decimal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class non_negative_decimal (*this, f, c);
  }

  non_negative_decimal::
  ~non_negative_decimal ()
  {
  }

  // number_level
  //

  number_level::
  number_level (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  number_level::
  number_level (const number_level& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  number_level::
  number_level (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  number_level::
  number_level (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  number_level::
  number_level (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  number_level* number_level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class number_level (*this, f, c);
  }

  number_level::
  ~number_level ()
  {
  }

  // number_of_lines
  //

  number_of_lines::
  number_of_lines (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base)
  {
  }

  number_of_lines::
  number_of_lines (const number_of_lines& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  number_of_lines::
  number_of_lines (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  number_of_lines::
  number_of_lines (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  number_of_lines::
  number_of_lines (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  number_of_lines* number_of_lines::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class number_of_lines (*this, f, c);
  }

  number_of_lines::
  ~number_of_lines ()
  {
  }

  // number_or_normal
  //

  number_or_normal::
  number_or_normal (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  number_or_normal::
  number_or_normal (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  number_or_normal::
  number_or_normal (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  number_or_normal* number_or_normal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class number_or_normal (*this, f, c);
  }

  // numeral_value
  //

  numeral_value::
  numeral_value (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  numeral_value::
  numeral_value (const numeral_value& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  numeral_value::
  numeral_value (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  numeral_value::
  numeral_value (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  numeral_value::
  numeral_value (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  numeral_value* numeral_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class numeral_value (*this, f, c);
  }

  numeral_value::
  ~numeral_value ()
  {
  }

  // over_under
  //

  over_under::
  over_under (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_over_under_convert ();
  }

  over_under::
  over_under (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_over_under_convert ();
  }

  over_under::
  over_under (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_over_under_convert ();
  }

  over_under* over_under::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class over_under (*this, f, c);
  }

  over_under::value over_under::
  _xsd_over_under_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_over_under_literals_);
    const value* i (::std::lower_bound (
                      _xsd_over_under_indexes_,
                      _xsd_over_under_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_over_under_indexes_ + 2 || _xsd_over_under_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const over_under::
  _xsd_over_under_literals_[2] =
  {
    "over",
    "under"
  };

  const over_under::value over_under::
  _xsd_over_under_indexes_[2] =
  {
    ::musicxml::over_under::over,
    ::musicxml::over_under::under
  };

  // percent
  //

  percent::
  percent (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  percent::
  percent (const percent& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  percent::
  percent (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  percent::
  percent (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  percent::
  percent (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  percent* percent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class percent (*this, f, c);
  }

  percent::
  ~percent ()
  {
  }

  // positive_decimal
  //

  positive_decimal::
  positive_decimal (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  positive_decimal::
  positive_decimal (const positive_decimal& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  positive_decimal::
  positive_decimal (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  positive_decimal::
  positive_decimal (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  positive_decimal::
  positive_decimal (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  positive_decimal* positive_decimal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positive_decimal (*this, f, c);
  }

  positive_decimal::
  ~positive_decimal ()
  {
  }

  // positive_divisions
  //

  positive_divisions::
  positive_divisions (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::musicxml::divisions (_xsd_decimal_base)
  {
  }

  positive_divisions::
  positive_divisions (const positive_divisions& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::musicxml::divisions (x, f, c)
  {
  }

  positive_divisions::
  positive_divisions (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::musicxml::divisions (e, f, c)
  {
  }

  positive_divisions::
  positive_divisions (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::musicxml::divisions (a, f, c)
  {
  }

  positive_divisions::
  positive_divisions (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::musicxml::divisions (s, e, f, c)
  {
  }

  positive_divisions* positive_divisions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positive_divisions (*this, f, c);
  }

  positive_divisions::
  ~positive_divisions ()
  {
  }

  // positive_integer_or_empty
  //

  positive_integer_or_empty::
  positive_integer_or_empty (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  positive_integer_or_empty::
  positive_integer_or_empty (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  positive_integer_or_empty::
  positive_integer_or_empty (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  positive_integer_or_empty* positive_integer_or_empty::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positive_integer_or_empty (*this, f, c);
  }

  // rotation_degrees
  //

  rotation_degrees::
  rotation_degrees (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  rotation_degrees::
  rotation_degrees (const rotation_degrees& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  rotation_degrees::
  rotation_degrees (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  rotation_degrees::
  rotation_degrees (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  rotation_degrees::
  rotation_degrees (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  rotation_degrees* rotation_degrees::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rotation_degrees (*this, f, c);
  }

  rotation_degrees::
  ~rotation_degrees ()
  {
  }

  // semi_pitched
  //

  semi_pitched::
  semi_pitched (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_semi_pitched_convert ();
  }

  semi_pitched::
  semi_pitched (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_semi_pitched_convert ();
  }

  semi_pitched::
  semi_pitched (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_semi_pitched_convert ();
  }

  semi_pitched* semi_pitched::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class semi_pitched (*this, f, c);
  }

  semi_pitched::value semi_pitched::
  _xsd_semi_pitched_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_semi_pitched_literals_);
    const value* i (::std::lower_bound (
                      _xsd_semi_pitched_indexes_,
                      _xsd_semi_pitched_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_semi_pitched_indexes_ + 6 || _xsd_semi_pitched_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const semi_pitched::
  _xsd_semi_pitched_literals_[6] =
  {
    "high",
    "medium-high",
    "medium",
    "medium-low",
    "low",
    "very-low"
  };

  const semi_pitched::value semi_pitched::
  _xsd_semi_pitched_indexes_[6] =
  {
    ::musicxml::semi_pitched::high,
    ::musicxml::semi_pitched::low,
    ::musicxml::semi_pitched::medium,
    ::musicxml::semi_pitched::medium_high,
    ::musicxml::semi_pitched::medium_low,
    ::musicxml::semi_pitched::very_low
  };

  // smufl_glyph_name
  //

  smufl_glyph_name::
  smufl_glyph_name (const char* _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::xml_schema::nmtoken (_xsd_nmtoken_base)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const smufl_glyph_name& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (x, f, c)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (e, f, c)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (a, f, c)
  {
  }

  smufl_glyph_name::
  smufl_glyph_name (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::nmtoken (s, e, f, c)
  {
  }

  smufl_glyph_name* smufl_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_glyph_name (*this, f, c);
  }

  smufl_glyph_name::
  ~smufl_glyph_name ()
  {
  }

  // smufl_accidental_glyph_name
  //

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const smufl_accidental_glyph_name& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_accidental_glyph_name::
  smufl_accidental_glyph_name (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_accidental_glyph_name* smufl_accidental_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_accidental_glyph_name (*this, f, c);
  }

  smufl_accidental_glyph_name::
  ~smufl_accidental_glyph_name ()
  {
  }

  // smufl_coda_glyph_name
  //

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const smufl_coda_glyph_name& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_coda_glyph_name::
  smufl_coda_glyph_name (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_coda_glyph_name* smufl_coda_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_coda_glyph_name (*this, f, c);
  }

  smufl_coda_glyph_name::
  ~smufl_coda_glyph_name ()
  {
  }

  // smufl_lyrics_glyph_name
  //

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const smufl_lyrics_glyph_name& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_lyrics_glyph_name::
  smufl_lyrics_glyph_name (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_lyrics_glyph_name* smufl_lyrics_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_lyrics_glyph_name (*this, f, c);
  }

  smufl_lyrics_glyph_name::
  ~smufl_lyrics_glyph_name ()
  {
  }

  // smufl_pictogram_glyph_name
  //

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const smufl_pictogram_glyph_name& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_pictogram_glyph_name::
  smufl_pictogram_glyph_name (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_pictogram_glyph_name* smufl_pictogram_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_pictogram_glyph_name (*this, f, c);
  }

  smufl_pictogram_glyph_name::
  ~smufl_pictogram_glyph_name ()
  {
  }

  // smufl_segno_glyph_name
  //

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const smufl_segno_glyph_name& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_segno_glyph_name::
  smufl_segno_glyph_name (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_segno_glyph_name* smufl_segno_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_segno_glyph_name (*this, f, c);
  }

  smufl_segno_glyph_name::
  ~smufl_segno_glyph_name ()
  {
  }

  // smufl_wavy_line_glyph_name
  //

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const smufl_wavy_line_glyph_name& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f, c)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (a, f, c)
  {
  }

  smufl_wavy_line_glyph_name::
  smufl_wavy_line_glyph_name (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (s, e, f, c)
  {
  }

  smufl_wavy_line_glyph_name* smufl_wavy_line_glyph_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class smufl_wavy_line_glyph_name (*this, f, c);
  }

  smufl_wavy_line_glyph_name::
  ~smufl_wavy_line_glyph_name ()
  {
  }

  // start_note
  //

  start_note::
  start_note (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_note_convert ();
  }

  start_note::
  start_note (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_note_convert ();
  }

  start_note::
  start_note (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_note_convert ();
  }

  start_note* start_note::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_note (*this, f, c);
  }

  start_note::value start_note::
  _xsd_start_note_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_note_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_note_indexes_,
                      _xsd_start_note_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_start_note_indexes_ + 3 || _xsd_start_note_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_note::
  _xsd_start_note_literals_[3] =
  {
    "upper",
    "main",
    "below"
  };

  const start_note::value start_note::
  _xsd_start_note_indexes_[3] =
  {
    ::musicxml::start_note::below,
    ::musicxml::start_note::main,
    ::musicxml::start_note::upper
  };

  // start_stop
  //

  start_stop::
  start_stop (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_stop_convert ();
  }

  start_stop::
  start_stop (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_stop_convert ();
  }

  start_stop::
  start_stop (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_stop_convert ();
  }

  start_stop* start_stop::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_stop (*this, f, c);
  }

  start_stop::value start_stop::
  _xsd_start_stop_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_stop_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_stop_indexes_,
                      _xsd_start_stop_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_start_stop_indexes_ + 2 || _xsd_start_stop_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_stop::
  _xsd_start_stop_literals_[2] =
  {
    "start",
    "stop"
  };

  const start_stop::value start_stop::
  _xsd_start_stop_indexes_[2] =
  {
    ::musicxml::start_stop::start,
    ::musicxml::start_stop::stop
  };

  // start_stop_continue
  //

  start_stop_continue::
  start_stop_continue (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_stop_continue_convert ();
  }

  start_stop_continue::
  start_stop_continue (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_stop_continue_convert ();
  }

  start_stop_continue::
  start_stop_continue (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_stop_continue_convert ();
  }

  start_stop_continue* start_stop_continue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_stop_continue (*this, f, c);
  }

  start_stop_continue::value start_stop_continue::
  _xsd_start_stop_continue_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_stop_continue_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_stop_continue_indexes_,
                      _xsd_start_stop_continue_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_start_stop_continue_indexes_ + 3 || _xsd_start_stop_continue_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_stop_continue::
  _xsd_start_stop_continue_literals_[3] =
  {
    "start",
    "stop",
    "continue"
  };

  const start_stop_continue::value start_stop_continue::
  _xsd_start_stop_continue_indexes_[3] =
  {
    ::musicxml::start_stop_continue::continue_,
    ::musicxml::start_stop_continue::start,
    ::musicxml::start_stop_continue::stop
  };

  // start_stop_single
  //

  start_stop_single::
  start_stop_single (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_stop_single_convert ();
  }

  start_stop_single::
  start_stop_single (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_stop_single_convert ();
  }

  start_stop_single::
  start_stop_single (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_stop_single_convert ();
  }

  start_stop_single* start_stop_single::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_stop_single (*this, f, c);
  }

  start_stop_single::value start_stop_single::
  _xsd_start_stop_single_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_stop_single_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_stop_single_indexes_,
                      _xsd_start_stop_single_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_start_stop_single_indexes_ + 3 || _xsd_start_stop_single_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_stop_single::
  _xsd_start_stop_single_literals_[3] =
  {
    "start",
    "stop",
    "single"
  };

  const start_stop_single::value start_stop_single::
  _xsd_start_stop_single_indexes_[3] =
  {
    ::musicxml::start_stop_single::single,
    ::musicxml::start_stop_single::start,
    ::musicxml::start_stop_single::stop
  };

  // string_number
  //

  string_number::
  string_number (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  string_number::
  string_number (const string_number& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  string_number::
  string_number (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  string_number::
  string_number (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  string_number::
  string_number (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  string_number* string_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class string_number (*this, f, c);
  }

  string_number::
  ~string_number ()
  {
  }

  // symbol_size
  //

  symbol_size::
  symbol_size (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_symbol_size_convert ();
  }

  symbol_size::
  symbol_size (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_symbol_size_convert ();
  }

  symbol_size::
  symbol_size (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_symbol_size_convert ();
  }

  symbol_size* symbol_size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class symbol_size (*this, f, c);
  }

  symbol_size::value symbol_size::
  _xsd_symbol_size_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_symbol_size_literals_);
    const value* i (::std::lower_bound (
                      _xsd_symbol_size_indexes_,
                      _xsd_symbol_size_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_symbol_size_indexes_ + 4 || _xsd_symbol_size_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const symbol_size::
  _xsd_symbol_size_literals_[4] =
  {
    "full",
    "cue",
    "grace-cue",
    "large"
  };

  const symbol_size::value symbol_size::
  _xsd_symbol_size_indexes_[4] =
  {
    ::musicxml::symbol_size::cue,
    ::musicxml::symbol_size::full,
    ::musicxml::symbol_size::grace_cue,
    ::musicxml::symbol_size::large
  };

  // tenths
  //

  tenths::
  tenths (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  tenths::
  tenths (const tenths& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  tenths::
  tenths (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  tenths::
  tenths (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  tenths::
  tenths (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  tenths* tenths::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tenths (*this, f, c);
  }

  tenths::
  ~tenths ()
  {
  }

  // text_direction
  //

  text_direction::
  text_direction (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_text_direction_convert ();
  }

  text_direction::
  text_direction (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_text_direction_convert ();
  }

  text_direction::
  text_direction (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_text_direction_convert ();
  }

  text_direction* text_direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class text_direction (*this, f, c);
  }

  text_direction::value text_direction::
  _xsd_text_direction_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_text_direction_literals_);
    const value* i (::std::lower_bound (
                      _xsd_text_direction_indexes_,
                      _xsd_text_direction_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_text_direction_indexes_ + 4 || _xsd_text_direction_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const text_direction::
  _xsd_text_direction_literals_[4] =
  {
    "ltr",
    "rtl",
    "lro",
    "rlo"
  };

  const text_direction::value text_direction::
  _xsd_text_direction_indexes_[4] =
  {
    ::musicxml::text_direction::lro,
    ::musicxml::text_direction::ltr,
    ::musicxml::text_direction::rlo,
    ::musicxml::text_direction::rtl
  };

  // tied_type
  //

  tied_type::
  tied_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_tied_type_convert ();
  }

  tied_type::
  tied_type (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_tied_type_convert ();
  }

  tied_type::
  tied_type (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_tied_type_convert ();
  }

  tied_type* tied_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tied_type (*this, f, c);
  }

  tied_type::value tied_type::
  _xsd_tied_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tied_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_tied_type_indexes_,
                      _xsd_tied_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_tied_type_indexes_ + 4 || _xsd_tied_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const tied_type::
  _xsd_tied_type_literals_[4] =
  {
    "start",
    "stop",
    "continue",
    "let-ring"
  };

  const tied_type::value tied_type::
  _xsd_tied_type_indexes_[4] =
  {
    ::musicxml::tied_type::continue_,
    ::musicxml::tied_type::let_ring,
    ::musicxml::tied_type::start,
    ::musicxml::tied_type::stop
  };

  // time_only
  //

  time_only::
  time_only ()
  : ::xml_schema::token ()
  {
  }

  time_only::
  time_only (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  time_only::
  time_only (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  time_only::
  time_only (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  time_only::
  time_only (const time_only& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  time_only::
  time_only (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  time_only::
  time_only (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  time_only::
  time_only (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  time_only* time_only::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time_only (*this, f, c);
  }

  time_only::
  ~time_only ()
  {
  }

  // top_bottom
  //

  top_bottom::
  top_bottom (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_top_bottom_convert ();
  }

  top_bottom::
  top_bottom (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_top_bottom_convert ();
  }

  top_bottom::
  top_bottom (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_top_bottom_convert ();
  }

  top_bottom* top_bottom::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class top_bottom (*this, f, c);
  }

  top_bottom::value top_bottom::
  _xsd_top_bottom_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_top_bottom_literals_);
    const value* i (::std::lower_bound (
                      _xsd_top_bottom_indexes_,
                      _xsd_top_bottom_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_top_bottom_indexes_ + 2 || _xsd_top_bottom_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const top_bottom::
  _xsd_top_bottom_literals_[2] =
  {
    "top",
    "bottom"
  };

  const top_bottom::value top_bottom::
  _xsd_top_bottom_indexes_[2] =
  {
    ::musicxml::top_bottom::bottom,
    ::musicxml::top_bottom::top
  };

  // tremolo_type
  //

  tremolo_type::
  tremolo_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_tremolo_type_convert ();
  }

  tremolo_type::
  tremolo_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_tremolo_type_convert ();
  }

  tremolo_type::
  tremolo_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_tremolo_type_convert ();
  }

  tremolo_type* tremolo_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tremolo_type (*this, f, c);
  }

  tremolo_type::value tremolo_type::
  _xsd_tremolo_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tremolo_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_tremolo_type_indexes_,
                      _xsd_tremolo_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_tremolo_type_indexes_ + 4 || _xsd_tremolo_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const tremolo_type::
  _xsd_tremolo_type_literals_[4] =
  {
    "start",
    "stop",
    "single",
    "unmeasured"
  };

  const tremolo_type::value tremolo_type::
  _xsd_tremolo_type_indexes_[4] =
  {
    ::musicxml::tremolo_type::single,
    ::musicxml::tremolo_type::start,
    ::musicxml::tremolo_type::stop,
    ::musicxml::tremolo_type::unmeasured
  };

  // trill_beats
  //

  trill_beats::
  trill_beats (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  trill_beats::
  trill_beats (const trill_beats& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  trill_beats::
  trill_beats (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  trill_beats::
  trill_beats (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  trill_beats::
  trill_beats (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  trill_beats* trill_beats::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class trill_beats (*this, f, c);
  }

  trill_beats::
  ~trill_beats ()
  {
  }

  // trill_step
  //

  trill_step::
  trill_step (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_trill_step_convert ();
  }

  trill_step::
  trill_step (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_trill_step_convert ();
  }

  trill_step::
  trill_step (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_trill_step_convert ();
  }

  trill_step* trill_step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class trill_step (*this, f, c);
  }

  trill_step::value trill_step::
  _xsd_trill_step_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_trill_step_literals_);
    const value* i (::std::lower_bound (
                      _xsd_trill_step_indexes_,
                      _xsd_trill_step_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_trill_step_indexes_ + 3 || _xsd_trill_step_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const trill_step::
  _xsd_trill_step_literals_[3] =
  {
    "whole",
    "half",
    "unison"
  };

  const trill_step::value trill_step::
  _xsd_trill_step_indexes_[3] =
  {
    ::musicxml::trill_step::half,
    ::musicxml::trill_step::unison,
    ::musicxml::trill_step::whole
  };

  // two_note_turn
  //

  two_note_turn::
  two_note_turn (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_two_note_turn_convert ();
  }

  two_note_turn::
  two_note_turn (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_two_note_turn_convert ();
  }

  two_note_turn::
  two_note_turn (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_two_note_turn_convert ();
  }

  two_note_turn* two_note_turn::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class two_note_turn (*this, f, c);
  }

  two_note_turn::value two_note_turn::
  _xsd_two_note_turn_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_two_note_turn_literals_);
    const value* i (::std::lower_bound (
                      _xsd_two_note_turn_indexes_,
                      _xsd_two_note_turn_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_two_note_turn_indexes_ + 3 || _xsd_two_note_turn_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const two_note_turn::
  _xsd_two_note_turn_literals_[3] =
  {
    "whole",
    "half",
    "none"
  };

  const two_note_turn::value two_note_turn::
  _xsd_two_note_turn_indexes_[3] =
  {
    ::musicxml::two_note_turn::half,
    ::musicxml::two_note_turn::none,
    ::musicxml::two_note_turn::whole
  };

  // up_down
  //

  up_down::
  up_down (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_up_down_convert ();
  }

  up_down::
  up_down (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_up_down_convert ();
  }

  up_down::
  up_down (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_up_down_convert ();
  }

  up_down* up_down::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class up_down (*this, f, c);
  }

  up_down::value up_down::
  _xsd_up_down_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_up_down_literals_);
    const value* i (::std::lower_bound (
                      _xsd_up_down_indexes_,
                      _xsd_up_down_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_up_down_indexes_ + 2 || _xsd_up_down_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const up_down::
  _xsd_up_down_literals_[2] =
  {
    "up",
    "down"
  };

  const up_down::value up_down::
  _xsd_up_down_indexes_[2] =
  {
    ::musicxml::up_down::down,
    ::musicxml::up_down::up
  };

  // upright_inverted
  //

  upright_inverted::
  upright_inverted (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_upright_inverted_convert ();
  }

  upright_inverted::
  upright_inverted (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_upright_inverted_convert ();
  }

  upright_inverted::
  upright_inverted (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_upright_inverted_convert ();
  }

  upright_inverted* upright_inverted::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class upright_inverted (*this, f, c);
  }

  upright_inverted::value upright_inverted::
  _xsd_upright_inverted_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_upright_inverted_literals_);
    const value* i (::std::lower_bound (
                      _xsd_upright_inverted_indexes_,
                      _xsd_upright_inverted_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_upright_inverted_indexes_ + 2 || _xsd_upright_inverted_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const upright_inverted::
  _xsd_upright_inverted_literals_[2] =
  {
    "upright",
    "inverted"
  };

  const upright_inverted::value upright_inverted::
  _xsd_upright_inverted_indexes_[2] =
  {
    ::musicxml::upright_inverted::inverted,
    ::musicxml::upright_inverted::upright
  };

  // valign
  //

  valign::
  valign (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_valign_convert ();
  }

  valign::
  valign (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_valign_convert ();
  }

  valign::
  valign (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_valign_convert ();
  }

  valign* valign::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class valign (*this, f, c);
  }

  valign::value valign::
  _xsd_valign_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_valign_literals_);
    const value* i (::std::lower_bound (
                      _xsd_valign_indexes_,
                      _xsd_valign_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_valign_indexes_ + 4 || _xsd_valign_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const valign::
  _xsd_valign_literals_[4] =
  {
    "top",
    "middle",
    "bottom",
    "baseline"
  };

  const valign::value valign::
  _xsd_valign_indexes_[4] =
  {
    ::musicxml::valign::baseline,
    ::musicxml::valign::bottom,
    ::musicxml::valign::middle,
    ::musicxml::valign::top
  };

  // valign_image
  //

  valign_image::
  valign_image (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_valign_image_convert ();
  }

  valign_image::
  valign_image (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_valign_image_convert ();
  }

  valign_image::
  valign_image (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_valign_image_convert ();
  }

  valign_image* valign_image::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class valign_image (*this, f, c);
  }

  valign_image::value valign_image::
  _xsd_valign_image_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_valign_image_literals_);
    const value* i (::std::lower_bound (
                      _xsd_valign_image_indexes_,
                      _xsd_valign_image_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_valign_image_indexes_ + 3 || _xsd_valign_image_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const valign_image::
  _xsd_valign_image_literals_[3] =
  {
    "top",
    "middle",
    "bottom"
  };

  const valign_image::value valign_image::
  _xsd_valign_image_indexes_[3] =
  {
    ::musicxml::valign_image::bottom,
    ::musicxml::valign_image::middle,
    ::musicxml::valign_image::top
  };

  // yes_no
  //

  yes_no::
  yes_no (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_yes_no_convert ();
  }

  yes_no::
  yes_no (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_yes_no_convert ();
  }

  yes_no::
  yes_no (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_yes_no_convert ();
  }

  yes_no* yes_no::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yes_no (*this, f, c);
  }

  yes_no::value yes_no::
  _xsd_yes_no_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yes_no_literals_);
    const value* i (::std::lower_bound (
                      _xsd_yes_no_indexes_,
                      _xsd_yes_no_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_yes_no_indexes_ + 2 || _xsd_yes_no_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const yes_no::
  _xsd_yes_no_literals_[2] =
  {
    "yes",
    "no"
  };

  const yes_no::value yes_no::
  _xsd_yes_no_indexes_[2] =
  {
    ::musicxml::yes_no::no,
    ::musicxml::yes_no::yes
  };

  // yes_no_number
  //

  yes_no_number::
  yes_no_number (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  yes_no_number::
  yes_no_number (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  yes_no_number::
  yes_no_number (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  yes_no_number* yes_no_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yes_no_number (*this, f, c);
  }

  // yyyy_mm_dd
  //

  yyyy_mm_dd::
  yyyy_mm_dd (const ::xml_schema::date& _xsd_date_base)
  : ::xml_schema::date (_xsd_date_base)
  {
  }

  yyyy_mm_dd::
  yyyy_mm_dd (const yyyy_mm_dd& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::date (x, f, c)
  {
  }

  yyyy_mm_dd::
  yyyy_mm_dd (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::date (e, f, c)
  {
  }

  yyyy_mm_dd::
  yyyy_mm_dd (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::date (a, f, c)
  {
  }

  yyyy_mm_dd::
  yyyy_mm_dd (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::date (s, e, f, c)
  {
  }

  yyyy_mm_dd* yyyy_mm_dd::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class yyyy_mm_dd (*this, f, c);
  }

  yyyy_mm_dd::
  ~yyyy_mm_dd ()
  {
  }

  // cancel_location
  //

  cancel_location::
  cancel_location (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_cancel_location_convert ();
  }

  cancel_location::
  cancel_location (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_cancel_location_convert ();
  }

  cancel_location::
  cancel_location (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_cancel_location_convert ();
  }

  cancel_location* cancel_location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cancel_location (*this, f, c);
  }

  cancel_location::value cancel_location::
  _xsd_cancel_location_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_cancel_location_literals_);
    const value* i (::std::lower_bound (
                      _xsd_cancel_location_indexes_,
                      _xsd_cancel_location_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_cancel_location_indexes_ + 3 || _xsd_cancel_location_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const cancel_location::
  _xsd_cancel_location_literals_[3] =
  {
    "left",
    "right",
    "before-barline"
  };

  const cancel_location::value cancel_location::
  _xsd_cancel_location_indexes_[3] =
  {
    ::musicxml::cancel_location::before_barline,
    ::musicxml::cancel_location::left,
    ::musicxml::cancel_location::right
  };

  // clef_sign
  //

  clef_sign::
  clef_sign (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_clef_sign_convert ();
  }

  clef_sign::
  clef_sign (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_clef_sign_convert ();
  }

  clef_sign::
  clef_sign (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_clef_sign_convert ();
  }

  clef_sign* clef_sign::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class clef_sign (*this, f, c);
  }

  clef_sign::value clef_sign::
  _xsd_clef_sign_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_clef_sign_literals_);
    const value* i (::std::lower_bound (
                      _xsd_clef_sign_indexes_,
                      _xsd_clef_sign_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_clef_sign_indexes_ + 7 || _xsd_clef_sign_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const clef_sign::
  _xsd_clef_sign_literals_[7] =
  {
    "G",
    "F",
    "C",
    "percussion",
    "TAB",
    "jianpu",
    "none"
  };

  const clef_sign::value clef_sign::
  _xsd_clef_sign_indexes_[7] =
  {
    ::musicxml::clef_sign::C,
    ::musicxml::clef_sign::F,
    ::musicxml::clef_sign::G,
    ::musicxml::clef_sign::TAB,
    ::musicxml::clef_sign::jianpu,
    ::musicxml::clef_sign::none,
    ::musicxml::clef_sign::percussion
  };

  // fifths
  //

  fifths::
  fifths (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  fifths::
  fifths (const fifths& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  fifths::
  fifths (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  fifths::
  fifths (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  fifths::
  fifths (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  fifths* fifths::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fifths (*this, f, c);
  }

  fifths::
  ~fifths ()
  {
  }

  // mode
  //

  mode::
  mode ()
  : ::xml_schema::string ()
  {
  }

  mode::
  mode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  mode::
  mode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  mode::
  mode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  mode::
  mode (const mode& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  mode::
  mode (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  mode::
  mode (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  mode::
  mode (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  mode* mode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mode (*this, f, c);
  }

  mode::
  ~mode ()
  {
  }

  // show_frets
  //

  show_frets::
  show_frets (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_show_frets_convert ();
  }

  show_frets::
  show_frets (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_show_frets_convert ();
  }

  show_frets::
  show_frets (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_show_frets_convert ();
  }

  show_frets* show_frets::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class show_frets (*this, f, c);
  }

  show_frets::value show_frets::
  _xsd_show_frets_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_show_frets_literals_);
    const value* i (::std::lower_bound (
                      _xsd_show_frets_indexes_,
                      _xsd_show_frets_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_show_frets_indexes_ + 2 || _xsd_show_frets_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const show_frets::
  _xsd_show_frets_literals_[2] =
  {
    "numbers",
    "letters"
  };

  const show_frets::value show_frets::
  _xsd_show_frets_indexes_[2] =
  {
    ::musicxml::show_frets::letters,
    ::musicxml::show_frets::numbers
  };

  // staff_line
  //

  staff_line::
  staff_line (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  staff_line::
  staff_line (const staff_line& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  staff_line::
  staff_line (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  staff_line::
  staff_line (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  staff_line::
  staff_line (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  staff_line* staff_line::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_line (*this, f, c);
  }

  staff_line::
  ~staff_line ()
  {
  }

  // staff_line_position
  //

  staff_line_position::
  staff_line_position (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  staff_line_position::
  staff_line_position (const staff_line_position& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  staff_line_position::
  staff_line_position (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  staff_line_position::
  staff_line_position (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  staff_line_position::
  staff_line_position (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  staff_line_position* staff_line_position::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_line_position (*this, f, c);
  }

  staff_line_position::
  ~staff_line_position ()
  {
  }

  // staff_number
  //

  staff_number::
  staff_number (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  staff_number::
  staff_number (const staff_number& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  staff_number::
  staff_number (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  staff_number::
  staff_number (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  staff_number::
  staff_number (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  staff_number* staff_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_number (*this, f, c);
  }

  staff_number::
  ~staff_number ()
  {
  }

  // staff_type
  //

  staff_type::
  staff_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_staff_type_convert ();
  }

  staff_type::
  staff_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_staff_type_convert ();
  }

  staff_type::
  staff_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_staff_type_convert ();
  }

  staff_type* staff_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_type (*this, f, c);
  }

  staff_type::value staff_type::
  _xsd_staff_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_staff_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_staff_type_indexes_,
                      _xsd_staff_type_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_staff_type_indexes_ + 5 || _xsd_staff_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const staff_type::
  _xsd_staff_type_literals_[5] =
  {
    "ossia",
    "editorial",
    "cue",
    "alternate",
    "regular"
  };

  const staff_type::value staff_type::
  _xsd_staff_type_indexes_[5] =
  {
    ::musicxml::staff_type::alternate,
    ::musicxml::staff_type::cue,
    ::musicxml::staff_type::editorial,
    ::musicxml::staff_type::ossia,
    ::musicxml::staff_type::regular
  };

  // time_relation
  //

  time_relation::
  time_relation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_time_relation_convert ();
  }

  time_relation::
  time_relation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_time_relation_convert ();
  }

  time_relation::
  time_relation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_time_relation_convert ();
  }

  time_relation* time_relation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time_relation (*this, f, c);
  }

  time_relation::value time_relation::
  _xsd_time_relation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_time_relation_literals_);
    const value* i (::std::lower_bound (
                      _xsd_time_relation_indexes_,
                      _xsd_time_relation_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_time_relation_indexes_ + 6 || _xsd_time_relation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const time_relation::
  _xsd_time_relation_literals_[6] =
  {
    "parentheses",
    "bracket",
    "equals",
    "slash",
    "space",
    "hyphen"
  };

  const time_relation::value time_relation::
  _xsd_time_relation_indexes_[6] =
  {
    ::musicxml::time_relation::bracket,
    ::musicxml::time_relation::equals,
    ::musicxml::time_relation::hyphen,
    ::musicxml::time_relation::parentheses,
    ::musicxml::time_relation::slash,
    ::musicxml::time_relation::space
  };

  // time_separator
  //

  time_separator::
  time_separator (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_time_separator_convert ();
  }

  time_separator::
  time_separator (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_time_separator_convert ();
  }

  time_separator::
  time_separator (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_time_separator_convert ();
  }

  time_separator* time_separator::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time_separator (*this, f, c);
  }

  time_separator::value time_separator::
  _xsd_time_separator_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_time_separator_literals_);
    const value* i (::std::lower_bound (
                      _xsd_time_separator_indexes_,
                      _xsd_time_separator_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_time_separator_indexes_ + 5 || _xsd_time_separator_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const time_separator::
  _xsd_time_separator_literals_[5] =
  {
    "none",
    "horizontal",
    "diagonal",
    "vertical",
    "adjacent"
  };

  const time_separator::value time_separator::
  _xsd_time_separator_indexes_[5] =
  {
    ::musicxml::time_separator::adjacent,
    ::musicxml::time_separator::diagonal,
    ::musicxml::time_separator::horizontal,
    ::musicxml::time_separator::none,
    ::musicxml::time_separator::vertical
  };

  // time_symbol
  //

  time_symbol::
  time_symbol (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_time_symbol_convert ();
  }

  time_symbol::
  time_symbol (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_time_symbol_convert ();
  }

  time_symbol::
  time_symbol (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_time_symbol_convert ();
  }

  time_symbol* time_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time_symbol (*this, f, c);
  }

  time_symbol::value time_symbol::
  _xsd_time_symbol_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_time_symbol_literals_);
    const value* i (::std::lower_bound (
                      _xsd_time_symbol_indexes_,
                      _xsd_time_symbol_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_time_symbol_indexes_ + 6 || _xsd_time_symbol_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const time_symbol::
  _xsd_time_symbol_literals_[6] =
  {
    "common",
    "cut",
    "single-number",
    "note",
    "dotted-note",
    "normal"
  };

  const time_symbol::value time_symbol::
  _xsd_time_symbol_indexes_[6] =
  {
    ::musicxml::time_symbol::common,
    ::musicxml::time_symbol::cut,
    ::musicxml::time_symbol::dotted_note,
    ::musicxml::time_symbol::normal,
    ::musicxml::time_symbol::note,
    ::musicxml::time_symbol::single_number
  };

  // backward_forward
  //

  backward_forward::
  backward_forward (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_backward_forward_convert ();
  }

  backward_forward::
  backward_forward (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_backward_forward_convert ();
  }

  backward_forward::
  backward_forward (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_backward_forward_convert ();
  }

  backward_forward* backward_forward::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class backward_forward (*this, f, c);
  }

  backward_forward::value backward_forward::
  _xsd_backward_forward_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_backward_forward_literals_);
    const value* i (::std::lower_bound (
                      _xsd_backward_forward_indexes_,
                      _xsd_backward_forward_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_backward_forward_indexes_ + 2 || _xsd_backward_forward_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const backward_forward::
  _xsd_backward_forward_literals_[2] =
  {
    "backward",
    "forward"
  };

  const backward_forward::value backward_forward::
  _xsd_backward_forward_indexes_[2] =
  {
    ::musicxml::backward_forward::backward,
    ::musicxml::backward_forward::forward
  };

  // bar_style
  //

  bar_style::
  bar_style (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_bar_style_convert ();
  }

  bar_style::
  bar_style (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_bar_style_convert ();
  }

  bar_style::
  bar_style (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_bar_style_convert ();
  }

  bar_style* bar_style::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bar_style (*this, f, c);
  }

  bar_style::value bar_style::
  _xsd_bar_style_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bar_style_literals_);
    const value* i (::std::lower_bound (
                      _xsd_bar_style_indexes_,
                      _xsd_bar_style_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_bar_style_indexes_ + 11 || _xsd_bar_style_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const bar_style::
  _xsd_bar_style_literals_[11] =
  {
    "regular",
    "dotted",
    "dashed",
    "heavy",
    "light-light",
    "light-heavy",
    "heavy-light",
    "heavy-heavy",
    "tick",
    "short",
    "none"
  };

  const bar_style::value bar_style::
  _xsd_bar_style_indexes_[11] =
  {
    ::musicxml::bar_style::dashed,
    ::musicxml::bar_style::dotted,
    ::musicxml::bar_style::heavy,
    ::musicxml::bar_style::heavy_heavy,
    ::musicxml::bar_style::heavy_light,
    ::musicxml::bar_style::light_heavy,
    ::musicxml::bar_style::light_light,
    ::musicxml::bar_style::none,
    ::musicxml::bar_style::regular,
    ::musicxml::bar_style::short_,
    ::musicxml::bar_style::tick
  };

  // ending_number
  //

  ending_number::
  ending_number ()
  : ::xml_schema::token ()
  {
  }

  ending_number::
  ending_number (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ending_number::
  ending_number (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ending_number::
  ending_number (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  ending_number::
  ending_number (const ending_number& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  ending_number::
  ending_number (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  ending_number::
  ending_number (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  ending_number::
  ending_number (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  ending_number* ending_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ending_number (*this, f, c);
  }

  ending_number::
  ~ending_number ()
  {
  }

  // right_left_middle
  //

  right_left_middle::
  right_left_middle (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_right_left_middle_convert ();
  }

  right_left_middle::
  right_left_middle (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_right_left_middle_convert ();
  }

  right_left_middle::
  right_left_middle (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_right_left_middle_convert ();
  }

  right_left_middle* right_left_middle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class right_left_middle (*this, f, c);
  }

  right_left_middle::value right_left_middle::
  _xsd_right_left_middle_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_right_left_middle_literals_);
    const value* i (::std::lower_bound (
                      _xsd_right_left_middle_indexes_,
                      _xsd_right_left_middle_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_right_left_middle_indexes_ + 3 || _xsd_right_left_middle_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const right_left_middle::
  _xsd_right_left_middle_literals_[3] =
  {
    "right",
    "left",
    "middle"
  };

  const right_left_middle::value right_left_middle::
  _xsd_right_left_middle_indexes_[3] =
  {
    ::musicxml::right_left_middle::left,
    ::musicxml::right_left_middle::middle,
    ::musicxml::right_left_middle::right
  };

  // start_stop_discontinue
  //

  start_stop_discontinue::
  start_stop_discontinue (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_stop_discontinue_convert ();
  }

  start_stop_discontinue::
  start_stop_discontinue (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_stop_discontinue_convert ();
  }

  start_stop_discontinue::
  start_stop_discontinue (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_stop_discontinue_convert ();
  }

  start_stop_discontinue* start_stop_discontinue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_stop_discontinue (*this, f, c);
  }

  start_stop_discontinue::value start_stop_discontinue::
  _xsd_start_stop_discontinue_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_stop_discontinue_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_stop_discontinue_indexes_,
                      _xsd_start_stop_discontinue_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_start_stop_discontinue_indexes_ + 3 || _xsd_start_stop_discontinue_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_stop_discontinue::
  _xsd_start_stop_discontinue_literals_[3] =
  {
    "start",
    "stop",
    "discontinue"
  };

  const start_stop_discontinue::value start_stop_discontinue::
  _xsd_start_stop_discontinue_indexes_[3] =
  {
    ::musicxml::start_stop_discontinue::discontinue,
    ::musicxml::start_stop_discontinue::start,
    ::musicxml::start_stop_discontinue::stop
  };

  // winged
  //

  winged::
  winged (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_winged_convert ();
  }

  winged::
  winged (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_winged_convert ();
  }

  winged::
  winged (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_winged_convert ();
  }

  winged* winged::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class winged (*this, f, c);
  }

  winged::value winged::
  _xsd_winged_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_winged_literals_);
    const value* i (::std::lower_bound (
                      _xsd_winged_indexes_,
                      _xsd_winged_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_winged_indexes_ + 5 || _xsd_winged_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const winged::
  _xsd_winged_literals_[5] =
  {
    "none",
    "straight",
    "curved",
    "double-straight",
    "double-curved"
  };

  const winged::value winged::
  _xsd_winged_indexes_[5] =
  {
    ::musicxml::winged::curved,
    ::musicxml::winged::double_curved,
    ::musicxml::winged::double_straight,
    ::musicxml::winged::none,
    ::musicxml::winged::straight
  };

  // accordion_middle
  //

  accordion_middle::
  accordion_middle (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
  {
  }

  accordion_middle::
  accordion_middle (const accordion_middle& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  accordion_middle::
  accordion_middle (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  accordion_middle::
  accordion_middle (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  accordion_middle::
  accordion_middle (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  accordion_middle* accordion_middle::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accordion_middle (*this, f, c);
  }

  accordion_middle::
  ~accordion_middle ()
  {
  }

  // beater_value
  //

  beater_value::
  beater_value (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_beater_value_convert ();
  }

  beater_value::
  beater_value (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_beater_value_convert ();
  }

  beater_value::
  beater_value (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_beater_value_convert ();
  }

  beater_value* beater_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beater_value (*this, f, c);
  }

  beater_value::value beater_value::
  _xsd_beater_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_beater_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_beater_value_indexes_,
                      _xsd_beater_value_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_beater_value_indexes_ + 20 || _xsd_beater_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const beater_value::
  _xsd_beater_value_literals_[20] =
  {
    "bow",
    "chime hammer",
    "coin",
    "drum stick",
    "finger",
    "fingernail",
    "fist",
    "guiro scraper",
    "hammer",
    "hand",
    "jazz stick",
    "knitting needle",
    "metal hammer",
    "slide brush on gong",
    "snare stick",
    "spoon mallet",
    "superball",
    "triangle beater",
    "triangle beater plain",
    "wire brush"
  };

  const beater_value::value beater_value::
  _xsd_beater_value_indexes_[20] =
  {
    ::musicxml::beater_value::bow,
    ::musicxml::beater_value::chime_hammer,
    ::musicxml::beater_value::coin,
    ::musicxml::beater_value::drum_stick,
    ::musicxml::beater_value::finger,
    ::musicxml::beater_value::fingernail,
    ::musicxml::beater_value::fist,
    ::musicxml::beater_value::guiro_scraper,
    ::musicxml::beater_value::hammer,
    ::musicxml::beater_value::hand,
    ::musicxml::beater_value::jazz_stick,
    ::musicxml::beater_value::knitting_needle,
    ::musicxml::beater_value::metal_hammer,
    ::musicxml::beater_value::slide_brush_on_gong,
    ::musicxml::beater_value::snare_stick,
    ::musicxml::beater_value::spoon_mallet,
    ::musicxml::beater_value::superball,
    ::musicxml::beater_value::triangle_beater,
    ::musicxml::beater_value::triangle_beater_plain,
    ::musicxml::beater_value::wire_brush
  };

  // degree_symbol_value
  //

  degree_symbol_value::
  degree_symbol_value (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_degree_symbol_value_convert ();
  }

  degree_symbol_value::
  degree_symbol_value (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_degree_symbol_value_convert ();
  }

  degree_symbol_value::
  degree_symbol_value (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_degree_symbol_value_convert ();
  }

  degree_symbol_value* degree_symbol_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree_symbol_value (*this, f, c);
  }

  degree_symbol_value::value degree_symbol_value::
  _xsd_degree_symbol_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_degree_symbol_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_degree_symbol_value_indexes_,
                      _xsd_degree_symbol_value_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_degree_symbol_value_indexes_ + 5 || _xsd_degree_symbol_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const degree_symbol_value::
  _xsd_degree_symbol_value_literals_[5] =
  {
    "major",
    "minor",
    "augmented",
    "diminished",
    "half-diminished"
  };

  const degree_symbol_value::value degree_symbol_value::
  _xsd_degree_symbol_value_indexes_[5] =
  {
    ::musicxml::degree_symbol_value::augmented,
    ::musicxml::degree_symbol_value::diminished,
    ::musicxml::degree_symbol_value::half_diminished,
    ::musicxml::degree_symbol_value::major,
    ::musicxml::degree_symbol_value::minor
  };

  // degree_type_value
  //

  degree_type_value::
  degree_type_value (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_degree_type_value_convert ();
  }

  degree_type_value::
  degree_type_value (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_degree_type_value_convert ();
  }

  degree_type_value::
  degree_type_value (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_degree_type_value_convert ();
  }

  degree_type_value* degree_type_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree_type_value (*this, f, c);
  }

  degree_type_value::value degree_type_value::
  _xsd_degree_type_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_degree_type_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_degree_type_value_indexes_,
                      _xsd_degree_type_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_degree_type_value_indexes_ + 3 || _xsd_degree_type_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const degree_type_value::
  _xsd_degree_type_value_literals_[3] =
  {
    "add",
    "alter",
    "subtract"
  };

  const degree_type_value::value degree_type_value::
  _xsd_degree_type_value_indexes_[3] =
  {
    ::musicxml::degree_type_value::add,
    ::musicxml::degree_type_value::alter,
    ::musicxml::degree_type_value::subtract
  };

  // effect_value
  //

  effect_value::
  effect_value (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_effect_value_convert ();
  }

  effect_value::
  effect_value (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_effect_value_convert ();
  }

  effect_value::
  effect_value (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_effect_value_convert ();
  }

  effect_value* effect_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class effect_value (*this, f, c);
  }

  effect_value::value effect_value::
  _xsd_effect_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_effect_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_effect_value_indexes_,
                      _xsd_effect_value_indexes_ + 16,
                      *this,
                      c));

    if (i == _xsd_effect_value_indexes_ + 16 || _xsd_effect_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const effect_value::
  _xsd_effect_value_literals_[16] =
  {
    "anvil",
    "auto horn",
    "bird whistle",
    "cannon",
    "duck call",
    "gun shot",
    "klaxon horn",
    "lions roar",
    "lotus flute",
    "megaphone",
    "police whistle",
    "siren",
    "slide whistle",
    "thunder sheet",
    "wind machine",
    "wind whistle"
  };

  const effect_value::value effect_value::
  _xsd_effect_value_indexes_[16] =
  {
    ::musicxml::effect_value::anvil,
    ::musicxml::effect_value::auto_horn,
    ::musicxml::effect_value::bird_whistle,
    ::musicxml::effect_value::cannon,
    ::musicxml::effect_value::duck_call,
    ::musicxml::effect_value::gun_shot,
    ::musicxml::effect_value::klaxon_horn,
    ::musicxml::effect_value::lions_roar,
    ::musicxml::effect_value::lotus_flute,
    ::musicxml::effect_value::megaphone,
    ::musicxml::effect_value::police_whistle,
    ::musicxml::effect_value::siren,
    ::musicxml::effect_value::slide_whistle,
    ::musicxml::effect_value::thunder_sheet,
    ::musicxml::effect_value::wind_machine,
    ::musicxml::effect_value::wind_whistle
  };

  // glass_value
  //

  glass_value::
  glass_value (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_glass_value_convert ();
  }

  glass_value::
  glass_value (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_glass_value_convert ();
  }

  glass_value::
  glass_value (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_glass_value_convert ();
  }

  glass_value* glass_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class glass_value (*this, f, c);
  }

  glass_value::value glass_value::
  _xsd_glass_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_glass_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_glass_value_indexes_,
                      _xsd_glass_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_glass_value_indexes_ + 3 || _xsd_glass_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const glass_value::
  _xsd_glass_value_literals_[3] =
  {
    "glass harmonica",
    "glass harp",
    "wind chimes"
  };

  const glass_value::value glass_value::
  _xsd_glass_value_indexes_[3] =
  {
    ::musicxml::glass_value::glass_harmonica,
    ::musicxml::glass_value::glass_harp,
    ::musicxml::glass_value::wind_chimes
  };

  // harmony_arrangement
  //

  harmony_arrangement::
  harmony_arrangement (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_harmony_arrangement_convert ();
  }

  harmony_arrangement::
  harmony_arrangement (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_harmony_arrangement_convert ();
  }

  harmony_arrangement::
  harmony_arrangement (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_harmony_arrangement_convert ();
  }

  harmony_arrangement* harmony_arrangement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmony_arrangement (*this, f, c);
  }

  harmony_arrangement::value harmony_arrangement::
  _xsd_harmony_arrangement_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_harmony_arrangement_literals_);
    const value* i (::std::lower_bound (
                      _xsd_harmony_arrangement_indexes_,
                      _xsd_harmony_arrangement_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_harmony_arrangement_indexes_ + 3 || _xsd_harmony_arrangement_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const harmony_arrangement::
  _xsd_harmony_arrangement_literals_[3] =
  {
    "vertical",
    "horizontal",
    "diagonal"
  };

  const harmony_arrangement::value harmony_arrangement::
  _xsd_harmony_arrangement_indexes_[3] =
  {
    ::musicxml::harmony_arrangement::diagonal,
    ::musicxml::harmony_arrangement::horizontal,
    ::musicxml::harmony_arrangement::vertical
  };

  // harmony_type
  //

  harmony_type::
  harmony_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_harmony_type_convert ();
  }

  harmony_type::
  harmony_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_harmony_type_convert ();
  }

  harmony_type::
  harmony_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_harmony_type_convert ();
  }

  harmony_type* harmony_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmony_type (*this, f, c);
  }

  harmony_type::value harmony_type::
  _xsd_harmony_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_harmony_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_harmony_type_indexes_,
                      _xsd_harmony_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_harmony_type_indexes_ + 3 || _xsd_harmony_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const harmony_type::
  _xsd_harmony_type_literals_[3] =
  {
    "explicit",
    "implied",
    "alternate"
  };

  const harmony_type::value harmony_type::
  _xsd_harmony_type_indexes_[3] =
  {
    ::musicxml::harmony_type::alternate,
    ::musicxml::harmony_type::explicit_,
    ::musicxml::harmony_type::implied
  };

  // kind_value
  //

  kind_value::
  kind_value (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_kind_value_convert ();
  }

  kind_value::
  kind_value (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_kind_value_convert ();
  }

  kind_value::
  kind_value (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_kind_value_convert ();
  }

  kind_value* kind_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class kind_value (*this, f, c);
  }

  kind_value::value kind_value::
  _xsd_kind_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_kind_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_kind_value_indexes_,
                      _xsd_kind_value_indexes_ + 33,
                      *this,
                      c));

    if (i == _xsd_kind_value_indexes_ + 33 || _xsd_kind_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const kind_value::
  _xsd_kind_value_literals_[33] =
  {
    "major",
    "minor",
    "augmented",
    "diminished",
    "dominant",
    "major-seventh",
    "minor-seventh",
    "diminished-seventh",
    "augmented-seventh",
    "half-diminished",
    "major-minor",
    "major-sixth",
    "minor-sixth",
    "dominant-ninth",
    "major-ninth",
    "minor-ninth",
    "dominant-11th",
    "major-11th",
    "minor-11th",
    "dominant-13th",
    "major-13th",
    "minor-13th",
    "suspended-second",
    "suspended-fourth",
    "Neapolitan",
    "Italian",
    "French",
    "German",
    "pedal",
    "power",
    "Tristan",
    "other",
    "none"
  };

  const kind_value::value kind_value::
  _xsd_kind_value_indexes_[33] =
  {
    ::musicxml::kind_value::French,
    ::musicxml::kind_value::German,
    ::musicxml::kind_value::Italian,
    ::musicxml::kind_value::Neapolitan,
    ::musicxml::kind_value::Tristan,
    ::musicxml::kind_value::augmented,
    ::musicxml::kind_value::augmented_seventh,
    ::musicxml::kind_value::diminished,
    ::musicxml::kind_value::diminished_seventh,
    ::musicxml::kind_value::dominant,
    ::musicxml::kind_value::dominant_11th,
    ::musicxml::kind_value::dominant_13th,
    ::musicxml::kind_value::dominant_ninth,
    ::musicxml::kind_value::half_diminished,
    ::musicxml::kind_value::major,
    ::musicxml::kind_value::major_11th,
    ::musicxml::kind_value::major_13th,
    ::musicxml::kind_value::major_minor,
    ::musicxml::kind_value::major_ninth,
    ::musicxml::kind_value::major_seventh,
    ::musicxml::kind_value::major_sixth,
    ::musicxml::kind_value::minor,
    ::musicxml::kind_value::minor_11th,
    ::musicxml::kind_value::minor_13th,
    ::musicxml::kind_value::minor_ninth,
    ::musicxml::kind_value::minor_seventh,
    ::musicxml::kind_value::minor_sixth,
    ::musicxml::kind_value::none,
    ::musicxml::kind_value::other,
    ::musicxml::kind_value::pedal,
    ::musicxml::kind_value::power,
    ::musicxml::kind_value::suspended_fourth,
    ::musicxml::kind_value::suspended_second
  };

  // line_end
  //

  line_end::
  line_end (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_line_end_convert ();
  }

  line_end::
  line_end (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_line_end_convert ();
  }

  line_end::
  line_end (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_line_end_convert ();
  }

  line_end* line_end::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_end (*this, f, c);
  }

  line_end::value line_end::
  _xsd_line_end_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_line_end_literals_);
    const value* i (::std::lower_bound (
                      _xsd_line_end_indexes_,
                      _xsd_line_end_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_line_end_indexes_ + 5 || _xsd_line_end_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const line_end::
  _xsd_line_end_literals_[5] =
  {
    "up",
    "down",
    "both",
    "arrow",
    "none"
  };

  const line_end::value line_end::
  _xsd_line_end_indexes_[5] =
  {
    ::musicxml::line_end::arrow,
    ::musicxml::line_end::both,
    ::musicxml::line_end::down,
    ::musicxml::line_end::none,
    ::musicxml::line_end::up
  };

  // measure_numbering_value
  //

  measure_numbering_value::
  measure_numbering_value (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_measure_numbering_value_convert ();
  }

  measure_numbering_value::
  measure_numbering_value (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_measure_numbering_value_convert ();
  }

  measure_numbering_value::
  measure_numbering_value (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_measure_numbering_value_convert ();
  }

  measure_numbering_value* measure_numbering_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_numbering_value (*this, f, c);
  }

  measure_numbering_value::value measure_numbering_value::
  _xsd_measure_numbering_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_measure_numbering_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_measure_numbering_value_indexes_,
                      _xsd_measure_numbering_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_measure_numbering_value_indexes_ + 3 || _xsd_measure_numbering_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const measure_numbering_value::
  _xsd_measure_numbering_value_literals_[3] =
  {
    "none",
    "measure",
    "system"
  };

  const measure_numbering_value::value measure_numbering_value::
  _xsd_measure_numbering_value_indexes_[3] =
  {
    ::musicxml::measure_numbering_value::measure,
    ::musicxml::measure_numbering_value::none,
    ::musicxml::measure_numbering_value::system
  };

  // membrane_value
  //

  membrane_value::
  membrane_value (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_membrane_value_convert ();
  }

  membrane_value::
  membrane_value (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_membrane_value_convert ();
  }

  membrane_value::
  membrane_value (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_membrane_value_convert ();
  }

  membrane_value* membrane_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class membrane_value (*this, f, c);
  }

  membrane_value::value membrane_value::
  _xsd_membrane_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_membrane_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_membrane_value_indexes_,
                      _xsd_membrane_value_indexes_ + 17,
                      *this,
                      c));

    if (i == _xsd_membrane_value_indexes_ + 17 || _xsd_membrane_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const membrane_value::
  _xsd_membrane_value_literals_[17] =
  {
    "bass drum",
    "bass drum on side",
    "bongos",
    "Chinese tomtom",
    "conga drum",
    "cuica",
    "goblet drum",
    "Indo-American tomtom",
    "Japanese tomtom",
    "military drum",
    "snare drum",
    "snare drum snares off",
    "tabla",
    "tambourine",
    "tenor drum",
    "timbales",
    "tomtom"
  };

  const membrane_value::value membrane_value::
  _xsd_membrane_value_indexes_[17] =
  {
    ::musicxml::membrane_value::Chinese_tomtom,
    ::musicxml::membrane_value::Indo_American_tomtom,
    ::musicxml::membrane_value::Japanese_tomtom,
    ::musicxml::membrane_value::bass_drum,
    ::musicxml::membrane_value::bass_drum_on_side,
    ::musicxml::membrane_value::bongos,
    ::musicxml::membrane_value::conga_drum,
    ::musicxml::membrane_value::cuica,
    ::musicxml::membrane_value::goblet_drum,
    ::musicxml::membrane_value::military_drum,
    ::musicxml::membrane_value::snare_drum,
    ::musicxml::membrane_value::snare_drum_snares_off,
    ::musicxml::membrane_value::tabla,
    ::musicxml::membrane_value::tambourine,
    ::musicxml::membrane_value::tenor_drum,
    ::musicxml::membrane_value::timbales,
    ::musicxml::membrane_value::tomtom
  };

  // metal_value
  //

  metal_value::
  metal_value (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_metal_value_convert ();
  }

  metal_value::
  metal_value (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_metal_value_convert ();
  }

  metal_value::
  metal_value (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_metal_value_convert ();
  }

  metal_value* metal_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metal_value (*this, f, c);
  }

  metal_value::value metal_value::
  _xsd_metal_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_metal_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_metal_value_indexes_,
                      _xsd_metal_value_indexes_ + 32,
                      *this,
                      c));

    if (i == _xsd_metal_value_indexes_ + 32 || _xsd_metal_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const metal_value::
  _xsd_metal_value_literals_[32] =
  {
    "agogo",
    "almglocken",
    "bell",
    "bell plate",
    "bell tree",
    "brake drum",
    "cencerro",
    "chain rattle",
    "Chinese cymbal",
    "cowbell",
    "crash cymbals",
    "crotale",
    "cymbal tongs",
    "domed gong",
    "finger cymbals",
    "flexatone",
    "gong",
    "hi-hat",
    "high-hat cymbals",
    "handbell",
    "jaw harp",
    "jingle bells",
    "musical saw",
    "shell bells",
    "sistrum",
    "sizzle cymbal",
    "sleigh bells",
    "suspended cymbal",
    "tam tam",
    "tam tam with beater",
    "triangle",
    "Vietnamese hat"
  };

  const metal_value::value metal_value::
  _xsd_metal_value_indexes_[32] =
  {
    ::musicxml::metal_value::Chinese_cymbal,
    ::musicxml::metal_value::Vietnamese_hat,
    ::musicxml::metal_value::agogo,
    ::musicxml::metal_value::almglocken,
    ::musicxml::metal_value::bell,
    ::musicxml::metal_value::bell_plate,
    ::musicxml::metal_value::bell_tree,
    ::musicxml::metal_value::brake_drum,
    ::musicxml::metal_value::cencerro,
    ::musicxml::metal_value::chain_rattle,
    ::musicxml::metal_value::cowbell,
    ::musicxml::metal_value::crash_cymbals,
    ::musicxml::metal_value::crotale,
    ::musicxml::metal_value::cymbal_tongs,
    ::musicxml::metal_value::domed_gong,
    ::musicxml::metal_value::finger_cymbals,
    ::musicxml::metal_value::flexatone,
    ::musicxml::metal_value::gong,
    ::musicxml::metal_value::handbell,
    ::musicxml::metal_value::hi_hat,
    ::musicxml::metal_value::high_hat_cymbals,
    ::musicxml::metal_value::jaw_harp,
    ::musicxml::metal_value::jingle_bells,
    ::musicxml::metal_value::musical_saw,
    ::musicxml::metal_value::shell_bells,
    ::musicxml::metal_value::sistrum,
    ::musicxml::metal_value::sizzle_cymbal,
    ::musicxml::metal_value::sleigh_bells,
    ::musicxml::metal_value::suspended_cymbal,
    ::musicxml::metal_value::tam_tam,
    ::musicxml::metal_value::tam_tam_with_beater,
    ::musicxml::metal_value::triangle
  };

  // milliseconds
  //

  milliseconds::
  milliseconds (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base)
  {
  }

  milliseconds::
  milliseconds (const milliseconds& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  milliseconds::
  milliseconds (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  milliseconds::
  milliseconds (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  milliseconds::
  milliseconds (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  milliseconds* milliseconds::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class milliseconds (*this, f, c);
  }

  milliseconds::
  ~milliseconds ()
  {
  }

  // numeral_mode
  //

  numeral_mode::
  numeral_mode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_numeral_mode_convert ();
  }

  numeral_mode::
  numeral_mode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_numeral_mode_convert ();
  }

  numeral_mode::
  numeral_mode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_numeral_mode_convert ();
  }

  numeral_mode* numeral_mode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class numeral_mode (*this, f, c);
  }

  numeral_mode::value numeral_mode::
  _xsd_numeral_mode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_numeral_mode_literals_);
    const value* i (::std::lower_bound (
                      _xsd_numeral_mode_indexes_,
                      _xsd_numeral_mode_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_numeral_mode_indexes_ + 5 || _xsd_numeral_mode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const numeral_mode::
  _xsd_numeral_mode_literals_[5] =
  {
    "major",
    "minor",
    "natural minor",
    "melodic minor",
    "harmonic minor"
  };

  const numeral_mode::value numeral_mode::
  _xsd_numeral_mode_indexes_[5] =
  {
    ::musicxml::numeral_mode::harmonic_minor,
    ::musicxml::numeral_mode::major,
    ::musicxml::numeral_mode::melodic_minor,
    ::musicxml::numeral_mode::minor,
    ::musicxml::numeral_mode::natural_minor
  };

  // on_off
  //

  on_off::
  on_off (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_on_off_convert ();
  }

  on_off::
  on_off (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_on_off_convert ();
  }

  on_off::
  on_off (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_on_off_convert ();
  }

  on_off* on_off::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class on_off (*this, f, c);
  }

  on_off::value on_off::
  _xsd_on_off_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_on_off_literals_);
    const value* i (::std::lower_bound (
                      _xsd_on_off_indexes_,
                      _xsd_on_off_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_on_off_indexes_ + 2 || _xsd_on_off_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const on_off::
  _xsd_on_off_literals_[2] =
  {
    "on",
    "off"
  };

  const on_off::value on_off::
  _xsd_on_off_indexes_[2] =
  {
    ::musicxml::on_off::off,
    ::musicxml::on_off::on
  };

  // pedal_type
  //

  pedal_type::
  pedal_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_pedal_type_convert ();
  }

  pedal_type::
  pedal_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_pedal_type_convert ();
  }

  pedal_type::
  pedal_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_pedal_type_convert ();
  }

  pedal_type* pedal_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pedal_type (*this, f, c);
  }

  pedal_type::value pedal_type::
  _xsd_pedal_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_pedal_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_pedal_type_indexes_,
                      _xsd_pedal_type_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_pedal_type_indexes_ + 7 || _xsd_pedal_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const pedal_type::
  _xsd_pedal_type_literals_[7] =
  {
    "start",
    "stop",
    "sostenuto",
    "change",
    "continue",
    "discontinue",
    "resume"
  };

  const pedal_type::value pedal_type::
  _xsd_pedal_type_indexes_[7] =
  {
    ::musicxml::pedal_type::change,
    ::musicxml::pedal_type::continue_,
    ::musicxml::pedal_type::discontinue,
    ::musicxml::pedal_type::resume,
    ::musicxml::pedal_type::sostenuto,
    ::musicxml::pedal_type::start,
    ::musicxml::pedal_type::stop
  };

  // pitched_value
  //

  pitched_value::
  pitched_value (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_pitched_value_convert ();
  }

  pitched_value::
  pitched_value (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_pitched_value_convert ();
  }

  pitched_value::
  pitched_value (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_pitched_value_convert ();
  }

  pitched_value* pitched_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pitched_value (*this, f, c);
  }

  pitched_value::value pitched_value::
  _xsd_pitched_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_pitched_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_pitched_value_indexes_,
                      _xsd_pitched_value_indexes_ + 11,
                      *this,
                      c));

    if (i == _xsd_pitched_value_indexes_ + 11 || _xsd_pitched_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const pitched_value::
  _xsd_pitched_value_literals_[11] =
  {
    "celesta",
    "chimes",
    "glockenspiel",
    "lithophone",
    "mallet",
    "marimba",
    "steel drums",
    "tubaphone",
    "tubular chimes",
    "vibraphone",
    "xylophone"
  };

  const pitched_value::value pitched_value::
  _xsd_pitched_value_indexes_[11] =
  {
    ::musicxml::pitched_value::celesta,
    ::musicxml::pitched_value::chimes,
    ::musicxml::pitched_value::glockenspiel,
    ::musicxml::pitched_value::lithophone,
    ::musicxml::pitched_value::mallet,
    ::musicxml::pitched_value::marimba,
    ::musicxml::pitched_value::steel_drums,
    ::musicxml::pitched_value::tubaphone,
    ::musicxml::pitched_value::tubular_chimes,
    ::musicxml::pitched_value::vibraphone,
    ::musicxml::pitched_value::xylophone
  };

  // principal_voice_symbol
  //

  principal_voice_symbol::
  principal_voice_symbol (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_principal_voice_symbol_convert ();
  }

  principal_voice_symbol::
  principal_voice_symbol (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_principal_voice_symbol_convert ();
  }

  principal_voice_symbol::
  principal_voice_symbol (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_principal_voice_symbol_convert ();
  }

  principal_voice_symbol* principal_voice_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class principal_voice_symbol (*this, f, c);
  }

  principal_voice_symbol::value principal_voice_symbol::
  _xsd_principal_voice_symbol_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_principal_voice_symbol_literals_);
    const value* i (::std::lower_bound (
                      _xsd_principal_voice_symbol_indexes_,
                      _xsd_principal_voice_symbol_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_principal_voice_symbol_indexes_ + 4 || _xsd_principal_voice_symbol_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const principal_voice_symbol::
  _xsd_principal_voice_symbol_literals_[4] =
  {
    "Hauptstimme",
    "Nebenstimme",
    "plain",
    "none"
  };

  const principal_voice_symbol::value principal_voice_symbol::
  _xsd_principal_voice_symbol_indexes_[4] =
  {
    ::musicxml::principal_voice_symbol::Hauptstimme,
    ::musicxml::principal_voice_symbol::Nebenstimme,
    ::musicxml::principal_voice_symbol::none,
    ::musicxml::principal_voice_symbol::plain
  };

  // staff_divide_symbol
  //

  staff_divide_symbol::
  staff_divide_symbol (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_staff_divide_symbol_convert ();
  }

  staff_divide_symbol::
  staff_divide_symbol (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_staff_divide_symbol_convert ();
  }

  staff_divide_symbol::
  staff_divide_symbol (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_staff_divide_symbol_convert ();
  }

  staff_divide_symbol* staff_divide_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_divide_symbol (*this, f, c);
  }

  staff_divide_symbol::value staff_divide_symbol::
  _xsd_staff_divide_symbol_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_staff_divide_symbol_literals_);
    const value* i (::std::lower_bound (
                      _xsd_staff_divide_symbol_indexes_,
                      _xsd_staff_divide_symbol_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_staff_divide_symbol_indexes_ + 3 || _xsd_staff_divide_symbol_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const staff_divide_symbol::
  _xsd_staff_divide_symbol_literals_[3] =
  {
    "down",
    "up",
    "up-down"
  };

  const staff_divide_symbol::value staff_divide_symbol::
  _xsd_staff_divide_symbol_indexes_[3] =
  {
    ::musicxml::staff_divide_symbol::down,
    ::musicxml::staff_divide_symbol::up,
    ::musicxml::staff_divide_symbol::up_down
  };

  // start_stop_change_continue
  //

  start_stop_change_continue::
  start_stop_change_continue (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_start_stop_change_continue_convert ();
  }

  start_stop_change_continue::
  start_stop_change_continue (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_start_stop_change_continue_convert ();
  }

  start_stop_change_continue::
  start_stop_change_continue (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_start_stop_change_continue_convert ();
  }

  start_stop_change_continue* start_stop_change_continue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class start_stop_change_continue (*this, f, c);
  }

  start_stop_change_continue::value start_stop_change_continue::
  _xsd_start_stop_change_continue_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_start_stop_change_continue_literals_);
    const value* i (::std::lower_bound (
                      _xsd_start_stop_change_continue_indexes_,
                      _xsd_start_stop_change_continue_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_start_stop_change_continue_indexes_ + 4 || _xsd_start_stop_change_continue_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const start_stop_change_continue::
  _xsd_start_stop_change_continue_literals_[4] =
  {
    "start",
    "stop",
    "change",
    "continue"
  };

  const start_stop_change_continue::value start_stop_change_continue::
  _xsd_start_stop_change_continue_indexes_[4] =
  {
    ::musicxml::start_stop_change_continue::change,
    ::musicxml::start_stop_change_continue::continue_,
    ::musicxml::start_stop_change_continue::start,
    ::musicxml::start_stop_change_continue::stop
  };

  // sync_type
  //

  sync_type::
  sync_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_sync_type_convert ();
  }

  sync_type::
  sync_type (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_sync_type_convert ();
  }

  sync_type::
  sync_type (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_sync_type_convert ();
  }

  sync_type* sync_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sync_type (*this, f, c);
  }

  sync_type::value sync_type::
  _xsd_sync_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_sync_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_sync_type_indexes_,
                      _xsd_sync_type_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_sync_type_indexes_ + 6 || _xsd_sync_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const sync_type::
  _xsd_sync_type_literals_[6] =
  {
    "none",
    "tempo",
    "mostly-tempo",
    "mostly-event",
    "event",
    "always-event"
  };

  const sync_type::value sync_type::
  _xsd_sync_type_indexes_[6] =
  {
    ::musicxml::sync_type::always_event,
    ::musicxml::sync_type::event,
    ::musicxml::sync_type::mostly_event,
    ::musicxml::sync_type::mostly_tempo,
    ::musicxml::sync_type::none,
    ::musicxml::sync_type::tempo
  };

  // system_relation_number
  //

  system_relation_number::
  system_relation_number (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_system_relation_number_convert ();
  }

  system_relation_number::
  system_relation_number (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_system_relation_number_convert ();
  }

  system_relation_number::
  system_relation_number (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_system_relation_number_convert ();
  }

  system_relation_number* system_relation_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_relation_number (*this, f, c);
  }

  system_relation_number::value system_relation_number::
  _xsd_system_relation_number_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_relation_number_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_relation_number_indexes_,
                      _xsd_system_relation_number_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_system_relation_number_indexes_ + 5 || _xsd_system_relation_number_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const system_relation_number::
  _xsd_system_relation_number_literals_[5] =
  {
    "only-top",
    "only-bottom",
    "also-top",
    "also-bottom",
    "none"
  };

  const system_relation_number::value system_relation_number::
  _xsd_system_relation_number_indexes_[5] =
  {
    ::musicxml::system_relation_number::also_bottom,
    ::musicxml::system_relation_number::also_top,
    ::musicxml::system_relation_number::none,
    ::musicxml::system_relation_number::only_bottom,
    ::musicxml::system_relation_number::only_top
  };

  // system_relation
  //

  system_relation::
  system_relation (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::system_relation_number (e, f, c)
  {
    _xsd_system_relation_convert ();
  }

  system_relation::
  system_relation (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::system_relation_number (a, f, c)
  {
    _xsd_system_relation_convert ();
  }

  system_relation::
  system_relation (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::system_relation_number (s, e, f, c)
  {
    _xsd_system_relation_convert ();
  }

  system_relation* system_relation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_relation (*this, f, c);
  }

  system_relation::value system_relation::
  _xsd_system_relation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_system_relation_literals_);
    const value* i (::std::lower_bound (
                      _xsd_system_relation_indexes_,
                      _xsd_system_relation_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_system_relation_indexes_ + 3 || _xsd_system_relation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const* system_relation::
  _xsd_system_relation_literals_ = ::musicxml::system_relation_number::_xsd_system_relation_number_literals_;

  const system_relation::value system_relation::
  _xsd_system_relation_indexes_[3] =
  {
    ::musicxml::system_relation::also_top,
    ::musicxml::system_relation::none,
    ::musicxml::system_relation::only_top
  };

  // tip_direction
  //

  tip_direction::
  tip_direction (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_tip_direction_convert ();
  }

  tip_direction::
  tip_direction (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_tip_direction_convert ();
  }

  tip_direction::
  tip_direction (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_tip_direction_convert ();
  }

  tip_direction* tip_direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tip_direction (*this, f, c);
  }

  tip_direction::value tip_direction::
  _xsd_tip_direction_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tip_direction_literals_);
    const value* i (::std::lower_bound (
                      _xsd_tip_direction_indexes_,
                      _xsd_tip_direction_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_tip_direction_indexes_ + 8 || _xsd_tip_direction_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const tip_direction::
  _xsd_tip_direction_literals_[8] =
  {
    "up",
    "down",
    "left",
    "right",
    "northwest",
    "northeast",
    "southeast",
    "southwest"
  };

  const tip_direction::value tip_direction::
  _xsd_tip_direction_indexes_[8] =
  {
    ::musicxml::tip_direction::down,
    ::musicxml::tip_direction::left,
    ::musicxml::tip_direction::northeast,
    ::musicxml::tip_direction::northwest,
    ::musicxml::tip_direction::right,
    ::musicxml::tip_direction::southeast,
    ::musicxml::tip_direction::southwest,
    ::musicxml::tip_direction::up
  };

  // stick_location
  //

  stick_location::
  stick_location (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_stick_location_convert ();
  }

  stick_location::
  stick_location (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_stick_location_convert ();
  }

  stick_location::
  stick_location (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_stick_location_convert ();
  }

  stick_location* stick_location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stick_location (*this, f, c);
  }

  stick_location::value stick_location::
  _xsd_stick_location_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_stick_location_literals_);
    const value* i (::std::lower_bound (
                      _xsd_stick_location_indexes_,
                      _xsd_stick_location_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_stick_location_indexes_ + 4 || _xsd_stick_location_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const stick_location::
  _xsd_stick_location_literals_[4] =
  {
    "center",
    "rim",
    "cymbal bell",
    "cymbal edge"
  };

  const stick_location::value stick_location::
  _xsd_stick_location_indexes_[4] =
  {
    ::musicxml::stick_location::center,
    ::musicxml::stick_location::cymbal_bell,
    ::musicxml::stick_location::cymbal_edge,
    ::musicxml::stick_location::rim
  };

  // stick_material
  //

  stick_material::
  stick_material (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_stick_material_convert ();
  }

  stick_material::
  stick_material (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_stick_material_convert ();
  }

  stick_material::
  stick_material (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_stick_material_convert ();
  }

  stick_material* stick_material::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stick_material (*this, f, c);
  }

  stick_material::value stick_material::
  _xsd_stick_material_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_stick_material_literals_);
    const value* i (::std::lower_bound (
                      _xsd_stick_material_indexes_,
                      _xsd_stick_material_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_stick_material_indexes_ + 5 || _xsd_stick_material_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const stick_material::
  _xsd_stick_material_literals_[5] =
  {
    "soft",
    "medium",
    "hard",
    "shaded",
    "x"
  };

  const stick_material::value stick_material::
  _xsd_stick_material_indexes_[5] =
  {
    ::musicxml::stick_material::hard,
    ::musicxml::stick_material::medium,
    ::musicxml::stick_material::shaded,
    ::musicxml::stick_material::soft,
    ::musicxml::stick_material::x
  };

  // stick_type
  //

  stick_type::
  stick_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_stick_type_convert ();
  }

  stick_type::
  stick_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_stick_type_convert ();
  }

  stick_type::
  stick_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_stick_type_convert ();
  }

  stick_type* stick_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stick_type (*this, f, c);
  }

  stick_type::value stick_type::
  _xsd_stick_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_stick_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_stick_type_indexes_,
                      _xsd_stick_type_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_stick_type_indexes_ + 10 || _xsd_stick_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const stick_type::
  _xsd_stick_type_literals_[10] =
  {
    "bass drum",
    "double bass drum",
    "glockenspiel",
    "gum",
    "hammer",
    "superball",
    "timpani",
    "wound",
    "xylophone",
    "yarn"
  };

  const stick_type::value stick_type::
  _xsd_stick_type_indexes_[10] =
  {
    ::musicxml::stick_type::bass_drum,
    ::musicxml::stick_type::double_bass_drum,
    ::musicxml::stick_type::glockenspiel,
    ::musicxml::stick_type::gum,
    ::musicxml::stick_type::hammer,
    ::musicxml::stick_type::superball,
    ::musicxml::stick_type::timpani,
    ::musicxml::stick_type::wound,
    ::musicxml::stick_type::xylophone,
    ::musicxml::stick_type::yarn
  };

  // up_down_stop_continue
  //

  up_down_stop_continue::
  up_down_stop_continue (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_up_down_stop_continue_convert ();
  }

  up_down_stop_continue::
  up_down_stop_continue (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_up_down_stop_continue_convert ();
  }

  up_down_stop_continue::
  up_down_stop_continue (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_up_down_stop_continue_convert ();
  }

  up_down_stop_continue* up_down_stop_continue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class up_down_stop_continue (*this, f, c);
  }

  up_down_stop_continue::value up_down_stop_continue::
  _xsd_up_down_stop_continue_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_up_down_stop_continue_literals_);
    const value* i (::std::lower_bound (
                      _xsd_up_down_stop_continue_indexes_,
                      _xsd_up_down_stop_continue_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_up_down_stop_continue_indexes_ + 4 || _xsd_up_down_stop_continue_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const up_down_stop_continue::
  _xsd_up_down_stop_continue_literals_[4] =
  {
    "up",
    "down",
    "stop",
    "continue"
  };

  const up_down_stop_continue::value up_down_stop_continue::
  _xsd_up_down_stop_continue_indexes_[4] =
  {
    ::musicxml::up_down_stop_continue::continue_,
    ::musicxml::up_down_stop_continue::down,
    ::musicxml::up_down_stop_continue::stop,
    ::musicxml::up_down_stop_continue::up
  };

  // wedge_type
  //

  wedge_type::
  wedge_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_wedge_type_convert ();
  }

  wedge_type::
  wedge_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_wedge_type_convert ();
  }

  wedge_type::
  wedge_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_wedge_type_convert ();
  }

  wedge_type* wedge_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wedge_type (*this, f, c);
  }

  wedge_type::value wedge_type::
  _xsd_wedge_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_wedge_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_wedge_type_indexes_,
                      _xsd_wedge_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_wedge_type_indexes_ + 4 || _xsd_wedge_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const wedge_type::
  _xsd_wedge_type_literals_[4] =
  {
    "crescendo",
    "diminuendo",
    "stop",
    "continue"
  };

  const wedge_type::value wedge_type::
  _xsd_wedge_type_indexes_[4] =
  {
    ::musicxml::wedge_type::continue_,
    ::musicxml::wedge_type::crescendo,
    ::musicxml::wedge_type::diminuendo,
    ::musicxml::wedge_type::stop
  };

  // wood_value
  //

  wood_value::
  wood_value (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_wood_value_convert ();
  }

  wood_value::
  wood_value (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_wood_value_convert ();
  }

  wood_value::
  wood_value (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_wood_value_convert ();
  }

  wood_value* wood_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wood_value (*this, f, c);
  }

  wood_value::value wood_value::
  _xsd_wood_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_wood_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_wood_value_indexes_,
                      _xsd_wood_value_indexes_ + 21,
                      *this,
                      c));

    if (i == _xsd_wood_value_indexes_ + 21 || _xsd_wood_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const wood_value::
  _xsd_wood_value_literals_[21] =
  {
    "bamboo scraper",
    "board clapper",
    "cabasa",
    "castanets",
    "castanets with handle",
    "claves",
    "football rattle",
    "guiro",
    "log drum",
    "maraca",
    "maracas",
    "quijada",
    "rainstick",
    "ratchet",
    "reco-reco",
    "sandpaper blocks",
    "slit drum",
    "temple block",
    "vibraslap",
    "whip",
    "wood block"
  };

  const wood_value::value wood_value::
  _xsd_wood_value_indexes_[21] =
  {
    ::musicxml::wood_value::bamboo_scraper,
    ::musicxml::wood_value::board_clapper,
    ::musicxml::wood_value::cabasa,
    ::musicxml::wood_value::castanets,
    ::musicxml::wood_value::castanets_with_handle,
    ::musicxml::wood_value::claves,
    ::musicxml::wood_value::football_rattle,
    ::musicxml::wood_value::guiro,
    ::musicxml::wood_value::log_drum,
    ::musicxml::wood_value::maraca,
    ::musicxml::wood_value::maracas,
    ::musicxml::wood_value::quijada,
    ::musicxml::wood_value::rainstick,
    ::musicxml::wood_value::ratchet,
    ::musicxml::wood_value::reco_reco,
    ::musicxml::wood_value::sandpaper_blocks,
    ::musicxml::wood_value::slit_drum,
    ::musicxml::wood_value::temple_block,
    ::musicxml::wood_value::vibraslap,
    ::musicxml::wood_value::whip,
    ::musicxml::wood_value::wood_block
  };

  // distance_type
  //

  distance_type::
  distance_type ()
  : ::xml_schema::token ()
  {
  }

  distance_type::
  distance_type (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  distance_type::
  distance_type (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  distance_type::
  distance_type (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  distance_type::
  distance_type (const distance_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  distance_type::
  distance_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  distance_type::
  distance_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  distance_type::
  distance_type (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  distance_type* distance_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class distance_type (*this, f, c);
  }

  distance_type::
  ~distance_type ()
  {
  }

  // glyph_type
  //

  glyph_type::
  glyph_type ()
  : ::xml_schema::token ()
  {
  }

  glyph_type::
  glyph_type (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  glyph_type::
  glyph_type (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  glyph_type::
  glyph_type (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  glyph_type::
  glyph_type (const glyph_type& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  glyph_type::
  glyph_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  glyph_type::
  glyph_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  glyph_type::
  glyph_type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  glyph_type* glyph_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class glyph_type (*this, f, c);
  }

  glyph_type::
  ~glyph_type ()
  {
  }

  // line_width_type
  //

  line_width_type::
  line_width_type ()
  : ::xml_schema::token ()
  {
  }

  line_width_type::
  line_width_type (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  line_width_type::
  line_width_type (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  line_width_type::
  line_width_type (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  line_width_type::
  line_width_type (const line_width_type& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  line_width_type::
  line_width_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  line_width_type::
  line_width_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  line_width_type::
  line_width_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  line_width_type* line_width_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_width_type (*this, f, c);
  }

  line_width_type::
  ~line_width_type ()
  {
  }

  // margin_type
  //

  margin_type::
  margin_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_margin_type_convert ();
  }

  margin_type::
  margin_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_margin_type_convert ();
  }

  margin_type::
  margin_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_margin_type_convert ();
  }

  margin_type* margin_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class margin_type (*this, f, c);
  }

  margin_type::value margin_type::
  _xsd_margin_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_margin_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_margin_type_indexes_,
                      _xsd_margin_type_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_margin_type_indexes_ + 3 || _xsd_margin_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const margin_type::
  _xsd_margin_type_literals_[3] =
  {
    "odd",
    "even",
    "both"
  };

  const margin_type::value margin_type::
  _xsd_margin_type_indexes_[3] =
  {
    ::musicxml::margin_type::both,
    ::musicxml::margin_type::even,
    ::musicxml::margin_type::odd
  };

  // millimeters
  //

  millimeters::
  millimeters (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  millimeters::
  millimeters (const millimeters& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  millimeters::
  millimeters (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  millimeters::
  millimeters (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  millimeters::
  millimeters (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  millimeters* millimeters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class millimeters (*this, f, c);
  }

  millimeters::
  ~millimeters ()
  {
  }

  // note_size_type
  //

  note_size_type::
  note_size_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_note_size_type_convert ();
  }

  note_size_type::
  note_size_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_note_size_type_convert ();
  }

  note_size_type::
  note_size_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_note_size_type_convert ();
  }

  note_size_type* note_size_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note_size_type (*this, f, c);
  }

  note_size_type::value note_size_type::
  _xsd_note_size_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_note_size_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_note_size_type_indexes_,
                      _xsd_note_size_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_note_size_type_indexes_ + 4 || _xsd_note_size_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const note_size_type::
  _xsd_note_size_type_literals_[4] =
  {
    "cue",
    "grace",
    "grace-cue",
    "large"
  };

  const note_size_type::value note_size_type::
  _xsd_note_size_type_indexes_[4] =
  {
    ::musicxml::note_size_type::cue,
    ::musicxml::note_size_type::grace,
    ::musicxml::note_size_type::grace_cue,
    ::musicxml::note_size_type::large
  };

  // accidental_value
  //

  accidental_value::
  accidental_value (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_accidental_value_convert ();
  }

  accidental_value::
  accidental_value (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_accidental_value_convert ();
  }

  accidental_value::
  accidental_value (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_accidental_value_convert ();
  }

  accidental_value* accidental_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accidental_value (*this, f, c);
  }

  accidental_value::value accidental_value::
  _xsd_accidental_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_accidental_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_accidental_value_indexes_,
                      _xsd_accidental_value_indexes_ + 41,
                      *this,
                      c));

    if (i == _xsd_accidental_value_indexes_ + 41 || _xsd_accidental_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const accidental_value::
  _xsd_accidental_value_literals_[41] =
  {
    "sharp",
    "natural",
    "flat",
    "double-sharp",
    "sharp-sharp",
    "flat-flat",
    "natural-sharp",
    "natural-flat",
    "quarter-flat",
    "quarter-sharp",
    "three-quarters-flat",
    "three-quarters-sharp",
    "sharp-down",
    "sharp-up",
    "natural-down",
    "natural-up",
    "flat-down",
    "flat-up",
    "double-sharp-down",
    "double-sharp-up",
    "flat-flat-down",
    "flat-flat-up",
    "arrow-down",
    "arrow-up",
    "triple-sharp",
    "triple-flat",
    "slash-quarter-sharp",
    "slash-sharp",
    "slash-flat",
    "double-slash-flat",
    "sharp-1",
    "sharp-2",
    "sharp-3",
    "sharp-5",
    "flat-1",
    "flat-2",
    "flat-3",
    "flat-4",
    "sori",
    "koron",
    "other"
  };

  const accidental_value::value accidental_value::
  _xsd_accidental_value_indexes_[41] =
  {
    ::musicxml::accidental_value::arrow_down,
    ::musicxml::accidental_value::arrow_up,
    ::musicxml::accidental_value::double_sharp,
    ::musicxml::accidental_value::double_sharp_down,
    ::musicxml::accidental_value::double_sharp_up,
    ::musicxml::accidental_value::double_slash_flat,
    ::musicxml::accidental_value::flat,
    ::musicxml::accidental_value::flat_1,
    ::musicxml::accidental_value::flat_2,
    ::musicxml::accidental_value::flat_3,
    ::musicxml::accidental_value::flat_4,
    ::musicxml::accidental_value::flat_down,
    ::musicxml::accidental_value::flat_flat,
    ::musicxml::accidental_value::flat_flat_down,
    ::musicxml::accidental_value::flat_flat_up,
    ::musicxml::accidental_value::flat_up,
    ::musicxml::accidental_value::koron,
    ::musicxml::accidental_value::natural,
    ::musicxml::accidental_value::natural_down,
    ::musicxml::accidental_value::natural_flat,
    ::musicxml::accidental_value::natural_sharp,
    ::musicxml::accidental_value::natural_up,
    ::musicxml::accidental_value::other,
    ::musicxml::accidental_value::quarter_flat,
    ::musicxml::accidental_value::quarter_sharp,
    ::musicxml::accidental_value::sharp,
    ::musicxml::accidental_value::sharp_1,
    ::musicxml::accidental_value::sharp_2,
    ::musicxml::accidental_value::sharp_3,
    ::musicxml::accidental_value::sharp_5,
    ::musicxml::accidental_value::sharp_down,
    ::musicxml::accidental_value::sharp_sharp,
    ::musicxml::accidental_value::sharp_up,
    ::musicxml::accidental_value::slash_flat,
    ::musicxml::accidental_value::slash_quarter_sharp,
    ::musicxml::accidental_value::slash_sharp,
    ::musicxml::accidental_value::sori,
    ::musicxml::accidental_value::three_quarters_flat,
    ::musicxml::accidental_value::three_quarters_sharp,
    ::musicxml::accidental_value::triple_flat,
    ::musicxml::accidental_value::triple_sharp
  };

  // arrow_direction
  //

  arrow_direction::
  arrow_direction (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_arrow_direction_convert ();
  }

  arrow_direction::
  arrow_direction (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_arrow_direction_convert ();
  }

  arrow_direction::
  arrow_direction (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_arrow_direction_convert ();
  }

  arrow_direction* arrow_direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arrow_direction (*this, f, c);
  }

  arrow_direction::value arrow_direction::
  _xsd_arrow_direction_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_arrow_direction_literals_);
    const value* i (::std::lower_bound (
                      _xsd_arrow_direction_indexes_,
                      _xsd_arrow_direction_indexes_ + 13,
                      *this,
                      c));

    if (i == _xsd_arrow_direction_indexes_ + 13 || _xsd_arrow_direction_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const arrow_direction::
  _xsd_arrow_direction_literals_[13] =
  {
    "left",
    "up",
    "right",
    "down",
    "northwest",
    "northeast",
    "southeast",
    "southwest",
    "left right",
    "up down",
    "northwest southeast",
    "northeast southwest",
    "other"
  };

  const arrow_direction::value arrow_direction::
  _xsd_arrow_direction_indexes_[13] =
  {
    ::musicxml::arrow_direction::down,
    ::musicxml::arrow_direction::left,
    ::musicxml::arrow_direction::left_right,
    ::musicxml::arrow_direction::northeast,
    ::musicxml::arrow_direction::northeast_southwest,
    ::musicxml::arrow_direction::northwest,
    ::musicxml::arrow_direction::northwest_southeast,
    ::musicxml::arrow_direction::other,
    ::musicxml::arrow_direction::right,
    ::musicxml::arrow_direction::southeast,
    ::musicxml::arrow_direction::southwest,
    ::musicxml::arrow_direction::up,
    ::musicxml::arrow_direction::up_down
  };

  // arrow_style
  //

  arrow_style::
  arrow_style (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_arrow_style_convert ();
  }

  arrow_style::
  arrow_style (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_arrow_style_convert ();
  }

  arrow_style::
  arrow_style (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_arrow_style_convert ();
  }

  arrow_style* arrow_style::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arrow_style (*this, f, c);
  }

  arrow_style::value arrow_style::
  _xsd_arrow_style_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_arrow_style_literals_);
    const value* i (::std::lower_bound (
                      _xsd_arrow_style_indexes_,
                      _xsd_arrow_style_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_arrow_style_indexes_ + 7 || _xsd_arrow_style_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const arrow_style::
  _xsd_arrow_style_literals_[7] =
  {
    "single",
    "double",
    "filled",
    "hollow",
    "paired",
    "combined",
    "other"
  };

  const arrow_style::value arrow_style::
  _xsd_arrow_style_indexes_[7] =
  {
    ::musicxml::arrow_style::combined,
    ::musicxml::arrow_style::double_,
    ::musicxml::arrow_style::filled,
    ::musicxml::arrow_style::hollow,
    ::musicxml::arrow_style::other,
    ::musicxml::arrow_style::paired,
    ::musicxml::arrow_style::single
  };

  // beam_value
  //

  beam_value::
  beam_value (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_beam_value_convert ();
  }

  beam_value::
  beam_value (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_beam_value_convert ();
  }

  beam_value::
  beam_value (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_beam_value_convert ();
  }

  beam_value* beam_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beam_value (*this, f, c);
  }

  beam_value::value beam_value::
  _xsd_beam_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_beam_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_beam_value_indexes_,
                      _xsd_beam_value_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_beam_value_indexes_ + 5 || _xsd_beam_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const beam_value::
  _xsd_beam_value_literals_[5] =
  {
    "begin",
    "continue",
    "end",
    "forward hook",
    "backward hook"
  };

  const beam_value::value beam_value::
  _xsd_beam_value_indexes_[5] =
  {
    ::musicxml::beam_value::backward_hook,
    ::musicxml::beam_value::begin,
    ::musicxml::beam_value::continue_,
    ::musicxml::beam_value::end,
    ::musicxml::beam_value::forward_hook
  };

  // bend_shape
  //

  bend_shape::
  bend_shape (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_bend_shape_convert ();
  }

  bend_shape::
  bend_shape (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_bend_shape_convert ();
  }

  bend_shape::
  bend_shape (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_bend_shape_convert ();
  }

  bend_shape* bend_shape::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bend_shape (*this, f, c);
  }

  bend_shape::value bend_shape::
  _xsd_bend_shape_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bend_shape_literals_);
    const value* i (::std::lower_bound (
                      _xsd_bend_shape_indexes_,
                      _xsd_bend_shape_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_bend_shape_indexes_ + 2 || _xsd_bend_shape_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const bend_shape::
  _xsd_bend_shape_literals_[2] =
  {
    "angled",
    "curved"
  };

  const bend_shape::value bend_shape::
  _xsd_bend_shape_indexes_[2] =
  {
    ::musicxml::bend_shape::angled,
    ::musicxml::bend_shape::curved
  };

  // breath_mark_value
  //

  breath_mark_value::
  breath_mark_value (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_breath_mark_value_convert ();
  }

  breath_mark_value::
  breath_mark_value (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_breath_mark_value_convert ();
  }

  breath_mark_value::
  breath_mark_value (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_breath_mark_value_convert ();
  }

  breath_mark_value* breath_mark_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class breath_mark_value (*this, f, c);
  }

  breath_mark_value::value breath_mark_value::
  _xsd_breath_mark_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_breath_mark_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_breath_mark_value_indexes_,
                      _xsd_breath_mark_value_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_breath_mark_value_indexes_ + 5 || _xsd_breath_mark_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const breath_mark_value::
  _xsd_breath_mark_value_literals_[5] =
  {
    "",
    "comma",
    "tick",
    "upbow",
    "salzedo"
  };

  const breath_mark_value::value breath_mark_value::
  _xsd_breath_mark_value_indexes_[5] =
  {
    ::musicxml::breath_mark_value::empty,
    ::musicxml::breath_mark_value::comma,
    ::musicxml::breath_mark_value::salzedo,
    ::musicxml::breath_mark_value::tick,
    ::musicxml::breath_mark_value::upbow
  };

  // caesura_value
  //

  caesura_value::
  caesura_value (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_caesura_value_convert ();
  }

  caesura_value::
  caesura_value (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_caesura_value_convert ();
  }

  caesura_value::
  caesura_value (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_caesura_value_convert ();
  }

  caesura_value* caesura_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class caesura_value (*this, f, c);
  }

  caesura_value::value caesura_value::
  _xsd_caesura_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_caesura_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_caesura_value_indexes_,
                      _xsd_caesura_value_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_caesura_value_indexes_ + 6 || _xsd_caesura_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const caesura_value::
  _xsd_caesura_value_literals_[6] =
  {
    "normal",
    "thick",
    "short",
    "curved",
    "single",
    ""
  };

  const caesura_value::value caesura_value::
  _xsd_caesura_value_indexes_[6] =
  {
    ::musicxml::caesura_value::empty,
    ::musicxml::caesura_value::curved,
    ::musicxml::caesura_value::normal,
    ::musicxml::caesura_value::short_,
    ::musicxml::caesura_value::single,
    ::musicxml::caesura_value::thick
  };

  // circular_arrow
  //

  circular_arrow::
  circular_arrow (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_circular_arrow_convert ();
  }

  circular_arrow::
  circular_arrow (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_circular_arrow_convert ();
  }

  circular_arrow::
  circular_arrow (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_circular_arrow_convert ();
  }

  circular_arrow* circular_arrow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class circular_arrow (*this, f, c);
  }

  circular_arrow::value circular_arrow::
  _xsd_circular_arrow_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_circular_arrow_literals_);
    const value* i (::std::lower_bound (
                      _xsd_circular_arrow_indexes_,
                      _xsd_circular_arrow_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_circular_arrow_indexes_ + 2 || _xsd_circular_arrow_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const circular_arrow::
  _xsd_circular_arrow_literals_[2] =
  {
    "clockwise",
    "anticlockwise"
  };

  const circular_arrow::value circular_arrow::
  _xsd_circular_arrow_indexes_[2] =
  {
    ::musicxml::circular_arrow::anticlockwise,
    ::musicxml::circular_arrow::clockwise
  };

  // fan
  //

  fan::
  fan (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_fan_convert ();
  }

  fan::
  fan (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_fan_convert ();
  }

  fan::
  fan (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_fan_convert ();
  }

  fan* fan::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fan (*this, f, c);
  }

  fan::value fan::
  _xsd_fan_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fan_literals_);
    const value* i (::std::lower_bound (
                      _xsd_fan_indexes_,
                      _xsd_fan_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_fan_indexes_ + 3 || _xsd_fan_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const fan::
  _xsd_fan_literals_[3] =
  {
    "accel",
    "rit",
    "none"
  };

  const fan::value fan::
  _xsd_fan_indexes_[3] =
  {
    ::musicxml::fan::accel,
    ::musicxml::fan::none,
    ::musicxml::fan::rit
  };

  // handbell_value
  //

  handbell_value::
  handbell_value (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_handbell_value_convert ();
  }

  handbell_value::
  handbell_value (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_handbell_value_convert ();
  }

  handbell_value::
  handbell_value (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_handbell_value_convert ();
  }

  handbell_value* handbell_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class handbell_value (*this, f, c);
  }

  handbell_value::value handbell_value::
  _xsd_handbell_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_handbell_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_handbell_value_indexes_,
                      _xsd_handbell_value_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_handbell_value_indexes_ + 12 || _xsd_handbell_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const handbell_value::
  _xsd_handbell_value_literals_[12] =
  {
    "belltree",
    "damp",
    "echo",
    "gyro",
    "hand martellato",
    "mallet lift",
    "mallet table",
    "martellato",
    "martellato lift",
    "muted martellato",
    "pluck lift",
    "swing"
  };

  const handbell_value::value handbell_value::
  _xsd_handbell_value_indexes_[12] =
  {
    ::musicxml::handbell_value::belltree,
    ::musicxml::handbell_value::damp,
    ::musicxml::handbell_value::echo,
    ::musicxml::handbell_value::gyro,
    ::musicxml::handbell_value::hand_martellato,
    ::musicxml::handbell_value::mallet_lift,
    ::musicxml::handbell_value::mallet_table,
    ::musicxml::handbell_value::martellato,
    ::musicxml::handbell_value::martellato_lift,
    ::musicxml::handbell_value::muted_martellato,
    ::musicxml::handbell_value::pluck_lift,
    ::musicxml::handbell_value::swing
  };

  // harmon_closed_location
  //

  harmon_closed_location::
  harmon_closed_location (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_harmon_closed_location_convert ();
  }

  harmon_closed_location::
  harmon_closed_location (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_harmon_closed_location_convert ();
  }

  harmon_closed_location::
  harmon_closed_location (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_harmon_closed_location_convert ();
  }

  harmon_closed_location* harmon_closed_location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmon_closed_location (*this, f, c);
  }

  harmon_closed_location::value harmon_closed_location::
  _xsd_harmon_closed_location_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_harmon_closed_location_literals_);
    const value* i (::std::lower_bound (
                      _xsd_harmon_closed_location_indexes_,
                      _xsd_harmon_closed_location_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_harmon_closed_location_indexes_ + 4 || _xsd_harmon_closed_location_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const harmon_closed_location::
  _xsd_harmon_closed_location_literals_[4] =
  {
    "right",
    "bottom",
    "left",
    "top"
  };

  const harmon_closed_location::value harmon_closed_location::
  _xsd_harmon_closed_location_indexes_[4] =
  {
    ::musicxml::harmon_closed_location::bottom,
    ::musicxml::harmon_closed_location::left,
    ::musicxml::harmon_closed_location::right,
    ::musicxml::harmon_closed_location::top
  };

  // harmon_closed_value
  //

  harmon_closed_value::
  harmon_closed_value (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_harmon_closed_value_convert ();
  }

  harmon_closed_value::
  harmon_closed_value (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_harmon_closed_value_convert ();
  }

  harmon_closed_value::
  harmon_closed_value (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_harmon_closed_value_convert ();
  }

  harmon_closed_value* harmon_closed_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmon_closed_value (*this, f, c);
  }

  harmon_closed_value::value harmon_closed_value::
  _xsd_harmon_closed_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_harmon_closed_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_harmon_closed_value_indexes_,
                      _xsd_harmon_closed_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_harmon_closed_value_indexes_ + 3 || _xsd_harmon_closed_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const harmon_closed_value::
  _xsd_harmon_closed_value_literals_[3] =
  {
    "yes",
    "no",
    "half"
  };

  const harmon_closed_value::value harmon_closed_value::
  _xsd_harmon_closed_value_indexes_[3] =
  {
    ::musicxml::harmon_closed_value::half,
    ::musicxml::harmon_closed_value::no,
    ::musicxml::harmon_closed_value::yes
  };

  // hole_closed_location
  //

  hole_closed_location::
  hole_closed_location (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_hole_closed_location_convert ();
  }

  hole_closed_location::
  hole_closed_location (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_hole_closed_location_convert ();
  }

  hole_closed_location::
  hole_closed_location (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_hole_closed_location_convert ();
  }

  hole_closed_location* hole_closed_location::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hole_closed_location (*this, f, c);
  }

  hole_closed_location::value hole_closed_location::
  _xsd_hole_closed_location_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_hole_closed_location_literals_);
    const value* i (::std::lower_bound (
                      _xsd_hole_closed_location_indexes_,
                      _xsd_hole_closed_location_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_hole_closed_location_indexes_ + 4 || _xsd_hole_closed_location_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const hole_closed_location::
  _xsd_hole_closed_location_literals_[4] =
  {
    "right",
    "bottom",
    "left",
    "top"
  };

  const hole_closed_location::value hole_closed_location::
  _xsd_hole_closed_location_indexes_[4] =
  {
    ::musicxml::hole_closed_location::bottom,
    ::musicxml::hole_closed_location::left,
    ::musicxml::hole_closed_location::right,
    ::musicxml::hole_closed_location::top
  };

  // hole_closed_value
  //

  hole_closed_value::
  hole_closed_value (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_hole_closed_value_convert ();
  }

  hole_closed_value::
  hole_closed_value (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_hole_closed_value_convert ();
  }

  hole_closed_value::
  hole_closed_value (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_hole_closed_value_convert ();
  }

  hole_closed_value* hole_closed_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hole_closed_value (*this, f, c);
  }

  hole_closed_value::value hole_closed_value::
  _xsd_hole_closed_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_hole_closed_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_hole_closed_value_indexes_,
                      _xsd_hole_closed_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_hole_closed_value_indexes_ + 3 || _xsd_hole_closed_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const hole_closed_value::
  _xsd_hole_closed_value_literals_[3] =
  {
    "yes",
    "no",
    "half"
  };

  const hole_closed_value::value hole_closed_value::
  _xsd_hole_closed_value_indexes_[3] =
  {
    ::musicxml::hole_closed_value::half,
    ::musicxml::hole_closed_value::no,
    ::musicxml::hole_closed_value::yes
  };

  // note_type_value
  //

  note_type_value::
  note_type_value (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_note_type_value_convert ();
  }

  note_type_value::
  note_type_value (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_note_type_value_convert ();
  }

  note_type_value::
  note_type_value (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_note_type_value_convert ();
  }

  note_type_value* note_type_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note_type_value (*this, f, c);
  }

  note_type_value::value note_type_value::
  _xsd_note_type_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_note_type_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_note_type_value_indexes_,
                      _xsd_note_type_value_indexes_ + 14,
                      *this,
                      c));

    if (i == _xsd_note_type_value_indexes_ + 14 || _xsd_note_type_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const note_type_value::
  _xsd_note_type_value_literals_[14] =
  {
    "1024th",
    "512th",
    "256th",
    "128th",
    "64th",
    "32nd",
    "16th",
    "eighth",
    "quarter",
    "half",
    "whole",
    "breve",
    "long",
    "maxima"
  };

  const note_type_value::value note_type_value::
  _xsd_note_type_value_indexes_[14] =
  {
    ::musicxml::note_type_value::cxx_1024th,
    ::musicxml::note_type_value::cxx_128th,
    ::musicxml::note_type_value::cxx_16th,
    ::musicxml::note_type_value::cxx_256th,
    ::musicxml::note_type_value::cxx_32nd,
    ::musicxml::note_type_value::cxx_512th,
    ::musicxml::note_type_value::cxx_64th,
    ::musicxml::note_type_value::breve,
    ::musicxml::note_type_value::eighth,
    ::musicxml::note_type_value::half,
    ::musicxml::note_type_value::long_,
    ::musicxml::note_type_value::maxima,
    ::musicxml::note_type_value::quarter,
    ::musicxml::note_type_value::whole
  };

  // notehead_value
  //

  notehead_value::
  notehead_value (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_notehead_value_convert ();
  }

  notehead_value::
  notehead_value (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_notehead_value_convert ();
  }

  notehead_value::
  notehead_value (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_notehead_value_convert ();
  }

  notehead_value* notehead_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class notehead_value (*this, f, c);
  }

  notehead_value::value notehead_value::
  _xsd_notehead_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_notehead_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_notehead_value_indexes_,
                      _xsd_notehead_value_indexes_ + 28,
                      *this,
                      c));

    if (i == _xsd_notehead_value_indexes_ + 28 || _xsd_notehead_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const notehead_value::
  _xsd_notehead_value_literals_[28] =
  {
    "slash",
    "triangle",
    "diamond",
    "square",
    "cross",
    "x",
    "circle-x",
    "inverted triangle",
    "arrow down",
    "arrow up",
    "circled",
    "slashed",
    "back slashed",
    "normal",
    "cluster",
    "circle dot",
    "left triangle",
    "rectangle",
    "none",
    "do",
    "re",
    "mi",
    "fa",
    "fa up",
    "so",
    "la",
    "ti",
    "other"
  };

  const notehead_value::value notehead_value::
  _xsd_notehead_value_indexes_[28] =
  {
    ::musicxml::notehead_value::arrow_down,
    ::musicxml::notehead_value::arrow_up,
    ::musicxml::notehead_value::back_slashed,
    ::musicxml::notehead_value::circle_dot,
    ::musicxml::notehead_value::circle_x,
    ::musicxml::notehead_value::circled,
    ::musicxml::notehead_value::cluster,
    ::musicxml::notehead_value::cross,
    ::musicxml::notehead_value::diamond,
    ::musicxml::notehead_value::do_,
    ::musicxml::notehead_value::fa,
    ::musicxml::notehead_value::fa_up,
    ::musicxml::notehead_value::inverted_triangle,
    ::musicxml::notehead_value::la,
    ::musicxml::notehead_value::left_triangle,
    ::musicxml::notehead_value::mi,
    ::musicxml::notehead_value::none,
    ::musicxml::notehead_value::normal,
    ::musicxml::notehead_value::other,
    ::musicxml::notehead_value::re,
    ::musicxml::notehead_value::rectangle,
    ::musicxml::notehead_value::slash,
    ::musicxml::notehead_value::slashed,
    ::musicxml::notehead_value::so,
    ::musicxml::notehead_value::square,
    ::musicxml::notehead_value::ti,
    ::musicxml::notehead_value::triangle,
    ::musicxml::notehead_value::x
  };

  // octave
  //

  octave::
  octave (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  octave::
  octave (const octave& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  octave::
  octave (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  octave::
  octave (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  octave::
  octave (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  octave* octave::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class octave (*this, f, c);
  }

  octave::
  ~octave ()
  {
  }

  // semitones
  //

  semitones::
  semitones (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
  {
  }

  semitones::
  semitones (const semitones& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
  {
  }

  semitones::
  semitones (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
  {
  }

  semitones::
  semitones (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
  {
  }

  semitones::
  semitones (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
  {
  }

  semitones* semitones::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class semitones (*this, f, c);
  }

  semitones::
  ~semitones ()
  {
  }

  // show_tuplet
  //

  show_tuplet::
  show_tuplet (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_show_tuplet_convert ();
  }

  show_tuplet::
  show_tuplet (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_show_tuplet_convert ();
  }

  show_tuplet::
  show_tuplet (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_show_tuplet_convert ();
  }

  show_tuplet* show_tuplet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class show_tuplet (*this, f, c);
  }

  show_tuplet::value show_tuplet::
  _xsd_show_tuplet_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_show_tuplet_literals_);
    const value* i (::std::lower_bound (
                      _xsd_show_tuplet_indexes_,
                      _xsd_show_tuplet_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_show_tuplet_indexes_ + 3 || _xsd_show_tuplet_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const show_tuplet::
  _xsd_show_tuplet_literals_[3] =
  {
    "actual",
    "both",
    "none"
  };

  const show_tuplet::value show_tuplet::
  _xsd_show_tuplet_indexes_[3] =
  {
    ::musicxml::show_tuplet::actual,
    ::musicxml::show_tuplet::both,
    ::musicxml::show_tuplet::none
  };

  // stem_value
  //

  stem_value::
  stem_value (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_stem_value_convert ();
  }

  stem_value::
  stem_value (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_stem_value_convert ();
  }

  stem_value::
  stem_value (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_stem_value_convert ();
  }

  stem_value* stem_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stem_value (*this, f, c);
  }

  stem_value::value stem_value::
  _xsd_stem_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_stem_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_stem_value_indexes_,
                      _xsd_stem_value_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_stem_value_indexes_ + 4 || _xsd_stem_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const stem_value::
  _xsd_stem_value_literals_[4] =
  {
    "down",
    "up",
    "double",
    "none"
  };

  const stem_value::value stem_value::
  _xsd_stem_value_indexes_[4] =
  {
    ::musicxml::stem_value::double_,
    ::musicxml::stem_value::down,
    ::musicxml::stem_value::none,
    ::musicxml::stem_value::up
  };

  // step
  //

  step::
  step (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_step_convert ();
  }

  step::
  step (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_step_convert ();
  }

  step::
  step (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_step_convert ();
  }

  step* step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class step (*this, f, c);
  }

  step::value step::
  _xsd_step_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_step_literals_);
    const value* i (::std::lower_bound (
                      _xsd_step_indexes_,
                      _xsd_step_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_step_indexes_ + 7 || _xsd_step_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const step::
  _xsd_step_literals_[7] =
  {
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G"
  };

  const step::value step::
  _xsd_step_indexes_[7] =
  {
    ::musicxml::step::A,
    ::musicxml::step::B,
    ::musicxml::step::C,
    ::musicxml::step::D,
    ::musicxml::step::E,
    ::musicxml::step::F,
    ::musicxml::step::G
  };

  // syllabic
  //

  syllabic::
  syllabic (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_syllabic_convert ();
  }

  syllabic::
  syllabic (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_syllabic_convert ();
  }

  syllabic::
  syllabic (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_syllabic_convert ();
  }

  syllabic* syllabic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class syllabic (*this, f, c);
  }

  syllabic::value syllabic::
  _xsd_syllabic_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_syllabic_literals_);
    const value* i (::std::lower_bound (
                      _xsd_syllabic_indexes_,
                      _xsd_syllabic_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_syllabic_indexes_ + 4 || _xsd_syllabic_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const syllabic::
  _xsd_syllabic_literals_[4] =
  {
    "single",
    "begin",
    "end",
    "middle"
  };

  const syllabic::value syllabic::
  _xsd_syllabic_indexes_[4] =
  {
    ::musicxml::syllabic::begin,
    ::musicxml::syllabic::end,
    ::musicxml::syllabic::middle,
    ::musicxml::syllabic::single
  };

  // tap_hand
  //

  tap_hand::
  tap_hand (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_tap_hand_convert ();
  }

  tap_hand::
  tap_hand (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_tap_hand_convert ();
  }

  tap_hand::
  tap_hand (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_tap_hand_convert ();
  }

  tap_hand* tap_hand::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tap_hand (*this, f, c);
  }

  tap_hand::value tap_hand::
  _xsd_tap_hand_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tap_hand_literals_);
    const value* i (::std::lower_bound (
                      _xsd_tap_hand_indexes_,
                      _xsd_tap_hand_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_tap_hand_indexes_ + 2 || _xsd_tap_hand_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const tap_hand::
  _xsd_tap_hand_literals_[2] =
  {
    "left",
    "right"
  };

  const tap_hand::value tap_hand::
  _xsd_tap_hand_indexes_[2] =
  {
    ::musicxml::tap_hand::left,
    ::musicxml::tap_hand::right
  };

  // tremolo_marks
  //

  tremolo_marks::
  tremolo_marks (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  tremolo_marks::
  tremolo_marks (const tremolo_marks& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  tremolo_marks::
  tremolo_marks (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  tremolo_marks::
  tremolo_marks (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  tremolo_marks::
  tremolo_marks (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  tremolo_marks* tremolo_marks::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tremolo_marks (*this, f, c);
  }

  tremolo_marks::
  ~tremolo_marks ()
  {
  }

  // group_barline_value
  //

  group_barline_value::
  group_barline_value (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_group_barline_value_convert ();
  }

  group_barline_value::
  group_barline_value (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_group_barline_value_convert ();
  }

  group_barline_value::
  group_barline_value (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_group_barline_value_convert ();
  }

  group_barline_value* group_barline_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group_barline_value (*this, f, c);
  }

  group_barline_value::value group_barline_value::
  _xsd_group_barline_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_group_barline_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_group_barline_value_indexes_,
                      _xsd_group_barline_value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_group_barline_value_indexes_ + 3 || _xsd_group_barline_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const group_barline_value::
  _xsd_group_barline_value_literals_[3] =
  {
    "yes",
    "no",
    "Mensurstrich"
  };

  const group_barline_value::value group_barline_value::
  _xsd_group_barline_value_indexes_[3] =
  {
    ::musicxml::group_barline_value::Mensurstrich,
    ::musicxml::group_barline_value::no,
    ::musicxml::group_barline_value::yes
  };

  // group_symbol_value
  //

  group_symbol_value::
  group_symbol_value (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_group_symbol_value_convert ();
  }

  group_symbol_value::
  group_symbol_value (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_group_symbol_value_convert ();
  }

  group_symbol_value::
  group_symbol_value (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_group_symbol_value_convert ();
  }

  group_symbol_value* group_symbol_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group_symbol_value (*this, f, c);
  }

  group_symbol_value::value group_symbol_value::
  _xsd_group_symbol_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_group_symbol_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_group_symbol_value_indexes_,
                      _xsd_group_symbol_value_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_group_symbol_value_indexes_ + 5 || _xsd_group_symbol_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const group_symbol_value::
  _xsd_group_symbol_value_literals_[5] =
  {
    "none",
    "brace",
    "line",
    "bracket",
    "square"
  };

  const group_symbol_value::value group_symbol_value::
  _xsd_group_symbol_value_indexes_[5] =
  {
    ::musicxml::group_symbol_value::brace,
    ::musicxml::group_symbol_value::bracket,
    ::musicxml::group_symbol_value::line,
    ::musicxml::group_symbol_value::none,
    ::musicxml::group_symbol_value::square
  };

  // measure_text
  //

  measure_text::
  measure_text ()
  : ::xml_schema::token ()
  {
  }

  measure_text::
  measure_text (const char* _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  measure_text::
  measure_text (const ::std::string& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  measure_text::
  measure_text (const ::xml_schema::token& _xsd_token_base)
  : ::xml_schema::token (_xsd_token_base)
  {
  }

  measure_text::
  measure_text (const measure_text& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (x, f, c)
  {
  }

  measure_text::
  measure_text (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
  }

  measure_text::
  measure_text (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
  }

  measure_text::
  measure_text (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
  }

  measure_text* measure_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_text (*this, f, c);
  }

  measure_text::
  ~measure_text ()
  {
  }

  // swing_type_value
  //

  swing_type_value::
  swing_type_value (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::note_type_value (e, f, c)
  {
    _xsd_swing_type_value_convert ();
  }

  swing_type_value::
  swing_type_value (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::note_type_value (a, f, c)
  {
    _xsd_swing_type_value_convert ();
  }

  swing_type_value::
  swing_type_value (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::note_type_value (s, e, f, c)
  {
    _xsd_swing_type_value_convert ();
  }

  swing_type_value* swing_type_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class swing_type_value (*this, f, c);
  }

  swing_type_value::value swing_type_value::
  _xsd_swing_type_value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_swing_type_value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_swing_type_value_indexes_,
                      _xsd_swing_type_value_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_swing_type_value_indexes_ + 2 || _xsd_swing_type_value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const* swing_type_value::
  _xsd_swing_type_value_literals_ = ::musicxml::note_type_value::_xsd_note_type_value_literals_;

  const swing_type_value::value swing_type_value::
  _xsd_swing_type_value_indexes_[2] =
  {
    ::musicxml::swing_type_value::cxx_16th,
    ::musicxml::swing_type_value::eighth
  };

  // accidental_text
  //

  accidental_text::
  accidental_text (::musicxml::accidental_value::value _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    smufl_ (this)
  {
  }

  accidental_text::
  accidental_text (const char* _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    smufl_ (this)
  {
  }

  accidental_text::
  accidental_text (const ::std::string& _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    smufl_ (this)
  {
  }

  accidental_text::
  accidental_text (const ::musicxml::accidental_value& _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    smufl_ (this)
  {
  }

  accidental_text::
  accidental_text (const accidental_text& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::accidental_value (x, f, c),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    line_height_ (x.line_height_, f, this),
    lang_ (x.lang_, f, this),
    space_ (x.space_, f, this),
    dir_ (x.dir_, f, this),
    enclosure_ (x.enclosure_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  accidental_text::
  accidental_text (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::accidental_value (e, f | ::xml_schema::flags::base, c),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void accidental_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-height" && n.namespace_ ().empty ())
      {
        this->line_height_.set (line_height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  accidental_text* accidental_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accidental_text (*this, f, c);
  }

  accidental_text& accidental_text::
  operator= (const accidental_text& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::accidental_value& > (*this) = x;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->line_height_ = x.line_height_;
      this->lang_ = x.lang_;
      this->space_ = x.space_;
      this->dir_ = x.dir_;
      this->enclosure_ = x.enclosure_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  accidental_text::
  ~accidental_text ()
  {
  }

  // coda
  //

  coda::
  coda ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this),
    smufl_ (this)
  {
  }

  coda::
  coda (const coda& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  coda::
  coda (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void coda::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  coda* coda::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class coda (*this, f, c);
  }

  coda& coda::
  operator= (const coda& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  coda::
  ~coda ()
  {
  }

  // dynamics
  //

  dynamics::
  dynamics ()
  : ::xml_schema::type (),
    p_ (this),
    pp_ (this),
    ppp_ (this),
    pppp_ (this),
    ppppp_ (this),
    pppppp_ (this),
    f_ (this),
    ff_ (this),
    fff_ (this),
    ffff_ (this),
    fffff_ (this),
    ffffff_ (this),
    mp_ (this),
    mf_ (this),
    sf_ (this),
    sfp_ (this),
    sfpp_ (this),
    fp_ (this),
    rf_ (this),
    rfz_ (this),
    sfz_ (this),
    sffz_ (this),
    fz_ (this),
    n_ (this),
    pf_ (this),
    sfzp_ (this),
    other_dynamics_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    placement_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  dynamics::
  dynamics (const dynamics& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    p_ (x.p_, f, this),
    pp_ (x.pp_, f, this),
    ppp_ (x.ppp_, f, this),
    pppp_ (x.pppp_, f, this),
    ppppp_ (x.ppppp_, f, this),
    pppppp_ (x.pppppp_, f, this),
    f_ (x.f_, f, this),
    ff_ (x.ff_, f, this),
    fff_ (x.fff_, f, this),
    ffff_ (x.ffff_, f, this),
    fffff_ (x.fffff_, f, this),
    ffffff_ (x.ffffff_, f, this),
    mp_ (x.mp_, f, this),
    mf_ (x.mf_, f, this),
    sf_ (x.sf_, f, this),
    sfp_ (x.sfp_, f, this),
    sfpp_ (x.sfpp_, f, this),
    fp_ (x.fp_, f, this),
    rf_ (x.rf_, f, this),
    rfz_ (x.rfz_, f, this),
    sfz_ (x.sfz_, f, this),
    sffz_ (x.sffz_, f, this),
    fz_ (x.fz_, f, this),
    n_ (x.n_, f, this),
    pf_ (x.pf_, f, this),
    sfzp_ (x.sfzp_, f, this),
    other_dynamics_ (x.other_dynamics_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    placement_ (x.placement_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    enclosure_ (x.enclosure_, f, this),
    id_ (x.id_, f, this)
  {
  }

  dynamics::
  dynamics (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    p_ (this),
    pp_ (this),
    ppp_ (this),
    pppp_ (this),
    ppppp_ (this),
    pppppp_ (this),
    f_ (this),
    ff_ (this),
    fff_ (this),
    ffff_ (this),
    fffff_ (this),
    ffffff_ (this),
    mp_ (this),
    mf_ (this),
    sf_ (this),
    sfp_ (this),
    sfpp_ (this),
    fp_ (this),
    rf_ (this),
    rfz_ (this),
    sfz_ (this),
    sffz_ (this),
    fz_ (this),
    n_ (this),
    pf_ (this),
    sfzp_ (this),
    other_dynamics_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    placement_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    enclosure_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void dynamics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // p
      //
      if (n.name () == "p" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< p_type > r (
          p_traits::create (i, f, this));

        this->p_.push_back (::std::move (r));
        continue;
      }

      // pp
      //
      if (n.name () == "pp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pp_type > r (
          pp_traits::create (i, f, this));

        this->pp_.push_back (::std::move (r));
        continue;
      }

      // ppp
      //
      if (n.name () == "ppp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ppp_type > r (
          ppp_traits::create (i, f, this));

        this->ppp_.push_back (::std::move (r));
        continue;
      }

      // pppp
      //
      if (n.name () == "pppp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pppp_type > r (
          pppp_traits::create (i, f, this));

        this->pppp_.push_back (::std::move (r));
        continue;
      }

      // ppppp
      //
      if (n.name () == "ppppp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ppppp_type > r (
          ppppp_traits::create (i, f, this));

        this->ppppp_.push_back (::std::move (r));
        continue;
      }

      // pppppp
      //
      if (n.name () == "pppppp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pppppp_type > r (
          pppppp_traits::create (i, f, this));

        this->pppppp_.push_back (::std::move (r));
        continue;
      }

      // f
      //
      if (n.name () == "f" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< f_type > r (
          f_traits::create (i, f, this));

        this->f_.push_back (::std::move (r));
        continue;
      }

      // ff
      //
      if (n.name () == "ff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ff_type > r (
          ff_traits::create (i, f, this));

        this->ff_.push_back (::std::move (r));
        continue;
      }

      // fff
      //
      if (n.name () == "fff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fff_type > r (
          fff_traits::create (i, f, this));

        this->fff_.push_back (::std::move (r));
        continue;
      }

      // ffff
      //
      if (n.name () == "ffff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ffff_type > r (
          ffff_traits::create (i, f, this));

        this->ffff_.push_back (::std::move (r));
        continue;
      }

      // fffff
      //
      if (n.name () == "fffff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fffff_type > r (
          fffff_traits::create (i, f, this));

        this->fffff_.push_back (::std::move (r));
        continue;
      }

      // ffffff
      //
      if (n.name () == "ffffff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ffffff_type > r (
          ffffff_traits::create (i, f, this));

        this->ffffff_.push_back (::std::move (r));
        continue;
      }

      // mp
      //
      if (n.name () == "mp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< mp_type > r (
          mp_traits::create (i, f, this));

        this->mp_.push_back (::std::move (r));
        continue;
      }

      // mf
      //
      if (n.name () == "mf" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< mf_type > r (
          mf_traits::create (i, f, this));

        this->mf_.push_back (::std::move (r));
        continue;
      }

      // sf
      //
      if (n.name () == "sf" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sf_type > r (
          sf_traits::create (i, f, this));

        this->sf_.push_back (::std::move (r));
        continue;
      }

      // sfp
      //
      if (n.name () == "sfp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sfp_type > r (
          sfp_traits::create (i, f, this));

        this->sfp_.push_back (::std::move (r));
        continue;
      }

      // sfpp
      //
      if (n.name () == "sfpp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sfpp_type > r (
          sfpp_traits::create (i, f, this));

        this->sfpp_.push_back (::std::move (r));
        continue;
      }

      // fp
      //
      if (n.name () == "fp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fp_type > r (
          fp_traits::create (i, f, this));

        this->fp_.push_back (::std::move (r));
        continue;
      }

      // rf
      //
      if (n.name () == "rf" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< rf_type > r (
          rf_traits::create (i, f, this));

        this->rf_.push_back (::std::move (r));
        continue;
      }

      // rfz
      //
      if (n.name () == "rfz" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< rfz_type > r (
          rfz_traits::create (i, f, this));

        this->rfz_.push_back (::std::move (r));
        continue;
      }

      // sfz
      //
      if (n.name () == "sfz" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sfz_type > r (
          sfz_traits::create (i, f, this));

        this->sfz_.push_back (::std::move (r));
        continue;
      }

      // sffz
      //
      if (n.name () == "sffz" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sffz_type > r (
          sffz_traits::create (i, f, this));

        this->sffz_.push_back (::std::move (r));
        continue;
      }

      // fz
      //
      if (n.name () == "fz" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fz_type > r (
          fz_traits::create (i, f, this));

        this->fz_.push_back (::std::move (r));
        continue;
      }

      // n
      //
      if (n.name () == "n" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< n_type > r (
          n_traits::create (i, f, this));

        this->n_.push_back (::std::move (r));
        continue;
      }

      // pf
      //
      if (n.name () == "pf" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pf_type > r (
          pf_traits::create (i, f, this));

        this->pf_.push_back (::std::move (r));
        continue;
      }

      // sfzp
      //
      if (n.name () == "sfzp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sfzp_type > r (
          sfzp_traits::create (i, f, this));

        this->sfzp_.push_back (::std::move (r));
        continue;
      }

      // other-dynamics
      //
      if (n.name () == "other-dynamics" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_dynamics_type > r (
          other_dynamics_traits::create (i, f, this));

        this->other_dynamics_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  dynamics* dynamics::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dynamics (*this, f, c);
  }

  dynamics& dynamics::
  operator= (const dynamics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->p_ = x.p_;
      this->pp_ = x.pp_;
      this->ppp_ = x.ppp_;
      this->pppp_ = x.pppp_;
      this->ppppp_ = x.ppppp_;
      this->pppppp_ = x.pppppp_;
      this->f_ = x.f_;
      this->ff_ = x.ff_;
      this->fff_ = x.fff_;
      this->ffff_ = x.ffff_;
      this->fffff_ = x.fffff_;
      this->ffffff_ = x.ffffff_;
      this->mp_ = x.mp_;
      this->mf_ = x.mf_;
      this->sf_ = x.sf_;
      this->sfp_ = x.sfp_;
      this->sfpp_ = x.sfpp_;
      this->fp_ = x.fp_;
      this->rf_ = x.rf_;
      this->rfz_ = x.rfz_;
      this->sfz_ = x.sfz_;
      this->sffz_ = x.sffz_;
      this->fz_ = x.fz_;
      this->n_ = x.n_;
      this->pf_ = x.pf_;
      this->sfzp_ = x.sfzp_;
      this->other_dynamics_ = x.other_dynamics_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->placement_ = x.placement_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->enclosure_ = x.enclosure_;
      this->id_ = x.id_;
    }

    return *this;
  }

  dynamics::
  ~dynamics ()
  {
  }

  // empty
  //

  empty::
  empty ()
  : ::xml_schema::type ()
  {
  }

  empty::
  empty (const empty& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c)
  {
  }

  empty::
  empty (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  empty::
  empty (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  empty::
  empty (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  empty* empty::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty (*this, f, c);
  }

  empty::
  ~empty ()
  {
  }

  // empty_placement
  //

  empty_placement::
  empty_placement ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  empty_placement::
  empty_placement (const empty_placement& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  empty_placement::
  empty_placement (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_placement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_placement* empty_placement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_placement (*this, f, c);
  }

  empty_placement& empty_placement::
  operator= (const empty_placement& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  empty_placement::
  ~empty_placement ()
  {
  }

  // empty_placement_smufl
  //

  empty_placement_smufl::
  empty_placement_smufl ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  empty_placement_smufl::
  empty_placement_smufl (const empty_placement_smufl& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  empty_placement_smufl::
  empty_placement_smufl (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_placement_smufl::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_placement_smufl* empty_placement_smufl::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_placement_smufl (*this, f, c);
  }

  empty_placement_smufl& empty_placement_smufl::
  operator= (const empty_placement_smufl& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  empty_placement_smufl::
  ~empty_placement_smufl ()
  {
  }

  // empty_print_style
  //

  empty_print_style::
  empty_print_style ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  empty_print_style::
  empty_print_style (const empty_print_style& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  empty_print_style::
  empty_print_style (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_print_style::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_print_style* empty_print_style::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_print_style (*this, f, c);
  }

  empty_print_style& empty_print_style::
  operator= (const empty_print_style& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  empty_print_style::
  ~empty_print_style ()
  {
  }

  // empty_print_style_align
  //

  empty_print_style_align::
  empty_print_style_align ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  empty_print_style_align::
  empty_print_style_align (const empty_print_style_align& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this)
  {
  }

  empty_print_style_align::
  empty_print_style_align (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_print_style_align::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_print_style_align* empty_print_style_align::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_print_style_align (*this, f, c);
  }

  empty_print_style_align& empty_print_style_align::
  operator= (const empty_print_style_align& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
    }

    return *this;
  }

  empty_print_style_align::
  ~empty_print_style_align ()
  {
  }

  // empty_print_style_align_id
  //

  empty_print_style_align_id::
  empty_print_style_align_id ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  empty_print_style_align_id::
  empty_print_style_align_id (const empty_print_style_align_id& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  empty_print_style_align_id::
  empty_print_style_align_id (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_print_style_align_id::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_print_style_align_id* empty_print_style_align_id::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_print_style_align_id (*this, f, c);
  }

  empty_print_style_align_id& empty_print_style_align_id::
  operator= (const empty_print_style_align_id& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  empty_print_style_align_id::
  ~empty_print_style_align_id ()
  {
  }

  // empty_print_object_style_align
  //

  empty_print_object_style_align::
  empty_print_object_style_align ()
  : ::xml_schema::type (),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  empty_print_object_style_align::
  empty_print_object_style_align (const empty_print_object_style_align& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this)
  {
  }

  empty_print_object_style_align::
  empty_print_object_style_align (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_print_object_style_align::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_print_object_style_align* empty_print_object_style_align::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_print_object_style_align (*this, f, c);
  }

  empty_print_object_style_align& empty_print_object_style_align::
  operator= (const empty_print_object_style_align& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
    }

    return *this;
  }

  empty_print_object_style_align::
  ~empty_print_object_style_align ()
  {
  }

  // empty_trill_sound
  //

  empty_trill_sound::
  empty_trill_sound ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this)
  {
  }

  empty_trill_sound::
  empty_trill_sound (const empty_trill_sound& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    start_note_ (x.start_note_, f, this),
    trill_step_ (x.trill_step_, f, this),
    two_note_turn_ (x.two_note_turn_, f, this),
    accelerate_ (x.accelerate_, f, this),
    beats_ (x.beats_, f, this),
    second_beat_ (x.second_beat_, f, this),
    last_beat_ (x.last_beat_, f, this)
  {
  }

  empty_trill_sound::
  empty_trill_sound (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_trill_sound::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start-note" && n.namespace_ ().empty ())
      {
        this->start_note_.set (start_note_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "trill-step" && n.namespace_ ().empty ())
      {
        this->trill_step_.set (trill_step_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "two-note-turn" && n.namespace_ ().empty ())
      {
        this->two_note_turn_.set (two_note_turn_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accelerate" && n.namespace_ ().empty ())
      {
        this->accelerate_.set (accelerate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        this->beats_.set (beats_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "second-beat" && n.namespace_ ().empty ())
      {
        this->second_beat_.set (second_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "last-beat" && n.namespace_ ().empty ())
      {
        this->last_beat_.set (last_beat_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_trill_sound* empty_trill_sound::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_trill_sound (*this, f, c);
  }

  empty_trill_sound& empty_trill_sound::
  operator= (const empty_trill_sound& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->start_note_ = x.start_note_;
      this->trill_step_ = x.trill_step_;
      this->two_note_turn_ = x.two_note_turn_;
      this->accelerate_ = x.accelerate_;
      this->beats_ = x.beats_;
      this->second_beat_ = x.second_beat_;
      this->last_beat_ = x.last_beat_;
    }

    return *this;
  }

  empty_trill_sound::
  ~empty_trill_sound ()
  {
  }

  // horizontal_turn
  //

  horizontal_turn::
  horizontal_turn ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this),
    slash_ (this)
  {
  }

  horizontal_turn::
  horizontal_turn (const horizontal_turn& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    start_note_ (x.start_note_, f, this),
    trill_step_ (x.trill_step_, f, this),
    two_note_turn_ (x.two_note_turn_, f, this),
    accelerate_ (x.accelerate_, f, this),
    beats_ (x.beats_, f, this),
    second_beat_ (x.second_beat_, f, this),
    last_beat_ (x.last_beat_, f, this),
    slash_ (x.slash_, f, this)
  {
  }

  horizontal_turn::
  horizontal_turn (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this),
    slash_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void horizontal_turn::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start-note" && n.namespace_ ().empty ())
      {
        this->start_note_.set (start_note_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "trill-step" && n.namespace_ ().empty ())
      {
        this->trill_step_.set (trill_step_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "two-note-turn" && n.namespace_ ().empty ())
      {
        this->two_note_turn_.set (two_note_turn_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accelerate" && n.namespace_ ().empty ())
      {
        this->accelerate_.set (accelerate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        this->beats_.set (beats_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "second-beat" && n.namespace_ ().empty ())
      {
        this->second_beat_.set (second_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "last-beat" && n.namespace_ ().empty ())
      {
        this->last_beat_.set (last_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slash" && n.namespace_ ().empty ())
      {
        this->slash_.set (slash_traits::create (i, f, this));
        continue;
      }
    }
  }

  horizontal_turn* horizontal_turn::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class horizontal_turn (*this, f, c);
  }

  horizontal_turn& horizontal_turn::
  operator= (const horizontal_turn& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->start_note_ = x.start_note_;
      this->trill_step_ = x.trill_step_;
      this->two_note_turn_ = x.two_note_turn_;
      this->accelerate_ = x.accelerate_;
      this->beats_ = x.beats_;
      this->second_beat_ = x.second_beat_;
      this->last_beat_ = x.last_beat_;
      this->slash_ = x.slash_;
    }

    return *this;
  }

  horizontal_turn::
  ~horizontal_turn ()
  {
  }

  // fermata
  //

  fermata::
  fermata (::musicxml::fermata_shape::value _xsd_fermata_shape_base)
  : ::musicxml::fermata_shape (_xsd_fermata_shape_base),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  fermata::
  fermata (const char* _xsd_string_base)
  : ::musicxml::fermata_shape (_xsd_string_base),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  fermata::
  fermata (const ::std::string& _xsd_string_base)
  : ::musicxml::fermata_shape (_xsd_string_base),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  fermata::
  fermata (const ::musicxml::fermata_shape& _xsd_fermata_shape_base)
  : ::musicxml::fermata_shape (_xsd_fermata_shape_base),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  fermata::
  fermata (const fermata& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::fermata_shape (x, f, c),
    type_ (x.type_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  fermata::
  fermata (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::fermata_shape (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void fermata::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  fermata* fermata::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fermata (*this, f, c);
  }

  fermata& fermata::
  operator= (const fermata& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::fermata_shape& > (*this) = x;
      this->type_ = x.type_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  fermata::
  ~fermata ()
  {
  }

  // fingering
  //

  fingering::
  fingering ()
  : ::xml_schema::string (),
    substitution_ (this),
    alternate_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  fingering::
  fingering (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    substitution_ (this),
    alternate_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  fingering::
  fingering (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    substitution_ (this),
    alternate_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  fingering::
  fingering (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    substitution_ (this),
    alternate_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  fingering::
  fingering (const fingering& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    substitution_ (x.substitution_, f, this),
    alternate_ (x.alternate_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  fingering::
  fingering (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    substitution_ (this),
    alternate_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void fingering::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "substitution" && n.namespace_ ().empty ())
      {
        this->substitution_.set (substitution_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "alternate" && n.namespace_ ().empty ())
      {
        this->alternate_.set (alternate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  fingering* fingering::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fingering (*this, f, c);
  }

  fingering& fingering::
  operator= (const fingering& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->substitution_ = x.substitution_;
      this->alternate_ = x.alternate_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  fingering::
  ~fingering ()
  {
  }

  // formatted_symbol
  //

  formatted_symbol::
  formatted_symbol (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_symbol::
  formatted_symbol (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_symbol::
  formatted_symbol (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_symbol::
  formatted_symbol (const formatted_symbol& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    line_height_ (x.line_height_, f, this),
    dir_ (x.dir_, f, this),
    enclosure_ (x.enclosure_, f, this)
  {
  }

  formatted_symbol::
  formatted_symbol (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f | ::xml_schema::flags::base, c),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void formatted_symbol::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-height" && n.namespace_ ().empty ())
      {
        this->line_height_.set (line_height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }
    }
  }

  formatted_symbol* formatted_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatted_symbol (*this, f, c);
  }

  formatted_symbol& formatted_symbol::
  operator= (const formatted_symbol& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::smufl_glyph_name& > (*this) = x;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->line_height_ = x.line_height_;
      this->dir_ = x.dir_;
      this->enclosure_ = x.enclosure_;
    }

    return *this;
  }

  formatted_symbol::
  ~formatted_symbol ()
  {
  }

  // formatted_symbol_id
  //

  formatted_symbol_id::
  formatted_symbol_id (const char* _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_symbol_id::
  formatted_symbol_id (const ::std::string& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_symbol_id::
  formatted_symbol_id (const ::xml_schema::nmtoken& _xsd_nmtoken_base)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_symbol_id::
  formatted_symbol_id (const formatted_symbol_id& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    line_height_ (x.line_height_, f, this),
    dir_ (x.dir_, f, this),
    enclosure_ (x.enclosure_, f, this),
    id_ (x.id_, f, this)
  {
  }

  formatted_symbol_id::
  formatted_symbol_id (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f | ::xml_schema::flags::base, c),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void formatted_symbol_id::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-height" && n.namespace_ ().empty ())
      {
        this->line_height_.set (line_height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  formatted_symbol_id* formatted_symbol_id::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatted_symbol_id (*this, f, c);
  }

  formatted_symbol_id& formatted_symbol_id::
  operator= (const formatted_symbol_id& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::smufl_glyph_name& > (*this) = x;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->line_height_ = x.line_height_;
      this->dir_ = x.dir_;
      this->enclosure_ = x.enclosure_;
      this->id_ = x.id_;
    }

    return *this;
  }

  formatted_symbol_id::
  ~formatted_symbol_id ()
  {
  }

  // formatted_text
  //

  formatted_text::
  formatted_text ()
  : ::xml_schema::string (),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_text::
  formatted_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_text::
  formatted_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_text::
  formatted_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this)
  {
  }

  formatted_text::
  formatted_text (const formatted_text& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    line_height_ (x.line_height_, f, this),
    lang_ (x.lang_, f, this),
    space_ (x.space_, f, this),
    dir_ (x.dir_, f, this),
    enclosure_ (x.enclosure_, f, this)
  {
  }

  formatted_text::
  formatted_text (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void formatted_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-height" && n.namespace_ ().empty ())
      {
        this->line_height_.set (line_height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }
    }
  }

  formatted_text* formatted_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatted_text (*this, f, c);
  }

  formatted_text& formatted_text::
  operator= (const formatted_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->line_height_ = x.line_height_;
      this->lang_ = x.lang_;
      this->space_ = x.space_;
      this->dir_ = x.dir_;
      this->enclosure_ = x.enclosure_;
    }

    return *this;
  }

  formatted_text::
  ~formatted_text ()
  {
  }

  // formatted_text_id
  //

  formatted_text_id::
  formatted_text_id ()
  : ::xml_schema::string (),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_text_id::
  formatted_text_id (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_text_id::
  formatted_text_id (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_text_id::
  formatted_text_id (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  formatted_text_id::
  formatted_text_id (const formatted_text_id& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    line_height_ (x.line_height_, f, this),
    lang_ (x.lang_, f, this),
    space_ (x.space_, f, this),
    dir_ (x.dir_, f, this),
    enclosure_ (x.enclosure_, f, this),
    id_ (x.id_, f, this)
  {
  }

  formatted_text_id::
  formatted_text_id (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    line_height_ (this),
    lang_ (this),
    space_ (this),
    dir_ (this),
    enclosure_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void formatted_text_id::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-height" && n.namespace_ ().empty ())
      {
        this->line_height_.set (line_height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  formatted_text_id* formatted_text_id::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class formatted_text_id (*this, f, c);
  }

  formatted_text_id& formatted_text_id::
  operator= (const formatted_text_id& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->line_height_ = x.line_height_;
      this->lang_ = x.lang_;
      this->space_ = x.space_;
      this->dir_ = x.dir_;
      this->enclosure_ = x.enclosure_;
      this->id_ = x.id_;
    }

    return *this;
  }

  formatted_text_id::
  ~formatted_text_id ()
  {
  }

  // fret
  //

  fret::
  fret (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  fret::
  fret (const fret& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  fret::
  fret (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void fret::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  fret* fret::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fret (*this, f, c);
  }

  fret& fret::
  operator= (const fret& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  fret::
  ~fret ()
  {
  }

  // level
  //

  level::
  level ()
  : ::xml_schema::string (),
    reference_ (this),
    type_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this)
  {
  }

  level::
  level (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    reference_ (this),
    type_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this)
  {
  }

  level::
  level (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    reference_ (this),
    type_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this)
  {
  }

  level::
  level (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    reference_ (this),
    type_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this)
  {
  }

  level::
  level (const level& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    reference_ (x.reference_, f, this),
    type_ (x.type_, f, this),
    parentheses_ (x.parentheses_, f, this),
    bracket_ (x.bracket_, f, this),
    size_ (x.size_, f, this)
  {
  }

  level::
  level (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    reference_ (this),
    type_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void level::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "reference" && n.namespace_ ().empty ())
      {
        this->reference_.set (reference_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        this->bracket_.set (bracket_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }
    }
  }

  level* level::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class level (*this, f, c);
  }

  level& level::
  operator= (const level& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->reference_ = x.reference_;
      this->type_ = x.type_;
      this->parentheses_ = x.parentheses_;
      this->bracket_ = x.bracket_;
      this->size_ = x.size_;
    }

    return *this;
  }

  level::
  ~level ()
  {
  }

  // midi_device
  //

  midi_device::
  midi_device ()
  : ::xml_schema::string (),
    port_ (this),
    id_ (this)
  {
  }

  midi_device::
  midi_device (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    port_ (this),
    id_ (this)
  {
  }

  midi_device::
  midi_device (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    port_ (this),
    id_ (this)
  {
  }

  midi_device::
  midi_device (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    port_ (this),
    id_ (this)
  {
  }

  midi_device::
  midi_device (const midi_device& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    port_ (x.port_, f, this),
    id_ (x.id_, f, this)
  {
  }

  midi_device::
  midi_device (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    port_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void midi_device::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "port" && n.namespace_ ().empty ())
      {
        this->port_.set (port_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  midi_device* midi_device::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class midi_device (*this, f, c);
  }

  midi_device& midi_device::
  operator= (const midi_device& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->port_ = x.port_;
      this->id_ = x.id_;
    }

    return *this;
  }

  midi_device::
  ~midi_device ()
  {
  }

  // midi_instrument
  //

  midi_instrument::
  midi_instrument (const id_type& id)
  : ::xml_schema::type (),
    midi_channel_ (this),
    midi_name_ (this),
    midi_bank_ (this),
    midi_program_ (this),
    midi_unpitched_ (this),
    volume_ (this),
    pan_ (this),
    elevation_ (this),
    id_ (id, this)
  {
  }

  midi_instrument::
  midi_instrument (const midi_instrument& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    midi_channel_ (x.midi_channel_, f, this),
    midi_name_ (x.midi_name_, f, this),
    midi_bank_ (x.midi_bank_, f, this),
    midi_program_ (x.midi_program_, f, this),
    midi_unpitched_ (x.midi_unpitched_, f, this),
    volume_ (x.volume_, f, this),
    pan_ (x.pan_, f, this),
    elevation_ (x.elevation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  midi_instrument::
  midi_instrument (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    midi_channel_ (this),
    midi_name_ (this),
    midi_bank_ (this),
    midi_program_ (this),
    midi_unpitched_ (this),
    volume_ (this),
    pan_ (this),
    elevation_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void midi_instrument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // midi-channel
      //
      if (n.name () == "midi-channel" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_channel_type > r (
          midi_channel_traits::create (i, f, this));

        if (!this->midi_channel_)
        {
          this->midi_channel_.set (::std::move (r));
          continue;
        }
      }

      // midi-name
      //
      if (n.name () == "midi-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_name_type > r (
          midi_name_traits::create (i, f, this));

        if (!this->midi_name_)
        {
          this->midi_name_.set (::std::move (r));
          continue;
        }
      }

      // midi-bank
      //
      if (n.name () == "midi-bank" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_bank_type > r (
          midi_bank_traits::create (i, f, this));

        if (!this->midi_bank_)
        {
          this->midi_bank_.set (::std::move (r));
          continue;
        }
      }

      // midi-program
      //
      if (n.name () == "midi-program" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_program_type > r (
          midi_program_traits::create (i, f, this));

        if (!this->midi_program_)
        {
          this->midi_program_.set (::std::move (r));
          continue;
        }
      }

      // midi-unpitched
      //
      if (n.name () == "midi-unpitched" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_unpitched_type > r (
          midi_unpitched_traits::create (i, f, this));

        if (!this->midi_unpitched_)
        {
          this->midi_unpitched_.set (::std::move (r));
          continue;
        }
      }

      // volume
      //
      if (n.name () == "volume" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< volume_type > r (
          volume_traits::create (i, f, this));

        if (!this->volume_)
        {
          this->volume_.set (::std::move (r));
          continue;
        }
      }

      // pan
      //
      if (n.name () == "pan" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pan_type > r (
          pan_traits::create (i, f, this));

        if (!this->pan_)
        {
          this->pan_.set (::std::move (r));
          continue;
        }
      }

      // elevation
      //
      if (n.name () == "elevation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< elevation_type > r (
          elevation_traits::create (i, f, this));

        if (!this->elevation_)
        {
          this->elevation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  midi_instrument* midi_instrument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class midi_instrument (*this, f, c);
  }

  midi_instrument& midi_instrument::
  operator= (const midi_instrument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->midi_channel_ = x.midi_channel_;
      this->midi_name_ = x.midi_name_;
      this->midi_bank_ = x.midi_bank_;
      this->midi_program_ = x.midi_program_;
      this->midi_unpitched_ = x.midi_unpitched_;
      this->volume_ = x.volume_;
      this->pan_ = x.pan_;
      this->elevation_ = x.elevation_;
      this->id_ = x.id_;
    }

    return *this;
  }

  midi_instrument::
  ~midi_instrument ()
  {
  }

  // name_display
  //

  name_display::
  name_display ()
  : ::xml_schema::type (),
    display_text_ (this),
    accidental_text_ (this),
    print_object_ (this)
  {
  }

  name_display::
  name_display (const name_display& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    display_text_ (x.display_text_, f, this),
    accidental_text_ (x.accidental_text_, f, this),
    print_object_ (x.print_object_, f, this)
  {
  }

  name_display::
  name_display (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    display_text_ (this),
    accidental_text_ (this),
    print_object_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void name_display::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // display-text
      //
      if (n.name () == "display-text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_text_type > r (
          display_text_traits::create (i, f, this));

        this->display_text_.push_back (::std::move (r));
        continue;
      }

      // accidental-text
      //
      if (n.name () == "accidental-text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accidental_text_type > r (
          accidental_text_traits::create (i, f, this));

        this->accidental_text_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }
    }
  }

  name_display* name_display::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class name_display (*this, f, c);
  }

  name_display& name_display::
  operator= (const name_display& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->display_text_ = x.display_text_;
      this->accidental_text_ = x.accidental_text_;
      this->print_object_ = x.print_object_;
    }

    return *this;
  }

  name_display::
  ~name_display ()
  {
  }

  // other_play
  //

  other_play::
  other_play (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this)
  {
  }

  other_play::
  other_play (const char* _xsd_string_base,
              const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_play::
  other_play (const ::std::string& _xsd_string_base,
              const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_play::
  other_play (const ::xml_schema::string& _xsd_string_base,
              const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_play::
  other_play (const other_play& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  other_play::
  other_play (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_play::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  other_play* other_play::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_play (*this, f, c);
  }

  other_play& other_play::
  operator= (const other_play& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  other_play::
  ~other_play ()
  {
  }

  // play
  //

  play::
  play ()
  : ::xml_schema::type (),
    ipa_ (this),
    mute_ (this),
    semi_pitched_ (this),
    other_play_ (this),
    id_ (this)
  {
  }

  play::
  play (const play& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    ipa_ (x.ipa_, f, this),
    mute_ (x.mute_, f, this),
    semi_pitched_ (x.semi_pitched_, f, this),
    other_play_ (x.other_play_, f, this),
    id_ (x.id_, f, this)
  {
  }

  play::
  play (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    ipa_ (this),
    mute_ (this),
    semi_pitched_ (this),
    other_play_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void play::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ipa
      //
      if (n.name () == "ipa" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ipa_type > r (
          ipa_traits::create (i, f, this));

        this->ipa_.push_back (::std::move (r));
        continue;
      }

      // mute
      //
      if (n.name () == "mute" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< mute_type > r (
          mute_traits::create (i, f, this));

        this->mute_.push_back (::std::move (r));
        continue;
      }

      // semi-pitched
      //
      if (n.name () == "semi-pitched" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< semi_pitched_type > r (
          semi_pitched_traits::create (i, f, this));

        this->semi_pitched_.push_back (::std::move (r));
        continue;
      }

      // other-play
      //
      if (n.name () == "other-play" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_play_type > r (
          other_play_traits::create (i, f, this));

        this->other_play_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  play* play::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class play (*this, f, c);
  }

  play& play::
  operator= (const play& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->ipa_ = x.ipa_;
      this->mute_ = x.mute_;
      this->semi_pitched_ = x.semi_pitched_;
      this->other_play_ = x.other_play_;
      this->id_ = x.id_;
    }

    return *this;
  }

  play::
  ~play ()
  {
  }

  // segno
  //

  segno::
  segno ()
  : ::xml_schema::type (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this),
    smufl_ (this)
  {
  }

  segno::
  segno (const segno& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  segno::
  segno (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void segno::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  segno* segno::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class segno (*this, f, c);
  }

  segno& segno::
  operator= (const segno& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  segno::
  ~segno ()
  {
  }

  // string
  //

  string::
  string (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::musicxml::string_number (_xsd_positive_integer_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  string::
  string (const string& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::string_number (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  string::
  string (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::string_number (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void string::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  string* string::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class string (*this, f, c);
  }

  string& string::
  operator= (const string& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::string_number& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  string::
  ~string ()
  {
  }

  // typed_text
  //

  typed_text::
  typed_text ()
  : ::xml_schema::string (),
    type_ (this)
  {
  }

  typed_text::
  typed_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  typed_text::
  typed_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  typed_text::
  typed_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  typed_text::
  typed_text (const typed_text& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  typed_text::
  typed_text (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void typed_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  typed_text* typed_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class typed_text (*this, f, c);
  }

  typed_text& typed_text::
  operator= (const typed_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  typed_text::
  ~typed_text ()
  {
  }

  // wavy_line
  //

  wavy_line::
  wavy_line (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    smufl_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this)
  {
  }

  wavy_line::
  wavy_line (const wavy_line& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    smufl_ (x.smufl_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    color_ (x.color_, f, this),
    start_note_ (x.start_note_, f, this),
    trill_step_ (x.trill_step_, f, this),
    two_note_turn_ (x.two_note_turn_, f, this),
    accelerate_ (x.accelerate_, f, this),
    beats_ (x.beats_, f, this),
    second_beat_ (x.second_beat_, f, this),
    last_beat_ (x.last_beat_, f, this)
  {
  }

  wavy_line::
  wavy_line (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    smufl_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    start_note_ (this),
    trill_step_ (this),
    two_note_turn_ (this),
    accelerate_ (this),
    beats_ (this),
    second_beat_ (this),
    last_beat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void wavy_line::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "start-note" && n.namespace_ ().empty ())
      {
        this->start_note_.set (start_note_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "trill-step" && n.namespace_ ().empty ())
      {
        this->trill_step_.set (trill_step_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "two-note-turn" && n.namespace_ ().empty ())
      {
        this->two_note_turn_.set (two_note_turn_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accelerate" && n.namespace_ ().empty ())
      {
        this->accelerate_.set (accelerate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        this->beats_.set (beats_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "second-beat" && n.namespace_ ().empty ())
      {
        this->second_beat_.set (second_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "last-beat" && n.namespace_ ().empty ())
      {
        this->last_beat_.set (last_beat_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  wavy_line* wavy_line::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wavy_line (*this, f, c);
  }

  wavy_line& wavy_line::
  operator= (const wavy_line& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->smufl_ = x.smufl_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->color_ = x.color_;
      this->start_note_ = x.start_note_;
      this->trill_step_ = x.trill_step_;
      this->two_note_turn_ = x.two_note_turn_;
      this->accelerate_ = x.accelerate_;
      this->beats_ = x.beats_;
      this->second_beat_ = x.second_beat_;
      this->last_beat_ = x.last_beat_;
    }

    return *this;
  }

  wavy_line::
  ~wavy_line ()
  {
  }

  // attributes
  //

  attributes::
  attributes ()
  : ::xml_schema::type (),
    footnote_ (this),
    level_ (this),
    divisions_ (this),
    key_ (this),
    time_ (this),
    staves_ (this),
    part_symbol_ (this),
    instruments_ (this),
    clef_ (this),
    staff_details_ (this),
    transpose_ (this),
    for_part_ (this),
    directive_ (this),
    measure_style_ (this)
  {
  }

  attributes::
  attributes (const attributes& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    divisions_ (x.divisions_, f, this),
    key_ (x.key_, f, this),
    time_ (x.time_, f, this),
    staves_ (x.staves_, f, this),
    part_symbol_ (x.part_symbol_, f, this),
    instruments_ (x.instruments_, f, this),
    clef_ (x.clef_, f, this),
    staff_details_ (x.staff_details_, f, this),
    transpose_ (x.transpose_, f, this),
    for_part_ (x.for_part_, f, this),
    directive_ (x.directive_, f, this),
    measure_style_ (x.measure_style_, f, this)
  {
  }

  attributes::
  attributes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    footnote_ (this),
    level_ (this),
    divisions_ (this),
    key_ (this),
    time_ (this),
    staves_ (this),
    part_symbol_ (this),
    instruments_ (this),
    clef_ (this),
    staff_details_ (this),
    transpose_ (this),
    for_part_ (this),
    directive_ (this),
    measure_style_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void attributes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // divisions
      //
      if (n.name () == "divisions" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< divisions_type > r (
          divisions_traits::create (i, f, this));

        if (!this->divisions_)
        {
          this->divisions_.set (::std::move (r));
          continue;
        }
      }

      // key
      //
      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< key_type > r (
          key_traits::create (i, f, this));

        this->key_.push_back (::std::move (r));
        continue;
      }

      // time
      //
      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< time_type > r (
          time_traits::create (i, f, this));

        this->time_.push_back (::std::move (r));
        continue;
      }

      // staves
      //
      if (n.name () == "staves" && n.namespace_ ().empty ())
      {
        if (!this->staves_)
        {
          this->staves_.set (staves_traits::create (i, f, this));
          continue;
        }
      }

      // part-symbol
      //
      if (n.name () == "part-symbol" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_symbol_type > r (
          part_symbol_traits::create (i, f, this));

        if (!this->part_symbol_)
        {
          this->part_symbol_.set (::std::move (r));
          continue;
        }
      }

      // instruments
      //
      if (n.name () == "instruments" && n.namespace_ ().empty ())
      {
        if (!this->instruments_)
        {
          this->instruments_.set (instruments_traits::create (i, f, this));
          continue;
        }
      }

      // clef
      //
      if (n.name () == "clef" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< clef_type > r (
          clef_traits::create (i, f, this));

        this->clef_.push_back (::std::move (r));
        continue;
      }

      // staff-details
      //
      if (n.name () == "staff-details" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_details_type > r (
          staff_details_traits::create (i, f, this));

        this->staff_details_.push_back (::std::move (r));
        continue;
      }

      // transpose
      //
      if (n.name () == "transpose" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< transpose_type > r (
          transpose_traits::create (i, f, this));

        this->transpose_.push_back (::std::move (r));
        continue;
      }

      // for-part
      //
      if (n.name () == "for-part" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< for_part_type > r (
          for_part_traits::create (i, f, this));

        this->for_part_.push_back (::std::move (r));
        continue;
      }

      // directive
      //
      if (n.name () == "directive" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< directive_type > r (
          directive_traits::create (i, f, this));

        this->directive_.push_back (::std::move (r));
        continue;
      }

      // measure-style
      //
      if (n.name () == "measure-style" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_style_type > r (
          measure_style_traits::create (i, f, this));

        this->measure_style_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  attributes* attributes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class attributes (*this, f, c);
  }

  attributes& attributes::
  operator= (const attributes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->divisions_ = x.divisions_;
      this->key_ = x.key_;
      this->time_ = x.time_;
      this->staves_ = x.staves_;
      this->part_symbol_ = x.part_symbol_;
      this->instruments_ = x.instruments_;
      this->clef_ = x.clef_;
      this->staff_details_ = x.staff_details_;
      this->transpose_ = x.transpose_;
      this->for_part_ = x.for_part_;
      this->directive_ = x.directive_;
      this->measure_style_ = x.measure_style_;
    }

    return *this;
  }

  attributes::
  ~attributes ()
  {
  }

  // beat_repeat
  //

  beat_repeat::
  beat_repeat (const type_type& type)
  : ::xml_schema::type (),
    slash_type_ (this),
    slash_dot_ (this),
    except_voice_ (this),
    type_ (type, this),
    slashes_ (this),
    use_dots_ (this)
  {
  }

  beat_repeat::
  beat_repeat (const beat_repeat& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    slash_type_ (x.slash_type_, f, this),
    slash_dot_ (x.slash_dot_, f, this),
    except_voice_ (x.except_voice_, f, this),
    type_ (x.type_, f, this),
    slashes_ (x.slashes_, f, this),
    use_dots_ (x.use_dots_, f, this)
  {
  }

  beat_repeat::
  beat_repeat (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    slash_type_ (this),
    slash_dot_ (this),
    except_voice_ (this),
    type_ (this),
    slashes_ (this),
    use_dots_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void beat_repeat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // slash-type
      //
      if (n.name () == "slash-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slash_type_type > r (
          slash_type_traits::create (i, f, this));

        if (!this->slash_type_)
        {
          this->slash_type_.set (::std::move (r));
          continue;
        }
      }

      // slash-dot
      //
      if (n.name () == "slash-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slash_dot_type > r (
          slash_dot_traits::create (i, f, this));

        this->slash_dot_.push_back (::std::move (r));
        continue;
      }

      // except-voice
      //
      if (n.name () == "except-voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< except_voice_type > r (
          except_voice_traits::create (i, f, this));

        this->except_voice_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slashes" && n.namespace_ ().empty ())
      {
        this->slashes_.set (slashes_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "use-dots" && n.namespace_ ().empty ())
      {
        this->use_dots_.set (use_dots_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  beat_repeat* beat_repeat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beat_repeat (*this, f, c);
  }

  beat_repeat& beat_repeat::
  operator= (const beat_repeat& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->slash_type_ = x.slash_type_;
      this->slash_dot_ = x.slash_dot_;
      this->except_voice_ = x.except_voice_;
      this->type_ = x.type_;
      this->slashes_ = x.slashes_;
      this->use_dots_ = x.use_dots_;
    }

    return *this;
  }

  beat_repeat::
  ~beat_repeat ()
  {
  }

  // cancel
  //

  cancel::
  cancel (const ::xml_schema::integer& _xsd_integer_base)
  : ::musicxml::fifths (_xsd_integer_base),
    location_ (this)
  {
  }

  cancel::
  cancel (const cancel& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::fifths (x, f, c),
    location_ (x.location_, f, this)
  {
  }

  cancel::
  cancel (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::fifths (e, f | ::xml_schema::flags::base, c),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void cancel::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }
  }

  cancel* cancel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class cancel (*this, f, c);
  }

  cancel& cancel::
  operator= (const cancel& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::fifths& > (*this) = x;
      this->location_ = x.location_;
    }

    return *this;
  }

  cancel::
  ~cancel ()
  {
  }

  // clef
  //

  clef::
  clef (const sign_type& sign)
  : ::xml_schema::type (),
    sign_ (sign, this),
    line_ (this),
    clef_octave_change_ (this),
    number_ (this),
    additional_ (this),
    size_ (this),
    after_barline_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    id_ (this)
  {
  }

  clef::
  clef (const clef& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sign_ (x.sign_, f, this),
    line_ (x.line_, f, this),
    clef_octave_change_ (x.clef_octave_change_, f, this),
    number_ (x.number_, f, this),
    additional_ (x.additional_, f, this),
    size_ (x.size_, f, this),
    after_barline_ (x.after_barline_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    print_object_ (x.print_object_, f, this),
    id_ (x.id_, f, this)
  {
  }

  clef::
  clef (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sign_ (this),
    line_ (this),
    clef_octave_change_ (this),
    number_ (this),
    additional_ (this),
    size_ (this),
    after_barline_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void clef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sign
      //
      if (n.name () == "sign" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sign_type > r (
          sign_traits::create (i, f, this));

        if (!sign_.present ())
        {
          this->sign_.set (::std::move (r));
          continue;
        }
      }

      // line
      //
      if (n.name () == "line" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< line_type > r (
          line_traits::create (i, f, this));

        if (!this->line_)
        {
          this->line_.set (::std::move (r));
          continue;
        }
      }

      // clef-octave-change
      //
      if (n.name () == "clef-octave-change" && n.namespace_ ().empty ())
      {
        if (!this->clef_octave_change_)
        {
          this->clef_octave_change_.set (clef_octave_change_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!sign_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sign",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "additional" && n.namespace_ ().empty ())
      {
        this->additional_.set (additional_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "after-barline" && n.namespace_ ().empty ())
      {
        this->after_barline_.set (after_barline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  clef* clef::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class clef (*this, f, c);
  }

  clef& clef::
  operator= (const clef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sign_ = x.sign_;
      this->line_ = x.line_;
      this->clef_octave_change_ = x.clef_octave_change_;
      this->number_ = x.number_;
      this->additional_ = x.additional_;
      this->size_ = x.size_;
      this->after_barline_ = x.after_barline_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->print_object_ = x.print_object_;
      this->id_ = x.id_;
    }

    return *this;
  }

  clef::
  ~clef ()
  {
  }

  // double_
  //

  double_::
  double_ ()
  : ::xml_schema::type (),
    above_ (this)
  {
  }

  double_::
  double_ (const double_& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    above_ (x.above_, f, this)
  {
  }

  double_::
  double_ (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    above_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void double_::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "above" && n.namespace_ ().empty ())
      {
        this->above_.set (above_traits::create (i, f, this));
        continue;
      }
    }
  }

  double_* double_::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class double_ (*this, f, c);
  }

  double_& double_::
  operator= (const double_& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->above_ = x.above_;
    }

    return *this;
  }

  double_::
  ~double_ ()
  {
  }

  // for_part
  //

  for_part::
  for_part (const part_transpose_type& part_transpose)
  : ::xml_schema::type (),
    part_clef_ (this),
    part_transpose_ (part_transpose, this),
    number_ (this),
    id_ (this)
  {
  }

  for_part::
  for_part (::std::unique_ptr< part_transpose_type > part_transpose)
  : ::xml_schema::type (),
    part_clef_ (this),
    part_transpose_ (std::move (part_transpose), this),
    number_ (this),
    id_ (this)
  {
  }

  for_part::
  for_part (const for_part& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    part_clef_ (x.part_clef_, f, this),
    part_transpose_ (x.part_transpose_, f, this),
    number_ (x.number_, f, this),
    id_ (x.id_, f, this)
  {
  }

  for_part::
  for_part (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    part_clef_ (this),
    part_transpose_ (this),
    number_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void for_part::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // part-clef
      //
      if (n.name () == "part-clef" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_clef_type > r (
          part_clef_traits::create (i, f, this));

        if (!this->part_clef_)
        {
          this->part_clef_.set (::std::move (r));
          continue;
        }
      }

      // part-transpose
      //
      if (n.name () == "part-transpose" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_transpose_type > r (
          part_transpose_traits::create (i, f, this));

        if (!part_transpose_.present ())
        {
          this->part_transpose_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!part_transpose_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "part-transpose",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  for_part* for_part::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class for_part (*this, f, c);
  }

  for_part& for_part::
  operator= (const for_part& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->part_clef_ = x.part_clef_;
      this->part_transpose_ = x.part_transpose_;
      this->number_ = x.number_;
      this->id_ = x.id_;
    }

    return *this;
  }

  for_part::
  ~for_part ()
  {
  }

  // interchangeable
  //

  interchangeable::
  interchangeable ()
  : ::xml_schema::type (),
    time_relation_ (this),
    beats_ (this),
    beat_type_ (this),
    symbol_ (this),
    separator_ (this)
  {
  }

  interchangeable::
  interchangeable (const interchangeable& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    time_relation_ (x.time_relation_, f, this),
    beats_ (x.beats_, f, this),
    beat_type_ (x.beat_type_, f, this),
    symbol_ (x.symbol_, f, this),
    separator_ (x.separator_, f, this)
  {
  }

  interchangeable::
  interchangeable (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    time_relation_ (this),
    beats_ (this),
    beat_type_ (this),
    symbol_ (this),
    separator_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void interchangeable::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // time-relation
      //
      if (n.name () == "time-relation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< time_relation_type > r (
          time_relation_traits::create (i, f, this));

        if (!this->time_relation_)
        {
          this->time_relation_.set (::std::move (r));
          continue;
        }
      }

      // beats
      //
      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beats_type > r (
          beats_traits::create (i, f, this));

        this->beats_.push_back (::std::move (r));
        continue;
      }

      // beat-type
      //
      if (n.name () == "beat-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_type_type > r (
          beat_type_traits::create (i, f, this));

        this->beat_type_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "separator" && n.namespace_ ().empty ())
      {
        this->separator_.set (separator_traits::create (i, f, this));
        continue;
      }
    }
  }

  interchangeable* interchangeable::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class interchangeable (*this, f, c);
  }

  interchangeable& interchangeable::
  operator= (const interchangeable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->time_relation_ = x.time_relation_;
      this->beats_ = x.beats_;
      this->beat_type_ = x.beat_type_;
      this->symbol_ = x.symbol_;
      this->separator_ = x.separator_;
    }

    return *this;
  }

  interchangeable::
  ~interchangeable ()
  {
  }

  // key
  //

  key::
  key ()
  : ::xml_schema::type (),
    cancel_ (this),
    fifths_ (this),
    mode_ (this),
    key_step_ (this),
    key_alter_ (this),
    key_accidental_ (this),
    key_octave_ (this),
    number_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    id_ (this)
  {
  }

  key::
  key (const key& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    cancel_ (x.cancel_, f, this),
    fifths_ (x.fifths_, f, this),
    mode_ (x.mode_, f, this),
    key_step_ (x.key_step_, f, this),
    key_alter_ (x.key_alter_, f, this),
    key_accidental_ (x.key_accidental_, f, this),
    key_octave_ (x.key_octave_, f, this),
    number_ (x.number_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    print_object_ (x.print_object_, f, this),
    id_ (x.id_, f, this)
  {
  }

  key::
  key (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    cancel_ (this),
    fifths_ (this),
    mode_ (this),
    key_step_ (this),
    key_alter_ (this),
    key_accidental_ (this),
    key_octave_ (this),
    number_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void key::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // cancel
      //
      if (n.name () == "cancel" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< cancel_type > r (
          cancel_traits::create (i, f, this));

        if (!this->cancel_)
        {
          this->cancel_.set (::std::move (r));
          continue;
        }
      }

      // fifths
      //
      if (n.name () == "fifths" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fifths_type > r (
          fifths_traits::create (i, f, this));

        if (!this->fifths_)
        {
          this->fifths_.set (::std::move (r));
          continue;
        }
      }

      // mode
      //
      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< mode_type > r (
          mode_traits::create (i, f, this));

        if (!this->mode_)
        {
          this->mode_.set (::std::move (r));
          continue;
        }
      }

      // key-step
      //
      if (n.name () == "key-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< key_step_type > r (
          key_step_traits::create (i, f, this));

        this->key_step_.push_back (::std::move (r));
        continue;
      }

      // key-alter
      //
      if (n.name () == "key-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< key_alter_type > r (
          key_alter_traits::create (i, f, this));

        this->key_alter_.push_back (::std::move (r));
        continue;
      }

      // key-accidental
      //
      if (n.name () == "key-accidental" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< key_accidental_type > r (
          key_accidental_traits::create (i, f, this));

        this->key_accidental_.push_back (::std::move (r));
        continue;
      }

      // key-octave
      //
      if (n.name () == "key-octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< key_octave_type > r (
          key_octave_traits::create (i, f, this));

        this->key_octave_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  key* key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key (*this, f, c);
  }

  key& key::
  operator= (const key& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->cancel_ = x.cancel_;
      this->fifths_ = x.fifths_;
      this->mode_ = x.mode_;
      this->key_step_ = x.key_step_;
      this->key_alter_ = x.key_alter_;
      this->key_accidental_ = x.key_accidental_;
      this->key_octave_ = x.key_octave_;
      this->number_ = x.number_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->print_object_ = x.print_object_;
      this->id_ = x.id_;
    }

    return *this;
  }

  key::
  ~key ()
  {
  }

  // key_accidental
  //

  key_accidental::
  key_accidental (::musicxml::accidental_value::value _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    smufl_ (this)
  {
  }

  key_accidental::
  key_accidental (const char* _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  key_accidental::
  key_accidental (const ::std::string& _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  key_accidental::
  key_accidental (const ::musicxml::accidental_value& _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    smufl_ (this)
  {
  }

  key_accidental::
  key_accidental (const key_accidental& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::accidental_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  key_accidental::
  key_accidental (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::accidental_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void key_accidental::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  key_accidental* key_accidental::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key_accidental (*this, f, c);
  }

  key_accidental& key_accidental::
  operator= (const key_accidental& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::accidental_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  key_accidental::
  ~key_accidental ()
  {
  }

  // key_octave
  //

  key_octave::
  key_octave (const ::xml_schema::integer& _xsd_integer_base,
              const number_type& number)
  : ::musicxml::octave (_xsd_integer_base),
    number_ (number, this),
    cancel_ (this)
  {
  }

  key_octave::
  key_octave (const key_octave& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::octave (x, f, c),
    number_ (x.number_, f, this),
    cancel_ (x.cancel_, f, this)
  {
  }

  key_octave::
  key_octave (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::octave (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    cancel_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void key_octave::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "cancel" && n.namespace_ ().empty ())
      {
        this->cancel_.set (cancel_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  key_octave* key_octave::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class key_octave (*this, f, c);
  }

  key_octave& key_octave::
  operator= (const key_octave& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::octave& > (*this) = x;
      this->number_ = x.number_;
      this->cancel_ = x.cancel_;
    }

    return *this;
  }

  key_octave::
  ~key_octave ()
  {
  }

  // line_detail
  //

  line_detail::
  line_detail (const line_type& line)
  : ::xml_schema::type (),
    line_ (line, this),
    width_ (this),
    color_ (this),
    line_type_ (this),
    print_object_ (this)
  {
  }

  line_detail::
  line_detail (const line_detail& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    line_ (x.line_, f, this),
    width_ (x.width_, f, this),
    color_ (x.color_, f, this),
    line_type_ (x.line_type_, f, this),
    print_object_ (x.print_object_, f, this)
  {
  }

  line_detail::
  line_detail (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    line_ (this),
    width_ (this),
    color_ (this),
    line_type_ (this),
    print_object_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void line_detail::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "line" && n.namespace_ ().empty ())
      {
        this->line_.set (line_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }
    }

    if (!line_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "line",
        "");
    }
  }

  line_detail* line_detail::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_detail (*this, f, c);
  }

  line_detail& line_detail::
  operator= (const line_detail& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->line_ = x.line_;
      this->width_ = x.width_;
      this->color_ = x.color_;
      this->line_type_ = x.line_type_;
      this->print_object_ = x.print_object_;
    }

    return *this;
  }

  line_detail::
  ~line_detail ()
  {
  }

  // measure_repeat
  //

  measure_repeat::
  measure_repeat (const char* _xsd_positive_integer_or_empty_base,
                  const type_type& type)
  : ::musicxml::positive_integer_or_empty (_xsd_positive_integer_or_empty_base),
    type_ (type, this),
    slashes_ (this)
  {
  }

  measure_repeat::
  measure_repeat (const ::std::string& _xsd_positive_integer_or_empty_base,
                  const type_type& type)
  : ::musicxml::positive_integer_or_empty (_xsd_positive_integer_or_empty_base),
    type_ (type, this),
    slashes_ (this)
  {
  }

  measure_repeat::
  measure_repeat (const ::musicxml::positive_integer_or_empty& _xsd_positive_integer_or_empty_base,
                  const type_type& type)
  : ::musicxml::positive_integer_or_empty (_xsd_positive_integer_or_empty_base),
    type_ (type, this),
    slashes_ (this)
  {
  }

  measure_repeat::
  measure_repeat (const measure_repeat& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::positive_integer_or_empty (x, f, c),
    type_ (x.type_, f, this),
    slashes_ (x.slashes_, f, this)
  {
  }

  measure_repeat::
  measure_repeat (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::positive_integer_or_empty (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    slashes_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void measure_repeat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slashes" && n.namespace_ ().empty ())
      {
        this->slashes_.set (slashes_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  measure_repeat* measure_repeat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_repeat (*this, f, c);
  }

  measure_repeat& measure_repeat::
  operator= (const measure_repeat& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::positive_integer_or_empty& > (*this) = x;
      this->type_ = x.type_;
      this->slashes_ = x.slashes_;
    }

    return *this;
  }

  measure_repeat::
  ~measure_repeat ()
  {
  }

  // measure_style
  //

  measure_style::
  measure_style ()
  : ::xml_schema::type (),
    multiple_rest_ (this),
    measure_repeat_ (this),
    beat_repeat_ (this),
    slash_ (this),
    number_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  measure_style::
  measure_style (const measure_style& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    multiple_rest_ (x.multiple_rest_, f, this),
    measure_repeat_ (x.measure_repeat_, f, this),
    beat_repeat_ (x.beat_repeat_, f, this),
    slash_ (x.slash_, f, this),
    number_ (x.number_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  measure_style::
  measure_style (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    multiple_rest_ (this),
    measure_repeat_ (this),
    beat_repeat_ (this),
    slash_ (this),
    number_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void measure_style::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // multiple-rest
      //
      if (n.name () == "multiple-rest" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< multiple_rest_type > r (
          multiple_rest_traits::create (i, f, this));

        if (!this->multiple_rest_)
        {
          this->multiple_rest_.set (::std::move (r));
          continue;
        }
      }

      // measure-repeat
      //
      if (n.name () == "measure-repeat" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_repeat_type > r (
          measure_repeat_traits::create (i, f, this));

        if (!this->measure_repeat_)
        {
          this->measure_repeat_.set (::std::move (r));
          continue;
        }
      }

      // beat-repeat
      //
      if (n.name () == "beat-repeat" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_repeat_type > r (
          beat_repeat_traits::create (i, f, this));

        if (!this->beat_repeat_)
        {
          this->beat_repeat_.set (::std::move (r));
          continue;
        }
      }

      // slash
      //
      if (n.name () == "slash" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slash_type > r (
          slash_traits::create (i, f, this));

        if (!this->slash_)
        {
          this->slash_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  measure_style* measure_style::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_style (*this, f, c);
  }

  measure_style& measure_style::
  operator= (const measure_style& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->multiple_rest_ = x.multiple_rest_;
      this->measure_repeat_ = x.measure_repeat_;
      this->beat_repeat_ = x.beat_repeat_;
      this->slash_ = x.slash_;
      this->number_ = x.number_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  measure_style::
  ~measure_style ()
  {
  }

  // multiple_rest
  //

  multiple_rest::
  multiple_rest (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
    use_symbols_ (this)
  {
  }

  multiple_rest::
  multiple_rest (const multiple_rest& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
    use_symbols_ (x.use_symbols_, f, this)
  {
  }

  multiple_rest::
  multiple_rest (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    use_symbols_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void multiple_rest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "use-symbols" && n.namespace_ ().empty ())
      {
        this->use_symbols_.set (use_symbols_traits::create (i, f, this));
        continue;
      }
    }
  }

  multiple_rest* multiple_rest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class multiple_rest (*this, f, c);
  }

  multiple_rest& multiple_rest::
  operator= (const multiple_rest& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->use_symbols_ = x.use_symbols_;
    }

    return *this;
  }

  multiple_rest::
  ~multiple_rest ()
  {
  }

  // part_clef
  //

  part_clef::
  part_clef (const sign_type& sign)
  : ::xml_schema::type (),
    sign_ (sign, this),
    line_ (this),
    clef_octave_change_ (this)
  {
  }

  part_clef::
  part_clef (const part_clef& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sign_ (x.sign_, f, this),
    line_ (x.line_, f, this),
    clef_octave_change_ (x.clef_octave_change_, f, this)
  {
  }

  part_clef::
  part_clef (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sign_ (this),
    line_ (this),
    clef_octave_change_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void part_clef::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sign
      //
      if (n.name () == "sign" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sign_type > r (
          sign_traits::create (i, f, this));

        if (!sign_.present ())
        {
          this->sign_.set (::std::move (r));
          continue;
        }
      }

      // line
      //
      if (n.name () == "line" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< line_type > r (
          line_traits::create (i, f, this));

        if (!this->line_)
        {
          this->line_.set (::std::move (r));
          continue;
        }
      }

      // clef-octave-change
      //
      if (n.name () == "clef-octave-change" && n.namespace_ ().empty ())
      {
        if (!this->clef_octave_change_)
        {
          this->clef_octave_change_.set (clef_octave_change_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!sign_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "sign",
        "");
    }
  }

  part_clef* part_clef::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_clef (*this, f, c);
  }

  part_clef& part_clef::
  operator= (const part_clef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sign_ = x.sign_;
      this->line_ = x.line_;
      this->clef_octave_change_ = x.clef_octave_change_;
    }

    return *this;
  }

  part_clef::
  ~part_clef ()
  {
  }

  // part_symbol
  //

  part_symbol::
  part_symbol (::musicxml::group_symbol_value::value _xsd_group_symbol_value_base)
  : ::musicxml::group_symbol_value (_xsd_group_symbol_value_base),
    top_staff_ (this),
    bottom_staff_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  part_symbol::
  part_symbol (const char* _xsd_string_base)
  : ::musicxml::group_symbol_value (_xsd_string_base),
    top_staff_ (this),
    bottom_staff_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  part_symbol::
  part_symbol (const ::std::string& _xsd_string_base)
  : ::musicxml::group_symbol_value (_xsd_string_base),
    top_staff_ (this),
    bottom_staff_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  part_symbol::
  part_symbol (const ::musicxml::group_symbol_value& _xsd_group_symbol_value_base)
  : ::musicxml::group_symbol_value (_xsd_group_symbol_value_base),
    top_staff_ (this),
    bottom_staff_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  part_symbol::
  part_symbol (const part_symbol& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::group_symbol_value (x, f, c),
    top_staff_ (x.top_staff_, f, this),
    bottom_staff_ (x.bottom_staff_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this)
  {
  }

  part_symbol::
  part_symbol (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::group_symbol_value (e, f | ::xml_schema::flags::base, c),
    top_staff_ (this),
    bottom_staff_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void part_symbol::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "top-staff" && n.namespace_ ().empty ())
      {
        this->top_staff_.set (top_staff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bottom-staff" && n.namespace_ ().empty ())
      {
        this->bottom_staff_.set (bottom_staff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  part_symbol* part_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_symbol (*this, f, c);
  }

  part_symbol& part_symbol::
  operator= (const part_symbol& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::group_symbol_value& > (*this) = x;
      this->top_staff_ = x.top_staff_;
      this->bottom_staff_ = x.bottom_staff_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
    }

    return *this;
  }

  part_symbol::
  ~part_symbol ()
  {
  }

  // part_transpose
  //

  part_transpose::
  part_transpose (const chromatic_type& chromatic)
  : ::xml_schema::type (),
    diatonic_ (this),
    chromatic_ (chromatic, this),
    octave_change_ (this),
    double__ (this)
  {
  }

  part_transpose::
  part_transpose (const part_transpose& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    diatonic_ (x.diatonic_, f, this),
    chromatic_ (x.chromatic_, f, this),
    octave_change_ (x.octave_change_, f, this),
    double__ (x.double__, f, this)
  {
  }

  part_transpose::
  part_transpose (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    diatonic_ (this),
    chromatic_ (this),
    octave_change_ (this),
    double__ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void part_transpose::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // diatonic
      //
      if (n.name () == "diatonic" && n.namespace_ ().empty ())
      {
        if (!this->diatonic_)
        {
          this->diatonic_.set (diatonic_traits::create (i, f, this));
          continue;
        }
      }

      // chromatic
      //
      if (n.name () == "chromatic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< chromatic_type > r (
          chromatic_traits::create (i, f, this));

        if (!chromatic_.present ())
        {
          this->chromatic_.set (::std::move (r));
          continue;
        }
      }

      // octave-change
      //
      if (n.name () == "octave-change" && n.namespace_ ().empty ())
      {
        if (!this->octave_change_)
        {
          this->octave_change_.set (octave_change_traits::create (i, f, this));
          continue;
        }
      }

      // double
      //
      if (n.name () == "double" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< double_type > r (
          double_traits::create (i, f, this));

        if (!this->double__)
        {
          this->double__.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!chromatic_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "chromatic",
        "");
    }
  }

  part_transpose* part_transpose::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_transpose (*this, f, c);
  }

  part_transpose& part_transpose::
  operator= (const part_transpose& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->diatonic_ = x.diatonic_;
      this->chromatic_ = x.chromatic_;
      this->octave_change_ = x.octave_change_;
      this->double__ = x.double__;
    }

    return *this;
  }

  part_transpose::
  ~part_transpose ()
  {
  }

  // slash
  //

  slash::
  slash (const type_type& type)
  : ::xml_schema::type (),
    slash_type_ (this),
    slash_dot_ (this),
    except_voice_ (this),
    type_ (type, this),
    use_dots_ (this),
    use_stems_ (this)
  {
  }

  slash::
  slash (const slash& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    slash_type_ (x.slash_type_, f, this),
    slash_dot_ (x.slash_dot_, f, this),
    except_voice_ (x.except_voice_, f, this),
    type_ (x.type_, f, this),
    use_dots_ (x.use_dots_, f, this),
    use_stems_ (x.use_stems_, f, this)
  {
  }

  slash::
  slash (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    slash_type_ (this),
    slash_dot_ (this),
    except_voice_ (this),
    type_ (this),
    use_dots_ (this),
    use_stems_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void slash::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // slash-type
      //
      if (n.name () == "slash-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slash_type_type > r (
          slash_type_traits::create (i, f, this));

        if (!this->slash_type_)
        {
          this->slash_type_.set (::std::move (r));
          continue;
        }
      }

      // slash-dot
      //
      if (n.name () == "slash-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slash_dot_type > r (
          slash_dot_traits::create (i, f, this));

        this->slash_dot_.push_back (::std::move (r));
        continue;
      }

      // except-voice
      //
      if (n.name () == "except-voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< except_voice_type > r (
          except_voice_traits::create (i, f, this));

        this->except_voice_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "use-dots" && n.namespace_ ().empty ())
      {
        this->use_dots_.set (use_dots_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "use-stems" && n.namespace_ ().empty ())
      {
        this->use_stems_.set (use_stems_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  slash* slash::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class slash (*this, f, c);
  }

  slash& slash::
  operator= (const slash& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->slash_type_ = x.slash_type_;
      this->slash_dot_ = x.slash_dot_;
      this->except_voice_ = x.except_voice_;
      this->type_ = x.type_;
      this->use_dots_ = x.use_dots_;
      this->use_stems_ = x.use_stems_;
    }

    return *this;
  }

  slash::
  ~slash ()
  {
  }

  // staff_details
  //

  staff_details::
  staff_details ()
  : ::xml_schema::type (),
    staff_type_ (this),
    staff_lines_ (this),
    line_detail_ (this),
    staff_tuning_ (this),
    capo_ (this),
    staff_size_ (this),
    number_ (this),
    show_frets_ (this),
    print_object_ (this),
    print_spacing_ (this)
  {
  }

  staff_details::
  staff_details (const staff_details& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    staff_type_ (x.staff_type_, f, this),
    staff_lines_ (x.staff_lines_, f, this),
    line_detail_ (x.line_detail_, f, this),
    staff_tuning_ (x.staff_tuning_, f, this),
    capo_ (x.capo_, f, this),
    staff_size_ (x.staff_size_, f, this),
    number_ (x.number_, f, this),
    show_frets_ (x.show_frets_, f, this),
    print_object_ (x.print_object_, f, this),
    print_spacing_ (x.print_spacing_, f, this)
  {
  }

  staff_details::
  staff_details (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    staff_type_ (this),
    staff_lines_ (this),
    line_detail_ (this),
    staff_tuning_ (this),
    capo_ (this),
    staff_size_ (this),
    number_ (this),
    show_frets_ (this),
    print_object_ (this),
    print_spacing_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void staff_details::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // staff-type
      //
      if (n.name () == "staff-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_type_type > r (
          staff_type_traits::create (i, f, this));

        if (!this->staff_type_)
        {
          this->staff_type_.set (::std::move (r));
          continue;
        }
      }

      // staff-lines
      //
      if (n.name () == "staff-lines" && n.namespace_ ().empty ())
      {
        if (!this->staff_lines_)
        {
          this->staff_lines_.set (staff_lines_traits::create (i, f, this));
          continue;
        }
      }

      // line-detail
      //
      if (n.name () == "line-detail" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< line_detail_type > r (
          line_detail_traits::create (i, f, this));

        this->line_detail_.push_back (::std::move (r));
        continue;
      }

      // staff-tuning
      //
      if (n.name () == "staff-tuning" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_tuning_type > r (
          staff_tuning_traits::create (i, f, this));

        this->staff_tuning_.push_back (::std::move (r));
        continue;
      }

      // capo
      //
      if (n.name () == "capo" && n.namespace_ ().empty ())
      {
        if (!this->capo_)
        {
          this->capo_.set (capo_traits::create (i, f, this));
          continue;
        }
      }

      // staff-size
      //
      if (n.name () == "staff-size" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_size_type > r (
          staff_size_traits::create (i, f, this));

        if (!this->staff_size_)
        {
          this->staff_size_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show-frets" && n.namespace_ ().empty ())
      {
        this->show_frets_.set (show_frets_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-spacing" && n.namespace_ ().empty ())
      {
        this->print_spacing_.set (print_spacing_traits::create (i, f, this));
        continue;
      }
    }
  }

  staff_details* staff_details::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_details (*this, f, c);
  }

  staff_details& staff_details::
  operator= (const staff_details& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->staff_type_ = x.staff_type_;
      this->staff_lines_ = x.staff_lines_;
      this->line_detail_ = x.line_detail_;
      this->staff_tuning_ = x.staff_tuning_;
      this->capo_ = x.capo_;
      this->staff_size_ = x.staff_size_;
      this->number_ = x.number_;
      this->show_frets_ = x.show_frets_;
      this->print_object_ = x.print_object_;
      this->print_spacing_ = x.print_spacing_;
    }

    return *this;
  }

  staff_details::
  ~staff_details ()
  {
  }

  // staff_size
  //

  staff_size::
  staff_size (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::musicxml::non_negative_decimal (_xsd_decimal_base),
    scaling_ (this)
  {
  }

  staff_size::
  staff_size (const staff_size& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::non_negative_decimal (x, f, c),
    scaling_ (x.scaling_, f, this)
  {
  }

  staff_size::
  staff_size (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::non_negative_decimal (e, f | ::xml_schema::flags::base, c),
    scaling_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void staff_size::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scaling" && n.namespace_ ().empty ())
      {
        this->scaling_.set (scaling_traits::create (i, f, this));
        continue;
      }
    }
  }

  staff_size* staff_size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_size (*this, f, c);
  }

  staff_size& staff_size::
  operator= (const staff_size& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::non_negative_decimal& > (*this) = x;
      this->scaling_ = x.scaling_;
    }

    return *this;
  }

  staff_size::
  ~staff_size ()
  {
  }

  // staff_tuning
  //

  staff_tuning::
  staff_tuning (const tuning_step_type& tuning_step,
                const tuning_octave_type& tuning_octave,
                const line_type& line)
  : ::xml_schema::type (),
    tuning_step_ (tuning_step, this),
    tuning_alter_ (this),
    tuning_octave_ (tuning_octave, this),
    line_ (line, this)
  {
  }

  staff_tuning::
  staff_tuning (const staff_tuning& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tuning_step_ (x.tuning_step_, f, this),
    tuning_alter_ (x.tuning_alter_, f, this),
    tuning_octave_ (x.tuning_octave_, f, this),
    line_ (x.line_, f, this)
  {
  }

  staff_tuning::
  staff_tuning (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tuning_step_ (this),
    tuning_alter_ (this),
    tuning_octave_ (this),
    line_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void staff_tuning::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tuning-step
      //
      if (n.name () == "tuning-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_step_type > r (
          tuning_step_traits::create (i, f, this));

        if (!tuning_step_.present ())
        {
          this->tuning_step_.set (::std::move (r));
          continue;
        }
      }

      // tuning-alter
      //
      if (n.name () == "tuning-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_alter_type > r (
          tuning_alter_traits::create (i, f, this));

        if (!this->tuning_alter_)
        {
          this->tuning_alter_.set (::std::move (r));
          continue;
        }
      }

      // tuning-octave
      //
      if (n.name () == "tuning-octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_octave_type > r (
          tuning_octave_traits::create (i, f, this));

        if (!tuning_octave_.present ())
        {
          this->tuning_octave_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!tuning_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tuning-step",
        "");
    }

    if (!tuning_octave_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tuning-octave",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "line" && n.namespace_ ().empty ())
      {
        this->line_.set (line_traits::create (i, f, this));
        continue;
      }
    }

    if (!line_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "line",
        "");
    }
  }

  staff_tuning* staff_tuning::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_tuning (*this, f, c);
  }

  staff_tuning& staff_tuning::
  operator= (const staff_tuning& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tuning_step_ = x.tuning_step_;
      this->tuning_alter_ = x.tuning_alter_;
      this->tuning_octave_ = x.tuning_octave_;
      this->line_ = x.line_;
    }

    return *this;
  }

  staff_tuning::
  ~staff_tuning ()
  {
  }

  // time
  //

  time::
  time ()
  : ::xml_schema::type (),
    beats_ (this),
    beat_type_ (this),
    interchangeable_ (this),
    senza_misura_ (this),
    number_ (this),
    symbol_ (this),
    separator_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    print_object_ (this),
    id_ (this)
  {
  }

  time::
  time (const time& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    beats_ (x.beats_, f, this),
    beat_type_ (x.beat_type_, f, this),
    interchangeable_ (x.interchangeable_, f, this),
    senza_misura_ (x.senza_misura_, f, this),
    number_ (x.number_, f, this),
    symbol_ (x.symbol_, f, this),
    separator_ (x.separator_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    print_object_ (x.print_object_, f, this),
    id_ (x.id_, f, this)
  {
  }

  time::
  time (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    beats_ (this),
    beat_type_ (this),
    interchangeable_ (this),
    senza_misura_ (this),
    number_ (this),
    symbol_ (this),
    separator_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    print_object_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void time::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // beats
      //
      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beats_type > r (
          beats_traits::create (i, f, this));

        this->beats_.push_back (::std::move (r));
        continue;
      }

      // beat-type
      //
      if (n.name () == "beat-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_type_type > r (
          beat_type_traits::create (i, f, this));

        this->beat_type_.push_back (::std::move (r));
        continue;
      }

      // interchangeable
      //
      if (n.name () == "interchangeable" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< interchangeable_type > r (
          interchangeable_traits::create (i, f, this));

        if (!this->interchangeable_)
        {
          this->interchangeable_.set (::std::move (r));
          continue;
        }
      }

      // senza-misura
      //
      if (n.name () == "senza-misura" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< senza_misura_type > r (
          senza_misura_traits::create (i, f, this));

        if (!this->senza_misura_)
        {
          this->senza_misura_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "separator" && n.namespace_ ().empty ())
      {
        this->separator_.set (separator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  time* time::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time (*this, f, c);
  }

  time& time::
  operator= (const time& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->beats_ = x.beats_;
      this->beat_type_ = x.beat_type_;
      this->interchangeable_ = x.interchangeable_;
      this->senza_misura_ = x.senza_misura_;
      this->number_ = x.number_;
      this->symbol_ = x.symbol_;
      this->separator_ = x.separator_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->print_object_ = x.print_object_;
      this->id_ = x.id_;
    }

    return *this;
  }

  time::
  ~time ()
  {
  }

  // transpose
  //

  transpose::
  transpose (const chromatic_type& chromatic)
  : ::xml_schema::type (),
    diatonic_ (this),
    chromatic_ (chromatic, this),
    octave_change_ (this),
    double__ (this),
    number_ (this),
    id_ (this)
  {
  }

  transpose::
  transpose (const transpose& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    diatonic_ (x.diatonic_, f, this),
    chromatic_ (x.chromatic_, f, this),
    octave_change_ (x.octave_change_, f, this),
    double__ (x.double__, f, this),
    number_ (x.number_, f, this),
    id_ (x.id_, f, this)
  {
  }

  transpose::
  transpose (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    diatonic_ (this),
    chromatic_ (this),
    octave_change_ (this),
    double__ (this),
    number_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void transpose::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // diatonic
      //
      if (n.name () == "diatonic" && n.namespace_ ().empty ())
      {
        if (!this->diatonic_)
        {
          this->diatonic_.set (diatonic_traits::create (i, f, this));
          continue;
        }
      }

      // chromatic
      //
      if (n.name () == "chromatic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< chromatic_type > r (
          chromatic_traits::create (i, f, this));

        if (!chromatic_.present ())
        {
          this->chromatic_.set (::std::move (r));
          continue;
        }
      }

      // octave-change
      //
      if (n.name () == "octave-change" && n.namespace_ ().empty ())
      {
        if (!this->octave_change_)
        {
          this->octave_change_.set (octave_change_traits::create (i, f, this));
          continue;
        }
      }

      // double
      //
      if (n.name () == "double" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< double_type > r (
          double_traits::create (i, f, this));

        if (!this->double__)
        {
          this->double__.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!chromatic_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "chromatic",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  transpose* transpose::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class transpose (*this, f, c);
  }

  transpose& transpose::
  operator= (const transpose& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->diatonic_ = x.diatonic_;
      this->chromatic_ = x.chromatic_;
      this->octave_change_ = x.octave_change_;
      this->double__ = x.double__;
      this->number_ = x.number_;
      this->id_ = x.id_;
    }

    return *this;
  }

  transpose::
  ~transpose ()
  {
  }

  // bar_style_color
  //

  bar_style_color::
  bar_style_color (::musicxml::bar_style::value _xsd_bar_style_base)
  : ::musicxml::bar_style (_xsd_bar_style_base),
    color_ (this)
  {
  }

  bar_style_color::
  bar_style_color (const char* _xsd_string_base)
  : ::musicxml::bar_style (_xsd_string_base),
    color_ (this)
  {
  }

  bar_style_color::
  bar_style_color (const ::std::string& _xsd_string_base)
  : ::musicxml::bar_style (_xsd_string_base),
    color_ (this)
  {
  }

  bar_style_color::
  bar_style_color (const ::musicxml::bar_style& _xsd_bar_style_base)
  : ::musicxml::bar_style (_xsd_bar_style_base),
    color_ (this)
  {
  }

  bar_style_color::
  bar_style_color (const bar_style_color& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::bar_style (x, f, c),
    color_ (x.color_, f, this)
  {
  }

  bar_style_color::
  bar_style_color (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::bar_style (e, f | ::xml_schema::flags::base, c),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void bar_style_color::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  bar_style_color* bar_style_color::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bar_style_color (*this, f, c);
  }

  bar_style_color& bar_style_color::
  operator= (const bar_style_color& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::bar_style& > (*this) = x;
      this->color_ = x.color_;
    }

    return *this;
  }

  bar_style_color::
  ~bar_style_color ()
  {
  }

  // barline
  //

  const barline::location_type barline::location_default_value_ (
    "right");

  barline::
  barline ()
  : ::xml_schema::type (),
    bar_style_ (this),
    footnote_ (this),
    level_ (this),
    wavy_line_ (this),
    segno_ (this),
    coda_ (this),
    fermata_ (this),
    ending_ (this),
    repeat_ (this),
    location_ (location_default_value (), this),
    segno1_ (this),
    coda1_ (this),
    divisions_ (this),
    id_ (this)
  {
  }

  barline::
  barline (const barline& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bar_style_ (x.bar_style_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    wavy_line_ (x.wavy_line_, f, this),
    segno_ (x.segno_, f, this),
    coda_ (x.coda_, f, this),
    fermata_ (x.fermata_, f, this),
    ending_ (x.ending_, f, this),
    repeat_ (x.repeat_, f, this),
    location_ (x.location_, f, this),
    segno1_ (x.segno1_, f, this),
    coda1_ (x.coda1_, f, this),
    divisions_ (x.divisions_, f, this),
    id_ (x.id_, f, this)
  {
  }

  barline::
  barline (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bar_style_ (this),
    footnote_ (this),
    level_ (this),
    wavy_line_ (this),
    segno_ (this),
    coda_ (this),
    fermata_ (this),
    ending_ (this),
    repeat_ (this),
    location_ (this),
    segno1_ (this),
    coda1_ (this),
    divisions_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void barline::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bar-style
      //
      if (n.name () == "bar-style" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bar_style_type > r (
          bar_style_traits::create (i, f, this));

        if (!this->bar_style_)
        {
          this->bar_style_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // wavy-line
      //
      if (n.name () == "wavy-line" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< wavy_line_type > r (
          wavy_line_traits::create (i, f, this));

        if (!this->wavy_line_)
        {
          this->wavy_line_.set (::std::move (r));
          continue;
        }
      }

      // segno
      //
      if (n.name () == "segno" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< segno_type > r (
          segno_traits::create (i, f, this));

        if (!this->segno_)
        {
          this->segno_.set (::std::move (r));
          continue;
        }
      }

      // coda
      //
      if (n.name () == "coda" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< coda_type > r (
          coda_traits::create (i, f, this));

        if (!this->coda_)
        {
          this->coda_.set (::std::move (r));
          continue;
        }
      }

      // fermata
      //
      if (n.name () == "fermata" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fermata_type > r (
          fermata_traits::create (i, f, this));

        this->fermata_.push_back (::std::move (r));
        continue;
      }

      // ending
      //
      if (n.name () == "ending" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ending_type > r (
          ending_traits::create (i, f, this));

        if (!this->ending_)
        {
          this->ending_.set (::std::move (r));
          continue;
        }
      }

      // repeat
      //
      if (n.name () == "repeat" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< repeat_type > r (
          repeat_traits::create (i, f, this));

        if (!this->repeat_)
        {
          this->repeat_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segno" && n.namespace_ ().empty ())
      {
        this->segno1_.set (segno1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "coda" && n.namespace_ ().empty ())
      {
        this->coda1_.set (coda1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "divisions" && n.namespace_ ().empty ())
      {
        this->divisions_.set (divisions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!location_.present ())
    {
      this->location_.set (location_default_value ());
    }
  }

  barline* barline::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class barline (*this, f, c);
  }

  barline& barline::
  operator= (const barline& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->bar_style_ = x.bar_style_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->wavy_line_ = x.wavy_line_;
      this->segno_ = x.segno_;
      this->coda_ = x.coda_;
      this->fermata_ = x.fermata_;
      this->ending_ = x.ending_;
      this->repeat_ = x.repeat_;
      this->location_ = x.location_;
      this->segno1_ = x.segno1_;
      this->coda1_ = x.coda1_;
      this->divisions_ = x.divisions_;
      this->id_ = x.id_;
    }

    return *this;
  }

  barline::
  ~barline ()
  {
  }

  // ending
  //

  ending::
  ending (const number_type& number,
          const type_type& type)
  : ::xml_schema::string (),
    number_ (number, this),
    type_ (type, this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    system_ (this),
    end_length_ (this),
    text_x_ (this),
    text_y_ (this)
  {
  }

  ending::
  ending (const char* _xsd_string_base,
          const number_type& number,
          const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    number_ (number, this),
    type_ (type, this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    system_ (this),
    end_length_ (this),
    text_x_ (this),
    text_y_ (this)
  {
  }

  ending::
  ending (const ::std::string& _xsd_string_base,
          const number_type& number,
          const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    number_ (number, this),
    type_ (type, this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    system_ (this),
    end_length_ (this),
    text_x_ (this),
    text_y_ (this)
  {
  }

  ending::
  ending (const ::xml_schema::string& _xsd_string_base,
          const number_type& number,
          const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    number_ (number, this),
    type_ (type, this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    system_ (this),
    end_length_ (this),
    text_x_ (this),
    text_y_ (this)
  {
  }

  ending::
  ending (const ending& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    number_ (x.number_, f, this),
    type_ (x.type_, f, this),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    system_ (x.system_, f, this),
    end_length_ (x.end_length_, f, this),
    text_x_ (x.text_x_, f, this),
    text_y_ (x.text_y_, f, this)
  {
  }

  ending::
  ending (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    type_ (this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    system_ (this),
    end_length_ (this),
    text_x_ (this),
    text_y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ending::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        this->system_.set (system_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end-length" && n.namespace_ ().empty ())
      {
        this->end_length_.set (end_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text-x" && n.namespace_ ().empty ())
      {
        this->text_x_.set (text_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text-y" && n.namespace_ ().empty ())
      {
        this->text_y_.set (text_y_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  ending* ending::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ending (*this, f, c);
  }

  ending& ending::
  operator= (const ending& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->number_ = x.number_;
      this->type_ = x.type_;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->system_ = x.system_;
      this->end_length_ = x.end_length_;
      this->text_x_ = x.text_x_;
      this->text_y_ = x.text_y_;
    }

    return *this;
  }

  ending::
  ~ending ()
  {
  }

  // repeat
  //

  repeat::
  repeat (const direction_type& direction)
  : ::xml_schema::type (),
    direction_ (direction, this),
    times_ (this),
    after_jump_ (this),
    winged_ (this)
  {
  }

  repeat::
  repeat (const repeat& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    direction_ (x.direction_, f, this),
    times_ (x.times_, f, this),
    after_jump_ (x.after_jump_, f, this),
    winged_ (x.winged_, f, this)
  {
  }

  repeat::
  repeat (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    direction_ (this),
    times_ (this),
    after_jump_ (this),
    winged_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void repeat::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        this->direction_.set (direction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "times" && n.namespace_ ().empty ())
      {
        this->times_.set (times_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "after-jump" && n.namespace_ ().empty ())
      {
        this->after_jump_.set (after_jump_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "winged" && n.namespace_ ().empty ())
      {
        this->winged_.set (winged_traits::create (i, f, this));
        continue;
      }
    }

    if (!direction_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "direction",
        "");
    }
  }

  repeat* repeat::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class repeat (*this, f, c);
  }

  repeat& repeat::
  operator= (const repeat& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->direction_ = x.direction_;
      this->times_ = x.times_;
      this->after_jump_ = x.after_jump_;
      this->winged_ = x.winged_;
    }

    return *this;
  }

  repeat::
  ~repeat ()
  {
  }

  // accord
  //

  accord::
  accord (const tuning_step_type& tuning_step,
          const tuning_octave_type& tuning_octave)
  : ::xml_schema::type (),
    tuning_step_ (tuning_step, this),
    tuning_alter_ (this),
    tuning_octave_ (tuning_octave, this),
    string_ (this)
  {
  }

  accord::
  accord (const accord& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tuning_step_ (x.tuning_step_, f, this),
    tuning_alter_ (x.tuning_alter_, f, this),
    tuning_octave_ (x.tuning_octave_, f, this),
    string_ (x.string_, f, this)
  {
  }

  accord::
  accord (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tuning_step_ (this),
    tuning_alter_ (this),
    tuning_octave_ (this),
    string_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void accord::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tuning-step
      //
      if (n.name () == "tuning-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_step_type > r (
          tuning_step_traits::create (i, f, this));

        if (!tuning_step_.present ())
        {
          this->tuning_step_.set (::std::move (r));
          continue;
        }
      }

      // tuning-alter
      //
      if (n.name () == "tuning-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_alter_type > r (
          tuning_alter_traits::create (i, f, this));

        if (!this->tuning_alter_)
        {
          this->tuning_alter_.set (::std::move (r));
          continue;
        }
      }

      // tuning-octave
      //
      if (n.name () == "tuning-octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuning_octave_type > r (
          tuning_octave_traits::create (i, f, this));

        if (!tuning_octave_.present ())
        {
          this->tuning_octave_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!tuning_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tuning-step",
        "");
    }

    if (!tuning_octave_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tuning-octave",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "string" && n.namespace_ ().empty ())
      {
        this->string_.set (string_traits::create (i, f, this));
        continue;
      }
    }
  }

  accord* accord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accord (*this, f, c);
  }

  accord& accord::
  operator= (const accord& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tuning_step_ = x.tuning_step_;
      this->tuning_alter_ = x.tuning_alter_;
      this->tuning_octave_ = x.tuning_octave_;
      this->string_ = x.string_;
    }

    return *this;
  }

  accord::
  ~accord ()
  {
  }

  // accordion_registration
  //

  accordion_registration::
  accordion_registration ()
  : ::xml_schema::type (),
    accordion_high_ (this),
    accordion_middle_ (this),
    accordion_low_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  accordion_registration::
  accordion_registration (const accordion_registration& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    accordion_high_ (x.accordion_high_, f, this),
    accordion_middle_ (x.accordion_middle_, f, this),
    accordion_low_ (x.accordion_low_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  accordion_registration::
  accordion_registration (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    accordion_high_ (this),
    accordion_middle_ (this),
    accordion_low_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void accordion_registration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accordion-high
      //
      if (n.name () == "accordion-high" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accordion_high_type > r (
          accordion_high_traits::create (i, f, this));

        if (!this->accordion_high_)
        {
          this->accordion_high_.set (::std::move (r));
          continue;
        }
      }

      // accordion-middle
      //
      if (n.name () == "accordion-middle" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accordion_middle_type > r (
          accordion_middle_traits::create (i, f, this));

        if (!this->accordion_middle_)
        {
          this->accordion_middle_.set (::std::move (r));
          continue;
        }
      }

      // accordion-low
      //
      if (n.name () == "accordion-low" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accordion_low_type > r (
          accordion_low_traits::create (i, f, this));

        if (!this->accordion_low_)
        {
          this->accordion_low_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  accordion_registration* accordion_registration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accordion_registration (*this, f, c);
  }

  accordion_registration& accordion_registration::
  operator= (const accordion_registration& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->accordion_high_ = x.accordion_high_;
      this->accordion_middle_ = x.accordion_middle_;
      this->accordion_low_ = x.accordion_low_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  accordion_registration::
  ~accordion_registration ()
  {
  }

  // barre
  //

  barre::
  barre (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    color_ (this)
  {
  }

  barre::
  barre (const barre& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    color_ (x.color_, f, this)
  {
  }

  barre::
  barre (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void barre::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  barre* barre::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class barre (*this, f, c);
  }

  barre& barre::
  operator= (const barre& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->color_ = x.color_;
    }

    return *this;
  }

  barre::
  ~barre ()
  {
  }

  // bass
  //

  bass::
  bass (const bass_step_type& bass_step)
  : ::xml_schema::type (),
    bass_separator_ (this),
    bass_step_ (bass_step, this),
    bass_alter_ (this),
    arrangement_ (this)
  {
  }

  bass::
  bass (::std::unique_ptr< bass_step_type > bass_step)
  : ::xml_schema::type (),
    bass_separator_ (this),
    bass_step_ (std::move (bass_step), this),
    bass_alter_ (this),
    arrangement_ (this)
  {
  }

  bass::
  bass (const bass& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bass_separator_ (x.bass_separator_, f, this),
    bass_step_ (x.bass_step_, f, this),
    bass_alter_ (x.bass_alter_, f, this),
    arrangement_ (x.arrangement_, f, this)
  {
  }

  bass::
  bass (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bass_separator_ (this),
    bass_step_ (this),
    bass_alter_ (this),
    arrangement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void bass::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bass-separator
      //
      if (n.name () == "bass-separator" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bass_separator_type > r (
          bass_separator_traits::create (i, f, this));

        if (!this->bass_separator_)
        {
          this->bass_separator_.set (::std::move (r));
          continue;
        }
      }

      // bass-step
      //
      if (n.name () == "bass-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bass_step_type > r (
          bass_step_traits::create (i, f, this));

        if (!bass_step_.present ())
        {
          this->bass_step_.set (::std::move (r));
          continue;
        }
      }

      // bass-alter
      //
      if (n.name () == "bass-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bass_alter_type > r (
          bass_alter_traits::create (i, f, this));

        if (!this->bass_alter_)
        {
          this->bass_alter_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!bass_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bass-step",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "arrangement" && n.namespace_ ().empty ())
      {
        this->arrangement_.set (arrangement_traits::create (i, f, this));
        continue;
      }
    }
  }

  bass* bass::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bass (*this, f, c);
  }

  bass& bass::
  operator= (const bass& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->bass_separator_ = x.bass_separator_;
      this->bass_step_ = x.bass_step_;
      this->bass_alter_ = x.bass_alter_;
      this->arrangement_ = x.arrangement_;
    }

    return *this;
  }

  bass::
  ~bass ()
  {
  }

  // harmony_alter
  //

  harmony_alter::
  harmony_alter (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::musicxml::semitones (_xsd_decimal_base),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    location_ (this)
  {
  }

  harmony_alter::
  harmony_alter (const harmony_alter& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::semitones (x, f, c),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    location_ (x.location_, f, this)
  {
  }

  harmony_alter::
  harmony_alter (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::semitones (e, f | ::xml_schema::flags::base, c),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void harmony_alter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }
  }

  harmony_alter* harmony_alter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmony_alter (*this, f, c);
  }

  harmony_alter& harmony_alter::
  operator= (const harmony_alter& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::semitones& > (*this) = x;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->location_ = x.location_;
    }

    return *this;
  }

  harmony_alter::
  ~harmony_alter ()
  {
  }

  // bass_step
  //

  bass_step::
  bass_step (::musicxml::step::value _xsd_step_base)
  : ::musicxml::step (_xsd_step_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  bass_step::
  bass_step (const char* _xsd_string_base)
  : ::musicxml::step (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  bass_step::
  bass_step (const ::std::string& _xsd_string_base)
  : ::musicxml::step (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  bass_step::
  bass_step (const ::musicxml::step& _xsd_step_base)
  : ::musicxml::step (_xsd_step_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  bass_step::
  bass_step (const bass_step& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::step (x, f, c),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  bass_step::
  bass_step (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::step (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void bass_step::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  bass_step* bass_step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bass_step (*this, f, c);
  }

  bass_step& bass_step::
  operator= (const bass_step& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::step& > (*this) = x;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  bass_step::
  ~bass_step ()
  {
  }

  // beater
  //

  beater::
  beater (::musicxml::beater_value::value _xsd_beater_value_base)
  : ::musicxml::beater_value (_xsd_beater_value_base),
    tip_ (this)
  {
  }

  beater::
  beater (const char* _xsd_string_base)
  : ::musicxml::beater_value (_xsd_string_base),
    tip_ (this)
  {
  }

  beater::
  beater (const ::std::string& _xsd_string_base)
  : ::musicxml::beater_value (_xsd_string_base),
    tip_ (this)
  {
  }

  beater::
  beater (const ::musicxml::beater_value& _xsd_beater_value_base)
  : ::musicxml::beater_value (_xsd_beater_value_base),
    tip_ (this)
  {
  }

  beater::
  beater (const beater& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::beater_value (x, f, c),
    tip_ (x.tip_, f, this)
  {
  }

  beater::
  beater (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::beater_value (e, f | ::xml_schema::flags::base, c),
    tip_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void beater::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tip" && n.namespace_ ().empty ())
      {
        this->tip_.set (tip_traits::create (i, f, this));
        continue;
      }
    }
  }

  beater* beater::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beater (*this, f, c);
  }

  beater& beater::
  operator= (const beater& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::beater_value& > (*this) = x;
      this->tip_ = x.tip_;
    }

    return *this;
  }

  beater::
  ~beater ()
  {
  }

  // beat_unit_tied
  //

  beat_unit_tied::
  beat_unit_tied (const beat_unit_type& beat_unit)
  : ::xml_schema::type (),
    beat_unit_ (beat_unit, this),
    beat_unit_dot_ (this)
  {
  }

  beat_unit_tied::
  beat_unit_tied (const beat_unit_tied& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    beat_unit_ (x.beat_unit_, f, this),
    beat_unit_dot_ (x.beat_unit_dot_, f, this)
  {
  }

  beat_unit_tied::
  beat_unit_tied (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    beat_unit_ (this),
    beat_unit_dot_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void beat_unit_tied::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // beat-unit
      //
      if (n.name () == "beat-unit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_unit_type > r (
          beat_unit_traits::create (i, f, this));

        if (!beat_unit_.present ())
        {
          this->beat_unit_.set (::std::move (r));
          continue;
        }
      }

      // beat-unit-dot
      //
      if (n.name () == "beat-unit-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_unit_dot_type > r (
          beat_unit_dot_traits::create (i, f, this));

        this->beat_unit_dot_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!beat_unit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "beat-unit",
        "");
    }
  }

  beat_unit_tied* beat_unit_tied::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beat_unit_tied (*this, f, c);
  }

  beat_unit_tied& beat_unit_tied::
  operator= (const beat_unit_tied& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->beat_unit_ = x.beat_unit_;
      this->beat_unit_dot_ = x.beat_unit_dot_;
    }

    return *this;
  }

  beat_unit_tied::
  ~beat_unit_tied ()
  {
  }

  // bracket
  //

  bracket::
  bracket (const type_type& type,
           const line_end_type& line_end)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    line_end_ (line_end, this),
    end_length_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
  }

  bracket::
  bracket (const bracket& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_end_ (x.line_end_, f, this),
    end_length_ (x.end_length_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  bracket::
  bracket (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_end_ (this),
    end_length_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void bracket::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-end" && n.namespace_ ().empty ())
      {
        this->line_end_.set (line_end_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end-length" && n.namespace_ ().empty ())
      {
        this->end_length_.set (end_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!line_end_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "line-end",
        "");
    }
  }

  bracket* bracket::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bracket (*this, f, c);
  }

  bracket& bracket::
  operator= (const bracket& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_end_ = x.line_end_;
      this->end_length_ = x.end_length_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  bracket::
  ~bracket ()
  {
  }

  // dashes
  //

  dashes::
  dashes (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
  }

  dashes::
  dashes (const dashes& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  dashes::
  dashes (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void dashes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  dashes* dashes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dashes (*this, f, c);
  }

  dashes& dashes::
  operator= (const dashes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  dashes::
  ~dashes ()
  {
  }

  // degree
  //

  degree::
  degree (const degree_value_type& degree_value,
          const degree_alter_type& degree_alter,
          const degree_type_type& degree_type)
  : ::xml_schema::type (),
    degree_value_ (degree_value, this),
    degree_alter_ (degree_alter, this),
    degree_type_ (degree_type, this),
    print_object_ (this)
  {
  }

  degree::
  degree (::std::unique_ptr< degree_value_type > degree_value,
          ::std::unique_ptr< degree_alter_type > degree_alter,
          ::std::unique_ptr< degree_type_type > degree_type)
  : ::xml_schema::type (),
    degree_value_ (std::move (degree_value), this),
    degree_alter_ (std::move (degree_alter), this),
    degree_type_ (std::move (degree_type), this),
    print_object_ (this)
  {
  }

  degree::
  degree (const degree& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    degree_value_ (x.degree_value_, f, this),
    degree_alter_ (x.degree_alter_, f, this),
    degree_type_ (x.degree_type_, f, this),
    print_object_ (x.print_object_, f, this)
  {
  }

  degree::
  degree (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    degree_value_ (this),
    degree_alter_ (this),
    degree_type_ (this),
    print_object_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void degree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // degree-value
      //
      if (n.name () == "degree-value" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< degree_value_type > r (
          degree_value_traits::create (i, f, this));

        if (!degree_value_.present ())
        {
          this->degree_value_.set (::std::move (r));
          continue;
        }
      }

      // degree-alter
      //
      if (n.name () == "degree-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< degree_alter_type > r (
          degree_alter_traits::create (i, f, this));

        if (!degree_alter_.present ())
        {
          this->degree_alter_.set (::std::move (r));
          continue;
        }
      }

      // degree-type
      //
      if (n.name () == "degree-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< degree_type_type > r (
          degree_type_traits::create (i, f, this));

        if (!degree_type_.present ())
        {
          this->degree_type_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!degree_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "degree-value",
        "");
    }

    if (!degree_alter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "degree-alter",
        "");
    }

    if (!degree_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "degree-type",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }
    }
  }

  degree* degree::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree (*this, f, c);
  }

  degree& degree::
  operator= (const degree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->degree_value_ = x.degree_value_;
      this->degree_alter_ = x.degree_alter_;
      this->degree_type_ = x.degree_type_;
      this->print_object_ = x.print_object_;
    }

    return *this;
  }

  degree::
  ~degree ()
  {
  }

  // degree_alter
  //

  degree_alter::
  degree_alter (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::musicxml::semitones (_xsd_decimal_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    plus_minus_ (this)
  {
  }

  degree_alter::
  degree_alter (const degree_alter& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::semitones (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    plus_minus_ (x.plus_minus_, f, this)
  {
  }

  degree_alter::
  degree_alter (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::semitones (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    plus_minus_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void degree_alter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "plus-minus" && n.namespace_ ().empty ())
      {
        this->plus_minus_.set (plus_minus_traits::create (i, f, this));
        continue;
      }
    }
  }

  degree_alter* degree_alter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree_alter (*this, f, c);
  }

  degree_alter& degree_alter::
  operator= (const degree_alter& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::semitones& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->plus_minus_ = x.plus_minus_;
    }

    return *this;
  }

  degree_alter::
  ~degree_alter ()
  {
  }

  // degree_type
  //

  degree_type::
  degree_type (::musicxml::degree_type_value::value _xsd_degree_type_value_base)
  : ::musicxml::degree_type_value (_xsd_degree_type_value_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  degree_type::
  degree_type (const char* _xsd_string_base)
  : ::musicxml::degree_type_value (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  degree_type::
  degree_type (const ::std::string& _xsd_string_base)
  : ::musicxml::degree_type_value (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  degree_type::
  degree_type (const ::musicxml::degree_type_value& _xsd_degree_type_value_base)
  : ::musicxml::degree_type_value (_xsd_degree_type_value_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  degree_type::
  degree_type (const degree_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::degree_type_value (x, f, c),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  degree_type::
  degree_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::degree_type_value (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void degree_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  degree_type* degree_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree_type (*this, f, c);
  }

  degree_type& degree_type::
  operator= (const degree_type& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::degree_type_value& > (*this) = x;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  degree_type::
  ~degree_type ()
  {
  }

  // degree_value
  //

  degree_value::
  degree_value (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
    symbol_ (this),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  degree_value::
  degree_value (const degree_value& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
    symbol_ (x.symbol_, f, this),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  degree_value::
  degree_value (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    symbol_ (this),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void degree_value::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  degree_value* degree_value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class degree_value (*this, f, c);
  }

  degree_value& degree_value::
  operator= (const degree_value& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->symbol_ = x.symbol_;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  degree_value::
  ~degree_value ()
  {
  }

  // direction
  //

  direction::
  direction ()
  : ::xml_schema::type (),
    direction_type_ (this),
    offset_ (this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    staff_ (this),
    sound_ (this),
    listening_ (this),
    placement_ (this),
    directive_ (this),
    system_ (this),
    id_ (this)
  {
  }

  direction::
  direction (const direction& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    direction_type_ (x.direction_type_, f, this),
    offset_ (x.offset_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    voice_ (x.voice_, f, this),
    staff_ (x.staff_, f, this),
    sound_ (x.sound_, f, this),
    listening_ (x.listening_, f, this),
    placement_ (x.placement_, f, this),
    directive_ (x.directive_, f, this),
    system_ (x.system_, f, this),
    id_ (x.id_, f, this)
  {
  }

  direction::
  direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    direction_type_ (this),
    offset_ (this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    staff_ (this),
    sound_ (this),
    listening_ (this),
    placement_ (this),
    directive_ (this),
    system_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void direction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // direction-type
      //
      if (n.name () == "direction-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< direction_type_type > r (
          direction_type_traits::create (i, f, this));

        this->direction_type_.push_back (::std::move (r));
        continue;
      }

      // offset
      //
      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< offset_type > r (
          offset_traits::create (i, f, this));

        if (!this->offset_)
        {
          this->offset_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // voice
      //
      if (n.name () == "voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< voice_type > r (
          voice_traits::create (i, f, this));

        if (!this->voice_)
        {
          this->voice_.set (::std::move (r));
          continue;
        }
      }

      // staff
      //
      if (n.name () == "staff" && n.namespace_ ().empty ())
      {
        if (!this->staff_)
        {
          this->staff_.set (staff_traits::create (i, f, this));
          continue;
        }
      }

      // sound
      //
      if (n.name () == "sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sound_type > r (
          sound_traits::create (i, f, this));

        if (!this->sound_)
        {
          this->sound_.set (::std::move (r));
          continue;
        }
      }

      // listening
      //
      if (n.name () == "listening" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< listening_type > r (
          listening_traits::create (i, f, this));

        if (!this->listening_)
        {
          this->listening_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "directive" && n.namespace_ ().empty ())
      {
        this->directive_.set (directive_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        this->system_.set (system_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  direction* direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class direction (*this, f, c);
  }

  direction& direction::
  operator= (const direction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->direction_type_ = x.direction_type_;
      this->offset_ = x.offset_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->voice_ = x.voice_;
      this->staff_ = x.staff_;
      this->sound_ = x.sound_;
      this->listening_ = x.listening_;
      this->placement_ = x.placement_;
      this->directive_ = x.directive_;
      this->system_ = x.system_;
      this->id_ = x.id_;
    }

    return *this;
  }

  direction::
  ~direction ()
  {
  }

  // direction_type
  //

  direction_type::
  direction_type ()
  : ::xml_schema::type (),
    rehearsal_ (this),
    segno_ (this),
    coda_ (this),
    words_ (this),
    symbol_ (this),
    wedge_ (this),
    dynamics_ (this),
    dashes_ (this),
    bracket_ (this),
    pedal_ (this),
    metronome_ (this),
    octave_shift_ (this),
    harp_pedals_ (this),
    damp_ (this),
    damp_all_ (this),
    eyeglasses_ (this),
    string_mute_ (this),
    scordatura_ (this),
    image_ (this),
    principal_voice_ (this),
    percussion_ (this),
    accordion_registration_ (this),
    staff_divide_ (this),
    other_direction_ (this),
    id_ (this)
  {
  }

  direction_type::
  direction_type (const direction_type& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    rehearsal_ (x.rehearsal_, f, this),
    segno_ (x.segno_, f, this),
    coda_ (x.coda_, f, this),
    words_ (x.words_, f, this),
    symbol_ (x.symbol_, f, this),
    wedge_ (x.wedge_, f, this),
    dynamics_ (x.dynamics_, f, this),
    dashes_ (x.dashes_, f, this),
    bracket_ (x.bracket_, f, this),
    pedal_ (x.pedal_, f, this),
    metronome_ (x.metronome_, f, this),
    octave_shift_ (x.octave_shift_, f, this),
    harp_pedals_ (x.harp_pedals_, f, this),
    damp_ (x.damp_, f, this),
    damp_all_ (x.damp_all_, f, this),
    eyeglasses_ (x.eyeglasses_, f, this),
    string_mute_ (x.string_mute_, f, this),
    scordatura_ (x.scordatura_, f, this),
    image_ (x.image_, f, this),
    principal_voice_ (x.principal_voice_, f, this),
    percussion_ (x.percussion_, f, this),
    accordion_registration_ (x.accordion_registration_, f, this),
    staff_divide_ (x.staff_divide_, f, this),
    other_direction_ (x.other_direction_, f, this),
    id_ (x.id_, f, this)
  {
  }

  direction_type::
  direction_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    rehearsal_ (this),
    segno_ (this),
    coda_ (this),
    words_ (this),
    symbol_ (this),
    wedge_ (this),
    dynamics_ (this),
    dashes_ (this),
    bracket_ (this),
    pedal_ (this),
    metronome_ (this),
    octave_shift_ (this),
    harp_pedals_ (this),
    damp_ (this),
    damp_all_ (this),
    eyeglasses_ (this),
    string_mute_ (this),
    scordatura_ (this),
    image_ (this),
    principal_voice_ (this),
    percussion_ (this),
    accordion_registration_ (this),
    staff_divide_ (this),
    other_direction_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void direction_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rehearsal
      //
      if (n.name () == "rehearsal" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< rehearsal_type > r (
          rehearsal_traits::create (i, f, this));

        this->rehearsal_.push_back (::std::move (r));
        continue;
      }

      // segno
      //
      if (n.name () == "segno" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< segno_type > r (
          segno_traits::create (i, f, this));

        this->segno_.push_back (::std::move (r));
        continue;
      }

      // coda
      //
      if (n.name () == "coda" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< coda_type > r (
          coda_traits::create (i, f, this));

        this->coda_.push_back (::std::move (r));
        continue;
      }

      // words
      //
      if (n.name () == "words" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< words_type > r (
          words_traits::create (i, f, this));

        this->words_.push_back (::std::move (r));
        continue;
      }

      // symbol
      //
      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< symbol_type > r (
          symbol_traits::create (i, f, this));

        this->symbol_.push_back (::std::move (r));
        continue;
      }

      // wedge
      //
      if (n.name () == "wedge" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< wedge_type > r (
          wedge_traits::create (i, f, this));

        if (!this->wedge_)
        {
          this->wedge_.set (::std::move (r));
          continue;
        }
      }

      // dynamics
      //
      if (n.name () == "dynamics" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< dynamics_type > r (
          dynamics_traits::create (i, f, this));

        this->dynamics_.push_back (::std::move (r));
        continue;
      }

      // dashes
      //
      if (n.name () == "dashes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< dashes_type > r (
          dashes_traits::create (i, f, this));

        if (!this->dashes_)
        {
          this->dashes_.set (::std::move (r));
          continue;
        }
      }

      // bracket
      //
      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bracket_type > r (
          bracket_traits::create (i, f, this));

        if (!this->bracket_)
        {
          this->bracket_.set (::std::move (r));
          continue;
        }
      }

      // pedal
      //
      if (n.name () == "pedal" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pedal_type > r (
          pedal_traits::create (i, f, this));

        if (!this->pedal_)
        {
          this->pedal_.set (::std::move (r));
          continue;
        }
      }

      // metronome
      //
      if (n.name () == "metronome" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_type > r (
          metronome_traits::create (i, f, this));

        if (!this->metronome_)
        {
          this->metronome_.set (::std::move (r));
          continue;
        }
      }

      // octave-shift
      //
      if (n.name () == "octave-shift" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< octave_shift_type > r (
          octave_shift_traits::create (i, f, this));

        if (!this->octave_shift_)
        {
          this->octave_shift_.set (::std::move (r));
          continue;
        }
      }

      // harp-pedals
      //
      if (n.name () == "harp-pedals" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harp_pedals_type > r (
          harp_pedals_traits::create (i, f, this));

        if (!this->harp_pedals_)
        {
          this->harp_pedals_.set (::std::move (r));
          continue;
        }
      }

      // damp
      //
      if (n.name () == "damp" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< damp_type > r (
          damp_traits::create (i, f, this));

        if (!this->damp_)
        {
          this->damp_.set (::std::move (r));
          continue;
        }
      }

      // damp-all
      //
      if (n.name () == "damp-all" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< damp_all_type > r (
          damp_all_traits::create (i, f, this));

        if (!this->damp_all_)
        {
          this->damp_all_.set (::std::move (r));
          continue;
        }
      }

      // eyeglasses
      //
      if (n.name () == "eyeglasses" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< eyeglasses_type > r (
          eyeglasses_traits::create (i, f, this));

        if (!this->eyeglasses_)
        {
          this->eyeglasses_.set (::std::move (r));
          continue;
        }
      }

      // string-mute
      //
      if (n.name () == "string-mute" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< string_mute_type > r (
          string_mute_traits::create (i, f, this));

        if (!this->string_mute_)
        {
          this->string_mute_.set (::std::move (r));
          continue;
        }
      }

      // scordatura
      //
      if (n.name () == "scordatura" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< scordatura_type > r (
          scordatura_traits::create (i, f, this));

        if (!this->scordatura_)
        {
          this->scordatura_.set (::std::move (r));
          continue;
        }
      }

      // image
      //
      if (n.name () == "image" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< image_type > r (
          image_traits::create (i, f, this));

        if (!this->image_)
        {
          this->image_.set (::std::move (r));
          continue;
        }
      }

      // principal-voice
      //
      if (n.name () == "principal-voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< principal_voice_type > r (
          principal_voice_traits::create (i, f, this));

        if (!this->principal_voice_)
        {
          this->principal_voice_.set (::std::move (r));
          continue;
        }
      }

      // percussion
      //
      if (n.name () == "percussion" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< percussion_type > r (
          percussion_traits::create (i, f, this));

        this->percussion_.push_back (::std::move (r));
        continue;
      }

      // accordion-registration
      //
      if (n.name () == "accordion-registration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accordion_registration_type > r (
          accordion_registration_traits::create (i, f, this));

        if (!this->accordion_registration_)
        {
          this->accordion_registration_.set (::std::move (r));
          continue;
        }
      }

      // staff-divide
      //
      if (n.name () == "staff-divide" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_divide_type > r (
          staff_divide_traits::create (i, f, this));

        if (!this->staff_divide_)
        {
          this->staff_divide_.set (::std::move (r));
          continue;
        }
      }

      // other-direction
      //
      if (n.name () == "other-direction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_direction_type > r (
          other_direction_traits::create (i, f, this));

        if (!this->other_direction_)
        {
          this->other_direction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  direction_type* direction_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class direction_type (*this, f, c);
  }

  direction_type& direction_type::
  operator= (const direction_type& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->rehearsal_ = x.rehearsal_;
      this->segno_ = x.segno_;
      this->coda_ = x.coda_;
      this->words_ = x.words_;
      this->symbol_ = x.symbol_;
      this->wedge_ = x.wedge_;
      this->dynamics_ = x.dynamics_;
      this->dashes_ = x.dashes_;
      this->bracket_ = x.bracket_;
      this->pedal_ = x.pedal_;
      this->metronome_ = x.metronome_;
      this->octave_shift_ = x.octave_shift_;
      this->harp_pedals_ = x.harp_pedals_;
      this->damp_ = x.damp_;
      this->damp_all_ = x.damp_all_;
      this->eyeglasses_ = x.eyeglasses_;
      this->string_mute_ = x.string_mute_;
      this->scordatura_ = x.scordatura_;
      this->image_ = x.image_;
      this->principal_voice_ = x.principal_voice_;
      this->percussion_ = x.percussion_;
      this->accordion_registration_ = x.accordion_registration_;
      this->staff_divide_ = x.staff_divide_;
      this->other_direction_ = x.other_direction_;
      this->id_ = x.id_;
    }

    return *this;
  }

  direction_type::
  ~direction_type ()
  {
  }

  // effect
  //

  effect::
  effect (::musicxml::effect_value::value _xsd_effect_value_base)
  : ::musicxml::effect_value (_xsd_effect_value_base),
    smufl_ (this)
  {
  }

  effect::
  effect (const char* _xsd_string_base)
  : ::musicxml::effect_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  effect::
  effect (const ::std::string& _xsd_string_base)
  : ::musicxml::effect_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  effect::
  effect (const ::musicxml::effect_value& _xsd_effect_value_base)
  : ::musicxml::effect_value (_xsd_effect_value_base),
    smufl_ (this)
  {
  }

  effect::
  effect (const effect& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::effect_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  effect::
  effect (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::effect_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void effect::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  effect* effect::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class effect (*this, f, c);
  }

  effect& effect::
  operator= (const effect& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::effect_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  effect::
  ~effect ()
  {
  }

  // feature
  //

  feature::
  feature ()
  : ::xml_schema::string (),
    type_ (this)
  {
  }

  feature::
  feature (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  feature::
  feature (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  feature::
  feature (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    type_ (this)
  {
  }

  feature::
  feature (const feature& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  feature::
  feature (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void feature::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  feature* feature::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class feature (*this, f, c);
  }

  feature& feature::
  operator= (const feature& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  feature::
  ~feature ()
  {
  }

  // first_fret
  //

  first_fret::
  first_fret (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base),
    text_ (this),
    location_ (this)
  {
  }

  first_fret::
  first_fret (const first_fret& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c),
    text_ (x.text_, f, this),
    location_ (x.location_, f, this)
  {
  }

  first_fret::
  first_fret (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void first_fret::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }
  }

  first_fret* first_fret::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class first_fret (*this, f, c);
  }

  first_fret& first_fret::
  operator= (const first_fret& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->text_ = x.text_;
      this->location_ = x.location_;
    }

    return *this;
  }

  first_fret::
  ~first_fret ()
  {
  }

  // frame
  //

  frame::
  frame (const frame_strings_type& frame_strings,
         const frame_frets_type& frame_frets)
  : ::xml_schema::type (),
    frame_strings_ (frame_strings, this),
    frame_frets_ (frame_frets, this),
    first_fret_ (this),
    frame_note_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    height_ (this),
    width_ (this),
    unplayed_ (this),
    id_ (this)
  {
  }

  frame::
  frame (const frame& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    frame_strings_ (x.frame_strings_, f, this),
    frame_frets_ (x.frame_frets_, f, this),
    first_fret_ (x.first_fret_, f, this),
    frame_note_ (x.frame_note_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    height_ (x.height_, f, this),
    width_ (x.width_, f, this),
    unplayed_ (x.unplayed_, f, this),
    id_ (x.id_, f, this)
  {
  }

  frame::
  frame (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    frame_strings_ (this),
    frame_frets_ (this),
    first_fret_ (this),
    frame_note_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    height_ (this),
    width_ (this),
    unplayed_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void frame::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // frame-strings
      //
      if (n.name () == "frame-strings" && n.namespace_ ().empty ())
      {
        if (!frame_strings_.present ())
        {
          this->frame_strings_.set (frame_strings_traits::create (i, f, this));
          continue;
        }
      }

      // frame-frets
      //
      if (n.name () == "frame-frets" && n.namespace_ ().empty ())
      {
        if (!frame_frets_.present ())
        {
          this->frame_frets_.set (frame_frets_traits::create (i, f, this));
          continue;
        }
      }

      // first-fret
      //
      if (n.name () == "first-fret" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< first_fret_type > r (
          first_fret_traits::create (i, f, this));

        if (!this->first_fret_)
        {
          this->first_fret_.set (::std::move (r));
          continue;
        }
      }

      // frame-note
      //
      if (n.name () == "frame-note" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< frame_note_type > r (
          frame_note_traits::create (i, f, this));

        this->frame_note_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!frame_strings_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "frame-strings",
        "");
    }

    if (!frame_frets_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "frame-frets",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "height" && n.namespace_ ().empty ())
      {
        this->height_.set (height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unplayed" && n.namespace_ ().empty ())
      {
        this->unplayed_.set (unplayed_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  frame* frame::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class frame (*this, f, c);
  }

  frame& frame::
  operator= (const frame& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->frame_strings_ = x.frame_strings_;
      this->frame_frets_ = x.frame_frets_;
      this->first_fret_ = x.first_fret_;
      this->frame_note_ = x.frame_note_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->height_ = x.height_;
      this->width_ = x.width_;
      this->unplayed_ = x.unplayed_;
      this->id_ = x.id_;
    }

    return *this;
  }

  frame::
  ~frame ()
  {
  }

  // frame_note
  //

  frame_note::
  frame_note (const string_type& string,
              const fret_type& fret)
  : ::xml_schema::type (),
    string_ (string, this),
    fret_ (fret, this),
    fingering_ (this),
    barre_ (this)
  {
  }

  frame_note::
  frame_note (::std::unique_ptr< string_type > string,
              ::std::unique_ptr< fret_type > fret)
  : ::xml_schema::type (),
    string_ (std::move (string), this),
    fret_ (std::move (fret), this),
    fingering_ (this),
    barre_ (this)
  {
  }

  frame_note::
  frame_note (const frame_note& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    string_ (x.string_, f, this),
    fret_ (x.fret_, f, this),
    fingering_ (x.fingering_, f, this),
    barre_ (x.barre_, f, this)
  {
  }

  frame_note::
  frame_note (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    string_ (this),
    fret_ (this),
    fingering_ (this),
    barre_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void frame_note::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // string
      //
      if (n.name () == "string" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< string_type > r (
          string_traits::create (i, f, this));

        if (!string_.present ())
        {
          this->string_.set (::std::move (r));
          continue;
        }
      }

      // fret
      //
      if (n.name () == "fret" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fret_type > r (
          fret_traits::create (i, f, this));

        if (!fret_.present ())
        {
          this->fret_.set (::std::move (r));
          continue;
        }
      }

      // fingering
      //
      if (n.name () == "fingering" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fingering_type > r (
          fingering_traits::create (i, f, this));

        if (!this->fingering_)
        {
          this->fingering_.set (::std::move (r));
          continue;
        }
      }

      // barre
      //
      if (n.name () == "barre" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< barre_type > r (
          barre_traits::create (i, f, this));

        if (!this->barre_)
        {
          this->barre_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!string_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "string",
        "");
    }

    if (!fret_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "fret",
        "");
    }
  }

  frame_note* frame_note::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class frame_note (*this, f, c);
  }

  frame_note& frame_note::
  operator= (const frame_note& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->string_ = x.string_;
      this->fret_ = x.fret_;
      this->fingering_ = x.fingering_;
      this->barre_ = x.barre_;
    }

    return *this;
  }

  frame_note::
  ~frame_note ()
  {
  }

  // glass
  //

  glass::
  glass (::musicxml::glass_value::value _xsd_glass_value_base)
  : ::musicxml::glass_value (_xsd_glass_value_base),
    smufl_ (this)
  {
  }

  glass::
  glass (const char* _xsd_string_base)
  : ::musicxml::glass_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  glass::
  glass (const ::std::string& _xsd_string_base)
  : ::musicxml::glass_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  glass::
  glass (const ::musicxml::glass_value& _xsd_glass_value_base)
  : ::musicxml::glass_value (_xsd_glass_value_base),
    smufl_ (this)
  {
  }

  glass::
  glass (const glass& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::glass_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  glass::
  glass (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::glass_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void glass::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  glass* glass::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class glass (*this, f, c);
  }

  glass& glass::
  operator= (const glass& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::glass_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  glass::
  ~glass ()
  {
  }

  // grouping
  //

  const grouping::number_type grouping::number_default_value_ (
    "1");

  grouping::
  grouping (const type_type& type)
  : ::xml_schema::type (),
    feature_ (this),
    type_ (type, this),
    number_ (number_default_value (), this),
    member_of_ (this),
    id_ (this)
  {
  }

  grouping::
  grouping (const grouping& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    feature_ (x.feature_, f, this),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    member_of_ (x.member_of_, f, this),
    id_ (x.id_, f, this)
  {
  }

  grouping::
  grouping (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    feature_ (this),
    type_ (this),
    number_ (this),
    member_of_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void grouping::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // feature
      //
      if (n.name () == "feature" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< feature_type > r (
          feature_traits::create (i, f, this));

        this->feature_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "member-of" && n.namespace_ ().empty ())
      {
        this->member_of_.set (member_of_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  grouping* grouping::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class grouping (*this, f, c);
  }

  grouping& grouping::
  operator= (const grouping& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->feature_ = x.feature_;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->member_of_ = x.member_of_;
      this->id_ = x.id_;
    }

    return *this;
  }

  grouping::
  ~grouping ()
  {
  }

  // harmony
  //

  harmony::
  harmony ()
  : ::xml_schema::type (),
    root_ (this),
    numeral_ (this),
    function_ (this),
    kind_ (this),
    inversion_ (this),
    bass_ (this),
    degree_ (this),
    frame_ (this),
    offset_ (this),
    footnote_ (this),
    level_ (this),
    staff_ (this),
    type_ (this),
    print_object_ (this),
    print_frame_ (this),
    arrangement_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    system_ (this),
    id_ (this)
  {
  }

  harmony::
  harmony (const harmony& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    root_ (x.root_, f, this),
    numeral_ (x.numeral_, f, this),
    function_ (x.function_, f, this),
    kind_ (x.kind_, f, this),
    inversion_ (x.inversion_, f, this),
    bass_ (x.bass_, f, this),
    degree_ (x.degree_, f, this),
    frame_ (x.frame_, f, this),
    offset_ (x.offset_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    staff_ (x.staff_, f, this),
    type_ (x.type_, f, this),
    print_object_ (x.print_object_, f, this),
    print_frame_ (x.print_frame_, f, this),
    arrangement_ (x.arrangement_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    system_ (x.system_, f, this),
    id_ (x.id_, f, this)
  {
  }

  harmony::
  harmony (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    root_ (this),
    numeral_ (this),
    function_ (this),
    kind_ (this),
    inversion_ (this),
    bass_ (this),
    degree_ (this),
    frame_ (this),
    offset_ (this),
    footnote_ (this),
    level_ (this),
    staff_ (this),
    type_ (this),
    print_object_ (this),
    print_frame_ (this),
    arrangement_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    system_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void harmony::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // root
      //
      if (n.name () == "root" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< root_type > r (
          root_traits::create (i, f, this));

        this->root_.push_back (::std::move (r));
        continue;
      }

      // numeral
      //
      if (n.name () == "numeral" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_type > r (
          numeral_traits::create (i, f, this));

        this->numeral_.push_back (::std::move (r));
        continue;
      }

      // function
      //
      if (n.name () == "function" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< function_type > r (
          function_traits::create (i, f, this));

        this->function_.push_back (::std::move (r));
        continue;
      }

      // kind
      //
      if (n.name () == "kind" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< kind_type > r (
          kind_traits::create (i, f, this));

        this->kind_.push_back (::std::move (r));
        continue;
      }

      // inversion
      //
      if (n.name () == "inversion" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< inversion_type > r (
          inversion_traits::create (i, f, this));

        this->inversion_.push_back (::std::move (r));
        continue;
      }

      // bass
      //
      if (n.name () == "bass" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bass_type > r (
          bass_traits::create (i, f, this));

        this->bass_.push_back (::std::move (r));
        continue;
      }

      // degree
      //
      if (n.name () == "degree" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< degree_type > r (
          degree_traits::create (i, f, this));

        this->degree_.push_back (::std::move (r));
        continue;
      }

      // frame
      //
      if (n.name () == "frame" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< frame_type > r (
          frame_traits::create (i, f, this));

        if (!this->frame_)
        {
          this->frame_.set (::std::move (r));
          continue;
        }
      }

      // offset
      //
      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< offset_type > r (
          offset_traits::create (i, f, this));

        if (!this->offset_)
        {
          this->offset_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // staff
      //
      if (n.name () == "staff" && n.namespace_ ().empty ())
      {
        if (!this->staff_)
        {
          this->staff_.set (staff_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-frame" && n.namespace_ ().empty ())
      {
        this->print_frame_.set (print_frame_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "arrangement" && n.namespace_ ().empty ())
      {
        this->arrangement_.set (arrangement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        this->system_.set (system_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  harmony* harmony::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmony (*this, f, c);
  }

  harmony& harmony::
  operator= (const harmony& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->root_ = x.root_;
      this->numeral_ = x.numeral_;
      this->function_ = x.function_;
      this->kind_ = x.kind_;
      this->inversion_ = x.inversion_;
      this->bass_ = x.bass_;
      this->degree_ = x.degree_;
      this->frame_ = x.frame_;
      this->offset_ = x.offset_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->staff_ = x.staff_;
      this->type_ = x.type_;
      this->print_object_ = x.print_object_;
      this->print_frame_ = x.print_frame_;
      this->arrangement_ = x.arrangement_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->system_ = x.system_;
      this->id_ = x.id_;
    }

    return *this;
  }

  harmony::
  ~harmony ()
  {
  }

  // harp_pedals
  //

  harp_pedals::
  harp_pedals ()
  : ::xml_schema::type (),
    pedal_tuning_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  harp_pedals::
  harp_pedals (const harp_pedals& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    pedal_tuning_ (x.pedal_tuning_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  harp_pedals::
  harp_pedals (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    pedal_tuning_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void harp_pedals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pedal-tuning
      //
      if (n.name () == "pedal-tuning" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pedal_tuning_type > r (
          pedal_tuning_traits::create (i, f, this));

        this->pedal_tuning_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  harp_pedals* harp_pedals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harp_pedals (*this, f, c);
  }

  harp_pedals& harp_pedals::
  operator= (const harp_pedals& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->pedal_tuning_ = x.pedal_tuning_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  harp_pedals::
  ~harp_pedals ()
  {
  }

  // image
  //

  image::
  image (const source_type& source,
         const type_type& type)
  : ::xml_schema::type (),
    source_ (source, this),
    type_ (type, this),
    height_ (this),
    width_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  image::
  image (const image& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    source_ (x.source_, f, this),
    type_ (x.type_, f, this),
    height_ (x.height_, f, this),
    width_ (x.width_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  image::
  image (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    source_ (this),
    type_ (this),
    height_ (this),
    width_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void image::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        this->source_.set (source_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "height" && n.namespace_ ().empty ())
      {
        this->height_.set (height_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!source_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "source",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  image* image::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class image (*this, f, c);
  }

  image& image::
  operator= (const image& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->source_ = x.source_;
      this->type_ = x.type_;
      this->height_ = x.height_;
      this->width_ = x.width_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  image::
  ~image ()
  {
  }

  // instrument_change
  //

  instrument_change::
  instrument_change (const id_type& id)
  : ::xml_schema::type (),
    instrument_sound_ (this),
    solo_ (this),
    ensemble_ (this),
    virtual_instrument_ (this),
    id_ (id, this)
  {
  }

  instrument_change::
  instrument_change (const instrument_change& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    instrument_sound_ (x.instrument_sound_, f, this),
    solo_ (x.solo_, f, this),
    ensemble_ (x.ensemble_, f, this),
    virtual_instrument_ (x.virtual_instrument_, f, this),
    id_ (x.id_, f, this)
  {
  }

  instrument_change::
  instrument_change (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    instrument_sound_ (this),
    solo_ (this),
    ensemble_ (this),
    virtual_instrument_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void instrument_change::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instrument-sound
      //
      if (n.name () == "instrument-sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_sound_type > r (
          instrument_sound_traits::create (i, f, this));

        if (!this->instrument_sound_)
        {
          this->instrument_sound_.set (::std::move (r));
          continue;
        }
      }

      // solo
      //
      if (n.name () == "solo" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< solo_type > r (
          solo_traits::create (i, f, this));

        if (!this->solo_)
        {
          this->solo_.set (::std::move (r));
          continue;
        }
      }

      // ensemble
      //
      if (n.name () == "ensemble" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ensemble_type > r (
          ensemble_traits::create (i, f, this));

        if (!this->ensemble_)
        {
          this->ensemble_.set (::std::move (r));
          continue;
        }
      }

      // virtual-instrument
      //
      if (n.name () == "virtual-instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< virtual_instrument_type > r (
          virtual_instrument_traits::create (i, f, this));

        if (!this->virtual_instrument_)
        {
          this->virtual_instrument_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  instrument_change* instrument_change::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class instrument_change (*this, f, c);
  }

  instrument_change& instrument_change::
  operator= (const instrument_change& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->instrument_sound_ = x.instrument_sound_;
      this->solo_ = x.solo_;
      this->ensemble_ = x.ensemble_;
      this->virtual_instrument_ = x.virtual_instrument_;
      this->id_ = x.id_;
    }

    return *this;
  }

  instrument_change::
  ~instrument_change ()
  {
  }

  // inversion
  //

  inversion::
  inversion (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  inversion::
  inversion (const inversion& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  inversion::
  inversion (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void inversion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  inversion* inversion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inversion (*this, f, c);
  }

  inversion& inversion::
  operator= (const inversion& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  inversion::
  ~inversion ()
  {
  }

  // kind
  //

  kind::
  kind (::musicxml::kind_value::value _xsd_kind_value_base)
  : ::musicxml::kind_value (_xsd_kind_value_base),
    use_symbols_ (this),
    text_ (this),
    stack_degrees_ (this),
    parentheses_degrees_ (this),
    bracket_degrees_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  kind::
  kind (const char* _xsd_string_base)
  : ::musicxml::kind_value (_xsd_string_base),
    use_symbols_ (this),
    text_ (this),
    stack_degrees_ (this),
    parentheses_degrees_ (this),
    bracket_degrees_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  kind::
  kind (const ::std::string& _xsd_string_base)
  : ::musicxml::kind_value (_xsd_string_base),
    use_symbols_ (this),
    text_ (this),
    stack_degrees_ (this),
    parentheses_degrees_ (this),
    bracket_degrees_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  kind::
  kind (const ::musicxml::kind_value& _xsd_kind_value_base)
  : ::musicxml::kind_value (_xsd_kind_value_base),
    use_symbols_ (this),
    text_ (this),
    stack_degrees_ (this),
    parentheses_degrees_ (this),
    bracket_degrees_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  kind::
  kind (const kind& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::kind_value (x, f, c),
    use_symbols_ (x.use_symbols_, f, this),
    text_ (x.text_, f, this),
    stack_degrees_ (x.stack_degrees_, f, this),
    parentheses_degrees_ (x.parentheses_degrees_, f, this),
    bracket_degrees_ (x.bracket_degrees_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this)
  {
  }

  kind::
  kind (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::kind_value (e, f | ::xml_schema::flags::base, c),
    use_symbols_ (this),
    text_ (this),
    stack_degrees_ (this),
    parentheses_degrees_ (this),
    bracket_degrees_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void kind::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "use-symbols" && n.namespace_ ().empty ())
      {
        this->use_symbols_.set (use_symbols_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "stack-degrees" && n.namespace_ ().empty ())
      {
        this->stack_degrees_.set (stack_degrees_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses-degrees" && n.namespace_ ().empty ())
      {
        this->parentheses_degrees_.set (parentheses_degrees_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket-degrees" && n.namespace_ ().empty ())
      {
        this->bracket_degrees_.set (bracket_degrees_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }
    }
  }

  kind* kind::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class kind (*this, f, c);
  }

  kind& kind::
  operator= (const kind& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::kind_value& > (*this) = x;
      this->use_symbols_ = x.use_symbols_;
      this->text_ = x.text_;
      this->stack_degrees_ = x.stack_degrees_;
      this->parentheses_degrees_ = x.parentheses_degrees_;
      this->bracket_degrees_ = x.bracket_degrees_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
    }

    return *this;
  }

  kind::
  ~kind ()
  {
  }

  // listening
  //

  listening::
  listening ()
  : ::xml_schema::type (),
    sync_ (this),
    other_listening_ (this),
    offset_ (this)
  {
  }

  listening::
  listening (const listening& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    sync_ (x.sync_, f, this),
    other_listening_ (x.other_listening_, f, this),
    offset_ (x.offset_, f, this)
  {
  }

  listening::
  listening (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    sync_ (this),
    other_listening_ (this),
    offset_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void listening::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // sync
      //
      if (n.name () == "sync" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sync_type > r (
          sync_traits::create (i, f, this));

        this->sync_.push_back (::std::move (r));
        continue;
      }

      // other-listening
      //
      if (n.name () == "other-listening" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_listening_type > r (
          other_listening_traits::create (i, f, this));

        this->other_listening_.push_back (::std::move (r));
        continue;
      }

      // offset
      //
      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< offset_type > r (
          offset_traits::create (i, f, this));

        if (!this->offset_)
        {
          this->offset_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  listening* listening::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listening (*this, f, c);
  }

  listening& listening::
  operator= (const listening& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->sync_ = x.sync_;
      this->other_listening_ = x.other_listening_;
      this->offset_ = x.offset_;
    }

    return *this;
  }

  listening::
  ~listening ()
  {
  }

  // measure_numbering
  //

  measure_numbering::
  measure_numbering (::musicxml::measure_numbering_value::value _xsd_measure_numbering_value_base)
  : ::musicxml::measure_numbering_value (_xsd_measure_numbering_value_base),
    system_ (this),
    staff_ (this),
    multiple_rest_always_ (this),
    multiple_rest_range_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  measure_numbering::
  measure_numbering (const char* _xsd_token_base)
  : ::musicxml::measure_numbering_value (_xsd_token_base),
    system_ (this),
    staff_ (this),
    multiple_rest_always_ (this),
    multiple_rest_range_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  measure_numbering::
  measure_numbering (const ::std::string& _xsd_token_base)
  : ::musicxml::measure_numbering_value (_xsd_token_base),
    system_ (this),
    staff_ (this),
    multiple_rest_always_ (this),
    multiple_rest_range_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  measure_numbering::
  measure_numbering (const ::musicxml::measure_numbering_value& _xsd_measure_numbering_value_base)
  : ::musicxml::measure_numbering_value (_xsd_measure_numbering_value_base),
    system_ (this),
    staff_ (this),
    multiple_rest_always_ (this),
    multiple_rest_range_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
  }

  measure_numbering::
  measure_numbering (const measure_numbering& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::musicxml::measure_numbering_value (x, f, c),
    system_ (x.system_, f, this),
    staff_ (x.staff_, f, this),
    multiple_rest_always_ (x.multiple_rest_always_, f, this),
    multiple_rest_range_ (x.multiple_rest_range_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this)
  {
  }

  measure_numbering::
  measure_numbering (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::musicxml::measure_numbering_value (e, f | ::xml_schema::flags::base, c),
    system_ (this),
    staff_ (this),
    multiple_rest_always_ (this),
    multiple_rest_range_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void measure_numbering::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "system" && n.namespace_ ().empty ())
      {
        this->system_.set (system_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "staff" && n.namespace_ ().empty ())
      {
        this->staff_.set (staff_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "multiple-rest-always" && n.namespace_ ().empty ())
      {
        this->multiple_rest_always_.set (multiple_rest_always_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "multiple-rest-range" && n.namespace_ ().empty ())
      {
        this->multiple_rest_range_.set (multiple_rest_range_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }
    }
  }

  measure_numbering* measure_numbering::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_numbering (*this, f, c);
  }

  measure_numbering& measure_numbering::
  operator= (const measure_numbering& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::measure_numbering_value& > (*this) = x;
      this->system_ = x.system_;
      this->staff_ = x.staff_;
      this->multiple_rest_always_ = x.multiple_rest_always_;
      this->multiple_rest_range_ = x.multiple_rest_range_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
    }

    return *this;
  }

  measure_numbering::
  ~measure_numbering ()
  {
  }

  // membrane
  //

  membrane::
  membrane (::musicxml::membrane_value::value _xsd_membrane_value_base)
  : ::musicxml::membrane_value (_xsd_membrane_value_base),
    smufl_ (this)
  {
  }

  membrane::
  membrane (const char* _xsd_string_base)
  : ::musicxml::membrane_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  membrane::
  membrane (const ::std::string& _xsd_string_base)
  : ::musicxml::membrane_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  membrane::
  membrane (const ::musicxml::membrane_value& _xsd_membrane_value_base)
  : ::musicxml::membrane_value (_xsd_membrane_value_base),
    smufl_ (this)
  {
  }

  membrane::
  membrane (const membrane& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::membrane_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  membrane::
  membrane (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::membrane_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void membrane::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  membrane* membrane::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class membrane (*this, f, c);
  }

  membrane& membrane::
  operator= (const membrane& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::membrane_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  membrane::
  ~membrane ()
  {
  }

  // metal
  //

  metal::
  metal (::musicxml::metal_value::value _xsd_metal_value_base)
  : ::musicxml::metal_value (_xsd_metal_value_base),
    smufl_ (this)
  {
  }

  metal::
  metal (const char* _xsd_string_base)
  : ::musicxml::metal_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  metal::
  metal (const ::std::string& _xsd_string_base)
  : ::musicxml::metal_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  metal::
  metal (const ::musicxml::metal_value& _xsd_metal_value_base)
  : ::musicxml::metal_value (_xsd_metal_value_base),
    smufl_ (this)
  {
  }

  metal::
  metal (const metal& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::metal_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  metal::
  metal (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::metal_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void metal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  metal* metal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metal (*this, f, c);
  }

  metal& metal::
  operator= (const metal& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::metal_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  metal::
  ~metal ()
  {
  }

  // metronome
  //

  metronome::
  metronome ()
  : ::xml_schema::type (),
    beat_unit_ (this),
    beat_unit_dot_ (this),
    beat_unit_tied_ (this),
    per_minute_ (this),
    metronome_arrows_ (this),
    metronome_note_ (this),
    metronome_relation_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    print_object_ (this),
    justify_ (this),
    parentheses_ (this),
    id_ (this)
  {
  }

  metronome::
  metronome (const metronome& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    beat_unit_ (x.beat_unit_, f, this),
    beat_unit_dot_ (x.beat_unit_dot_, f, this),
    beat_unit_tied_ (x.beat_unit_tied_, f, this),
    per_minute_ (x.per_minute_, f, this),
    metronome_arrows_ (x.metronome_arrows_, f, this),
    metronome_note_ (x.metronome_note_, f, this),
    metronome_relation_ (x.metronome_relation_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    print_object_ (x.print_object_, f, this),
    justify_ (x.justify_, f, this),
    parentheses_ (x.parentheses_, f, this),
    id_ (x.id_, f, this)
  {
  }

  metronome::
  metronome (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    beat_unit_ (this),
    beat_unit_dot_ (this),
    beat_unit_tied_ (this),
    per_minute_ (this),
    metronome_arrows_ (this),
    metronome_note_ (this),
    metronome_relation_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    print_object_ (this),
    justify_ (this),
    parentheses_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void metronome::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // beat-unit
      //
      if (n.name () == "beat-unit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_unit_type > r (
          beat_unit_traits::create (i, f, this));

        this->beat_unit_.push_back (::std::move (r));
        continue;
      }

      // beat-unit-dot
      //
      if (n.name () == "beat-unit-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_unit_dot_type > r (
          beat_unit_dot_traits::create (i, f, this));

        this->beat_unit_dot_.push_back (::std::move (r));
        continue;
      }

      // beat-unit-tied
      //
      if (n.name () == "beat-unit-tied" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beat_unit_tied_type > r (
          beat_unit_tied_traits::create (i, f, this));

        this->beat_unit_tied_.push_back (::std::move (r));
        continue;
      }

      // per-minute
      //
      if (n.name () == "per-minute" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< per_minute_type > r (
          per_minute_traits::create (i, f, this));

        if (!this->per_minute_)
        {
          this->per_minute_.set (::std::move (r));
          continue;
        }
      }

      // metronome-arrows
      //
      if (n.name () == "metronome-arrows" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_arrows_type > r (
          metronome_arrows_traits::create (i, f, this));

        if (!this->metronome_arrows_)
        {
          this->metronome_arrows_.set (::std::move (r));
          continue;
        }
      }

      // metronome-note
      //
      if (n.name () == "metronome-note" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_note_type > r (
          metronome_note_traits::create (i, f, this));

        this->metronome_note_.push_back (::std::move (r));
        continue;
      }

      // metronome-relation
      //
      if (n.name () == "metronome-relation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_relation_type > r (
          metronome_relation_traits::create (i, f, this));

        if (!this->metronome_relation_)
        {
          this->metronome_relation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  metronome* metronome::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metronome (*this, f, c);
  }

  metronome& metronome::
  operator= (const metronome& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->beat_unit_ = x.beat_unit_;
      this->beat_unit_dot_ = x.beat_unit_dot_;
      this->beat_unit_tied_ = x.beat_unit_tied_;
      this->per_minute_ = x.per_minute_;
      this->metronome_arrows_ = x.metronome_arrows_;
      this->metronome_note_ = x.metronome_note_;
      this->metronome_relation_ = x.metronome_relation_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->print_object_ = x.print_object_;
      this->justify_ = x.justify_;
      this->parentheses_ = x.parentheses_;
      this->id_ = x.id_;
    }

    return *this;
  }

  metronome::
  ~metronome ()
  {
  }

  // metronome_beam
  //

  metronome_beam::
  metronome_beam (::musicxml::beam_value::value _xsd_beam_value_base)
  : ::musicxml::beam_value (_xsd_beam_value_base),
    number_ (number_default_value (), this)
  {
  }

  metronome_beam::
  metronome_beam (const char* _xsd_string_base)
  : ::musicxml::beam_value (_xsd_string_base),
    number_ (number_default_value (), this)
  {
  }

  metronome_beam::
  metronome_beam (const ::std::string& _xsd_string_base)
  : ::musicxml::beam_value (_xsd_string_base),
    number_ (number_default_value (), this)
  {
  }

  metronome_beam::
  metronome_beam (const ::musicxml::beam_value& _xsd_beam_value_base)
  : ::musicxml::beam_value (_xsd_beam_value_base),
    number_ (number_default_value (), this)
  {
  }

  metronome_beam::
  metronome_beam (const metronome_beam& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::beam_value (x, f, c),
    number_ (x.number_, f, this)
  {
  }

  metronome_beam::
  metronome_beam (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::musicxml::beam_value (e, f | ::xml_schema::flags::base, c),
    number_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void metronome_beam::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  metronome_beam* metronome_beam::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metronome_beam (*this, f, c);
  }

  metronome_beam& metronome_beam::
  operator= (const metronome_beam& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::beam_value& > (*this) = x;
      this->number_ = x.number_;
    }

    return *this;
  }

  metronome_beam::
  ~metronome_beam ()
  {
  }

  // metronome_note
  //

  metronome_note::
  metronome_note (const metronome_type_type& metronome_type)
  : ::xml_schema::type (),
    metronome_type_ (metronome_type, this),
    metronome_dot_ (this),
    metronome_beam_ (this),
    metronome_tied_ (this),
    metronome_tuplet_ (this)
  {
  }

  metronome_note::
  metronome_note (const metronome_note& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    metronome_type_ (x.metronome_type_, f, this),
    metronome_dot_ (x.metronome_dot_, f, this),
    metronome_beam_ (x.metronome_beam_, f, this),
    metronome_tied_ (x.metronome_tied_, f, this),
    metronome_tuplet_ (x.metronome_tuplet_, f, this)
  {
  }

  metronome_note::
  metronome_note (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    metronome_type_ (this),
    metronome_dot_ (this),
    metronome_beam_ (this),
    metronome_tied_ (this),
    metronome_tuplet_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void metronome_note::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // metronome-type
      //
      if (n.name () == "metronome-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_type_type > r (
          metronome_type_traits::create (i, f, this));

        if (!metronome_type_.present ())
        {
          this->metronome_type_.set (::std::move (r));
          continue;
        }
      }

      // metronome-dot
      //
      if (n.name () == "metronome-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_dot_type > r (
          metronome_dot_traits::create (i, f, this));

        this->metronome_dot_.push_back (::std::move (r));
        continue;
      }

      // metronome-beam
      //
      if (n.name () == "metronome-beam" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_beam_type > r (
          metronome_beam_traits::create (i, f, this));

        this->metronome_beam_.push_back (::std::move (r));
        continue;
      }

      // metronome-tied
      //
      if (n.name () == "metronome-tied" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_tied_type > r (
          metronome_tied_traits::create (i, f, this));

        if (!this->metronome_tied_)
        {
          this->metronome_tied_.set (::std::move (r));
          continue;
        }
      }

      // metronome-tuplet
      //
      if (n.name () == "metronome-tuplet" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metronome_tuplet_type > r (
          metronome_tuplet_traits::create (i, f, this));

        if (!this->metronome_tuplet_)
        {
          this->metronome_tuplet_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!metronome_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "metronome-type",
        "");
    }
  }

  metronome_note* metronome_note::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metronome_note (*this, f, c);
  }

  metronome_note& metronome_note::
  operator= (const metronome_note& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->metronome_type_ = x.metronome_type_;
      this->metronome_dot_ = x.metronome_dot_;
      this->metronome_beam_ = x.metronome_beam_;
      this->metronome_tied_ = x.metronome_tied_;
      this->metronome_tuplet_ = x.metronome_tuplet_;
    }

    return *this;
  }

  metronome_note::
  ~metronome_note ()
  {
  }

  // metronome_tied
  //

  metronome_tied::
  metronome_tied (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this)
  {
  }

  metronome_tied::
  metronome_tied (const metronome_tied& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  metronome_tied::
  metronome_tied (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void metronome_tied::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  metronome_tied* metronome_tied::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metronome_tied (*this, f, c);
  }

  metronome_tied& metronome_tied::
  operator= (const metronome_tied& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  metronome_tied::
  ~metronome_tied ()
  {
  }

  // time_modification
  //

  time_modification::
  time_modification (const actual_notes_type& actual_notes,
                     const normal_notes_type& normal_notes)
  : ::xml_schema::type (),
    actual_notes_ (actual_notes, this),
    normal_notes_ (normal_notes, this),
    normal_type_ (this),
    normal_dot_ (this)
  {
  }

  time_modification::
  time_modification (const time_modification& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    actual_notes_ (x.actual_notes_, f, this),
    normal_notes_ (x.normal_notes_, f, this),
    normal_type_ (x.normal_type_, f, this),
    normal_dot_ (x.normal_dot_, f, this)
  {
  }

  time_modification::
  time_modification (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    actual_notes_ (this),
    normal_notes_ (this),
    normal_type_ (this),
    normal_dot_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void time_modification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // actual-notes
      //
      if (n.name () == "actual-notes" && n.namespace_ ().empty ())
      {
        if (!actual_notes_.present ())
        {
          this->actual_notes_.set (actual_notes_traits::create (i, f, this));
          continue;
        }
      }

      // normal-notes
      //
      if (n.name () == "normal-notes" && n.namespace_ ().empty ())
      {
        if (!normal_notes_.present ())
        {
          this->normal_notes_.set (normal_notes_traits::create (i, f, this));
          continue;
        }
      }

      // normal-type
      //
      if (n.name () == "normal-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< normal_type_type > r (
          normal_type_traits::create (i, f, this));

        if (!this->normal_type_)
        {
          this->normal_type_.set (::std::move (r));
          continue;
        }
      }

      // normal-dot
      //
      if (n.name () == "normal-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< normal_dot_type > r (
          normal_dot_traits::create (i, f, this));

        this->normal_dot_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!actual_notes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "actual-notes",
        "");
    }

    if (!normal_notes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "normal-notes",
        "");
    }
  }

  time_modification* time_modification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class time_modification (*this, f, c);
  }

  time_modification& time_modification::
  operator= (const time_modification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->actual_notes_ = x.actual_notes_;
      this->normal_notes_ = x.normal_notes_;
      this->normal_type_ = x.normal_type_;
      this->normal_dot_ = x.normal_dot_;
    }

    return *this;
  }

  time_modification::
  ~time_modification ()
  {
  }

  // metronome_tuplet
  //

  metronome_tuplet::
  metronome_tuplet (const actual_notes_type& actual_notes,
                    const normal_notes_type& normal_notes,
                    const type_type& type)
  : ::musicxml::time_modification (actual_notes,
                                   normal_notes),
    type_ (type, this),
    bracket_ (this),
    show_number_ (this)
  {
  }

  metronome_tuplet::
  metronome_tuplet (const metronome_tuplet& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::time_modification (x, f, c),
    type_ (x.type_, f, this),
    bracket_ (x.bracket_, f, this),
    show_number_ (x.show_number_, f, this)
  {
  }

  metronome_tuplet::
  metronome_tuplet (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::musicxml::time_modification (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    bracket_ (this),
    show_number_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void metronome_tuplet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::musicxml::time_modification::parse (p, f);

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        this->bracket_.set (bracket_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show-number" && n.namespace_ ().empty ())
      {
        this->show_number_.set (show_number_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  metronome_tuplet* metronome_tuplet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metronome_tuplet (*this, f, c);
  }

  metronome_tuplet& metronome_tuplet::
  operator= (const metronome_tuplet& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::time_modification& > (*this) = x;
      this->type_ = x.type_;
      this->bracket_ = x.bracket_;
      this->show_number_ = x.show_number_;
    }

    return *this;
  }

  metronome_tuplet::
  ~metronome_tuplet ()
  {
  }

  // numeral
  //

  numeral::
  numeral (const numeral_root_type& numeral_root)
  : ::xml_schema::type (),
    numeral_root_ (numeral_root, this),
    numeral_alter_ (this),
    numeral_key_ (this)
  {
  }

  numeral::
  numeral (::std::unique_ptr< numeral_root_type > numeral_root)
  : ::xml_schema::type (),
    numeral_root_ (std::move (numeral_root), this),
    numeral_alter_ (this),
    numeral_key_ (this)
  {
  }

  numeral::
  numeral (const numeral& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    numeral_root_ (x.numeral_root_, f, this),
    numeral_alter_ (x.numeral_alter_, f, this),
    numeral_key_ (x.numeral_key_, f, this)
  {
  }

  numeral::
  numeral (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    numeral_root_ (this),
    numeral_alter_ (this),
    numeral_key_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void numeral::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // numeral-root
      //
      if (n.name () == "numeral-root" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_root_type > r (
          numeral_root_traits::create (i, f, this));

        if (!numeral_root_.present ())
        {
          this->numeral_root_.set (::std::move (r));
          continue;
        }
      }

      // numeral-alter
      //
      if (n.name () == "numeral-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_alter_type > r (
          numeral_alter_traits::create (i, f, this));

        if (!this->numeral_alter_)
        {
          this->numeral_alter_.set (::std::move (r));
          continue;
        }
      }

      // numeral-key
      //
      if (n.name () == "numeral-key" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_key_type > r (
          numeral_key_traits::create (i, f, this));

        if (!this->numeral_key_)
        {
          this->numeral_key_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!numeral_root_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numeral-root",
        "");
    }
  }

  numeral* numeral::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class numeral (*this, f, c);
  }

  numeral& numeral::
  operator= (const numeral& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->numeral_root_ = x.numeral_root_;
      this->numeral_alter_ = x.numeral_alter_;
      this->numeral_key_ = x.numeral_key_;
    }

    return *this;
  }

  numeral::
  ~numeral ()
  {
  }

  // numeral_key
  //

  numeral_key::
  numeral_key (const numeral_fifths_type& numeral_fifths,
               const numeral_mode_type& numeral_mode)
  : ::xml_schema::type (),
    numeral_fifths_ (numeral_fifths, this),
    numeral_mode_ (numeral_mode, this),
    print_object_ (this)
  {
  }

  numeral_key::
  numeral_key (const numeral_key& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    numeral_fifths_ (x.numeral_fifths_, f, this),
    numeral_mode_ (x.numeral_mode_, f, this),
    print_object_ (x.print_object_, f, this)
  {
  }

  numeral_key::
  numeral_key (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    numeral_fifths_ (this),
    numeral_mode_ (this),
    print_object_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void numeral_key::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // numeral-fifths
      //
      if (n.name () == "numeral-fifths" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_fifths_type > r (
          numeral_fifths_traits::create (i, f, this));

        if (!numeral_fifths_.present ())
        {
          this->numeral_fifths_.set (::std::move (r));
          continue;
        }
      }

      // numeral-mode
      //
      if (n.name () == "numeral-mode" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< numeral_mode_type > r (
          numeral_mode_traits::create (i, f, this));

        if (!numeral_mode_.present ())
        {
          this->numeral_mode_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!numeral_fifths_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numeral-fifths",
        "");
    }

    if (!numeral_mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numeral-mode",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }
    }
  }

  numeral_key* numeral_key::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class numeral_key (*this, f, c);
  }

  numeral_key& numeral_key::
  operator= (const numeral_key& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->numeral_fifths_ = x.numeral_fifths_;
      this->numeral_mode_ = x.numeral_mode_;
      this->print_object_ = x.print_object_;
    }

    return *this;
  }

  numeral_key::
  ~numeral_key ()
  {
  }

  // numeral_root
  //

  numeral_root::
  numeral_root (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
  : ::musicxml::numeral_value (_xsd_positive_integer_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  numeral_root::
  numeral_root (const numeral_root& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::numeral_value (x, f, c),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  numeral_root::
  numeral_root (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::numeral_value (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void numeral_root::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  numeral_root* numeral_root::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class numeral_root (*this, f, c);
  }

  numeral_root& numeral_root::
  operator= (const numeral_root& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::numeral_value& > (*this) = x;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  numeral_root::
  ~numeral_root ()
  {
  }

  // octave_shift
  //

  octave_shift::
  octave_shift (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    size_ (size_default_value (), this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  octave_shift::
  octave_shift (const octave_shift& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    size_ (x.size_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  octave_shift::
  octave_shift (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    size_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void octave_shift::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!size_.present ())
    {
      this->size_.set (size_default_value ());
    }
  }

  octave_shift* octave_shift::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class octave_shift (*this, f, c);
  }

  octave_shift& octave_shift::
  operator= (const octave_shift& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->size_ = x.size_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  octave_shift::
  ~octave_shift ()
  {
  }

  // offset
  //

  offset::
  offset (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::musicxml::divisions (_xsd_decimal_base),
    sound_ (this)
  {
  }

  offset::
  offset (const offset& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::divisions (x, f, c),
    sound_ (x.sound_, f, this)
  {
  }

  offset::
  offset (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::musicxml::divisions (e, f | ::xml_schema::flags::base, c),
    sound_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void offset::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sound" && n.namespace_ ().empty ())
      {
        this->sound_.set (sound_traits::create (i, f, this));
        continue;
      }
    }
  }

  offset* offset::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class offset (*this, f, c);
  }

  offset& offset::
  operator= (const offset& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::divisions& > (*this) = x;
      this->sound_ = x.sound_;
    }

    return *this;
  }

  offset::
  ~offset ()
  {
  }

  // other_direction
  //

  other_direction::
  other_direction ()
  : ::xml_schema::string (),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_direction::
  other_direction (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_direction::
  other_direction (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_direction::
  other_direction (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_direction::
  other_direction (const other_direction& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    smufl_ (x.smufl_, f, this),
    id_ (x.id_, f, this)
  {
  }

  other_direction::
  other_direction (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    smufl_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_direction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  other_direction* other_direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_direction (*this, f, c);
  }

  other_direction& other_direction::
  operator= (const other_direction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->smufl_ = x.smufl_;
      this->id_ = x.id_;
    }

    return *this;
  }

  other_direction::
  ~other_direction ()
  {
  }

  // other_listening
  //

  other_listening::
  other_listening (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    player_ (this),
    time_only_ (this)
  {
  }

  other_listening::
  other_listening (const char* _xsd_string_base,
                   const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    player_ (this),
    time_only_ (this)
  {
  }

  other_listening::
  other_listening (const ::std::string& _xsd_string_base,
                   const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    player_ (this),
    time_only_ (this)
  {
  }

  other_listening::
  other_listening (const ::xml_schema::string& _xsd_string_base,
                   const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    player_ (this),
    time_only_ (this)
  {
  }

  other_listening::
  other_listening (const other_listening& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    player_ (x.player_, f, this),
    time_only_ (x.time_only_, f, this)
  {
  }

  other_listening::
  other_listening (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    player_ (this),
    time_only_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_listening::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "player" && n.namespace_ ().empty ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  other_listening* other_listening::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_listening (*this, f, c);
  }

  other_listening& other_listening::
  operator= (const other_listening& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->player_ = x.player_;
      this->time_only_ = x.time_only_;
    }

    return *this;
  }

  other_listening::
  ~other_listening ()
  {
  }

  // pedal
  //

  pedal::
  pedal (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    line_ (this),
    sign_ (this),
    abbreviated_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  pedal::
  pedal (const pedal& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_ (x.line_, f, this),
    sign_ (x.sign_, f, this),
    abbreviated_ (x.abbreviated_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  pedal::
  pedal (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_ (this),
    sign_ (this),
    abbreviated_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void pedal::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line" && n.namespace_ ().empty ())
      {
        this->line_.set (line_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sign" && n.namespace_ ().empty ())
      {
        this->sign_.set (sign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "abbreviated" && n.namespace_ ().empty ())
      {
        this->abbreviated_.set (abbreviated_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  pedal* pedal::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pedal (*this, f, c);
  }

  pedal& pedal::
  operator= (const pedal& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_ = x.line_;
      this->sign_ = x.sign_;
      this->abbreviated_ = x.abbreviated_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  pedal::
  ~pedal ()
  {
  }

  // pedal_tuning
  //

  pedal_tuning::
  pedal_tuning (const pedal_step_type& pedal_step,
                const pedal_alter_type& pedal_alter)
  : ::xml_schema::type (),
    pedal_step_ (pedal_step, this),
    pedal_alter_ (pedal_alter, this)
  {
  }

  pedal_tuning::
  pedal_tuning (const pedal_tuning& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    pedal_step_ (x.pedal_step_, f, this),
    pedal_alter_ (x.pedal_alter_, f, this)
  {
  }

  pedal_tuning::
  pedal_tuning (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    pedal_step_ (this),
    pedal_alter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void pedal_tuning::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pedal-step
      //
      if (n.name () == "pedal-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pedal_step_type > r (
          pedal_step_traits::create (i, f, this));

        if (!pedal_step_.present ())
        {
          this->pedal_step_.set (::std::move (r));
          continue;
        }
      }

      // pedal-alter
      //
      if (n.name () == "pedal-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pedal_alter_type > r (
          pedal_alter_traits::create (i, f, this));

        if (!pedal_alter_.present ())
        {
          this->pedal_alter_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!pedal_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pedal-step",
        "");
    }

    if (!pedal_alter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pedal-alter",
        "");
    }
  }

  pedal_tuning* pedal_tuning::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pedal_tuning (*this, f, c);
  }

  pedal_tuning& pedal_tuning::
  operator= (const pedal_tuning& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->pedal_step_ = x.pedal_step_;
      this->pedal_alter_ = x.pedal_alter_;
    }

    return *this;
  }

  pedal_tuning::
  ~pedal_tuning ()
  {
  }

  // per_minute
  //

  per_minute::
  per_minute ()
  : ::xml_schema::string (),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  per_minute::
  per_minute (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  per_minute::
  per_minute (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  per_minute::
  per_minute (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  per_minute::
  per_minute (const per_minute& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this)
  {
  }

  per_minute::
  per_minute (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void per_minute::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }
    }
  }

  per_minute* per_minute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class per_minute (*this, f, c);
  }

  per_minute& per_minute::
  operator= (const per_minute& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
    }

    return *this;
  }

  per_minute::
  ~per_minute ()
  {
  }

  // percussion
  //

  percussion::
  percussion ()
  : ::xml_schema::type (),
    glass_ (this),
    metal_ (this),
    wood_ (this),
    pitched_ (this),
    membrane_ (this),
    effect_ (this),
    timpani_ (this),
    beater_ (this),
    stick_ (this),
    stick_location_ (this),
    other_percussion_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    enclosure_ (this),
    id_ (this)
  {
  }

  percussion::
  percussion (const percussion& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    glass_ (x.glass_, f, this),
    metal_ (x.metal_, f, this),
    wood_ (x.wood_, f, this),
    pitched_ (x.pitched_, f, this),
    membrane_ (x.membrane_, f, this),
    effect_ (x.effect_, f, this),
    timpani_ (x.timpani_, f, this),
    beater_ (x.beater_, f, this),
    stick_ (x.stick_, f, this),
    stick_location_ (x.stick_location_, f, this),
    other_percussion_ (x.other_percussion_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    enclosure_ (x.enclosure_, f, this),
    id_ (x.id_, f, this)
  {
  }

  percussion::
  percussion (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    glass_ (this),
    metal_ (this),
    wood_ (this),
    pitched_ (this),
    membrane_ (this),
    effect_ (this),
    timpani_ (this),
    beater_ (this),
    stick_ (this),
    stick_location_ (this),
    other_percussion_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    enclosure_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void percussion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // glass
      //
      if (n.name () == "glass" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< glass_type > r (
          glass_traits::create (i, f, this));

        if (!this->glass_)
        {
          this->glass_.set (::std::move (r));
          continue;
        }
      }

      // metal
      //
      if (n.name () == "metal" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< metal_type > r (
          metal_traits::create (i, f, this));

        if (!this->metal_)
        {
          this->metal_.set (::std::move (r));
          continue;
        }
      }

      // wood
      //
      if (n.name () == "wood" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< wood_type > r (
          wood_traits::create (i, f, this));

        if (!this->wood_)
        {
          this->wood_.set (::std::move (r));
          continue;
        }
      }

      // pitched
      //
      if (n.name () == "pitched" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pitched_type > r (
          pitched_traits::create (i, f, this));

        if (!this->pitched_)
        {
          this->pitched_.set (::std::move (r));
          continue;
        }
      }

      // membrane
      //
      if (n.name () == "membrane" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< membrane_type > r (
          membrane_traits::create (i, f, this));

        if (!this->membrane_)
        {
          this->membrane_.set (::std::move (r));
          continue;
        }
      }

      // effect
      //
      if (n.name () == "effect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< effect_type > r (
          effect_traits::create (i, f, this));

        if (!this->effect_)
        {
          this->effect_.set (::std::move (r));
          continue;
        }
      }

      // timpani
      //
      if (n.name () == "timpani" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< timpani_type > r (
          timpani_traits::create (i, f, this));

        if (!this->timpani_)
        {
          this->timpani_.set (::std::move (r));
          continue;
        }
      }

      // beater
      //
      if (n.name () == "beater" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beater_type > r (
          beater_traits::create (i, f, this));

        if (!this->beater_)
        {
          this->beater_.set (::std::move (r));
          continue;
        }
      }

      // stick
      //
      if (n.name () == "stick" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stick_type > r (
          stick_traits::create (i, f, this));

        if (!this->stick_)
        {
          this->stick_.set (::std::move (r));
          continue;
        }
      }

      // stick-location
      //
      if (n.name () == "stick-location" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stick_location_type > r (
          stick_location_traits::create (i, f, this));

        if (!this->stick_location_)
        {
          this->stick_location_.set (::std::move (r));
          continue;
        }
      }

      // other-percussion
      //
      if (n.name () == "other-percussion" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_percussion_type > r (
          other_percussion_traits::create (i, f, this));

        if (!this->other_percussion_)
        {
          this->other_percussion_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "enclosure" && n.namespace_ ().empty ())
      {
        this->enclosure_.set (enclosure_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  percussion* percussion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class percussion (*this, f, c);
  }

  percussion& percussion::
  operator= (const percussion& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->glass_ = x.glass_;
      this->metal_ = x.metal_;
      this->wood_ = x.wood_;
      this->pitched_ = x.pitched_;
      this->membrane_ = x.membrane_;
      this->effect_ = x.effect_;
      this->timpani_ = x.timpani_;
      this->beater_ = x.beater_;
      this->stick_ = x.stick_;
      this->stick_location_ = x.stick_location_;
      this->other_percussion_ = x.other_percussion_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->enclosure_ = x.enclosure_;
      this->id_ = x.id_;
    }

    return *this;
  }

  percussion::
  ~percussion ()
  {
  }

  // pitched
  //

  pitched::
  pitched (::musicxml::pitched_value::value _xsd_pitched_value_base)
  : ::musicxml::pitched_value (_xsd_pitched_value_base),
    smufl_ (this)
  {
  }

  pitched::
  pitched (const char* _xsd_string_base)
  : ::musicxml::pitched_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  pitched::
  pitched (const ::std::string& _xsd_string_base)
  : ::musicxml::pitched_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  pitched::
  pitched (const ::musicxml::pitched_value& _xsd_pitched_value_base)
  : ::musicxml::pitched_value (_xsd_pitched_value_base),
    smufl_ (this)
  {
  }

  pitched::
  pitched (const pitched& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::pitched_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  pitched::
  pitched (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::pitched_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void pitched::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  pitched* pitched::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pitched (*this, f, c);
  }

  pitched& pitched::
  operator= (const pitched& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::pitched_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  pitched::
  ~pitched ()
  {
  }

  // principal_voice
  //

  principal_voice::
  principal_voice (const type_type& type,
                   const symbol_type& symbol)
  : ::xml_schema::string (),
    type_ (type, this),
    symbol_ (symbol, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  principal_voice::
  principal_voice (const char* _xsd_string_base,
                   const type_type& type,
                   const symbol_type& symbol)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    symbol_ (symbol, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  principal_voice::
  principal_voice (const ::std::string& _xsd_string_base,
                   const type_type& type,
                   const symbol_type& symbol)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    symbol_ (symbol, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  principal_voice::
  principal_voice (const ::xml_schema::string& _xsd_string_base,
                   const type_type& type,
                   const symbol_type& symbol)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    symbol_ (symbol, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  principal_voice::
  principal_voice (const principal_voice& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    symbol_ (x.symbol_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  principal_voice::
  principal_voice (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    symbol_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void principal_voice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "symbol" && n.namespace_ ().empty ())
      {
        this->symbol_.set (symbol_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!symbol_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "symbol",
        "");
    }
  }

  principal_voice* principal_voice::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class principal_voice (*this, f, c);
  }

  principal_voice& principal_voice::
  operator= (const principal_voice& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->symbol_ = x.symbol_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  principal_voice::
  ~principal_voice ()
  {
  }

  // print
  //

  print::
  print ()
  : ::xml_schema::type (),
    page_layout_ (this),
    system_layout_ (this),
    staff_layout_ (this),
    measure_layout_ (this),
    measure_numbering_ (this),
    part_name_display_ (this),
    part_abbreviation_display_ (this),
    staff_spacing_ (this),
    new_system_ (this),
    new_page_ (this),
    blank_page_ (this),
    page_number_ (this),
    id_ (this)
  {
  }

  print::
  print (const print& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    page_layout_ (x.page_layout_, f, this),
    system_layout_ (x.system_layout_, f, this),
    staff_layout_ (x.staff_layout_, f, this),
    measure_layout_ (x.measure_layout_, f, this),
    measure_numbering_ (x.measure_numbering_, f, this),
    part_name_display_ (x.part_name_display_, f, this),
    part_abbreviation_display_ (x.part_abbreviation_display_, f, this),
    staff_spacing_ (x.staff_spacing_, f, this),
    new_system_ (x.new_system_, f, this),
    new_page_ (x.new_page_, f, this),
    blank_page_ (x.blank_page_, f, this),
    page_number_ (x.page_number_, f, this),
    id_ (x.id_, f, this)
  {
  }

  print::
  print (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    page_layout_ (this),
    system_layout_ (this),
    staff_layout_ (this),
    measure_layout_ (this),
    measure_numbering_ (this),
    part_name_display_ (this),
    part_abbreviation_display_ (this),
    staff_spacing_ (this),
    new_system_ (this),
    new_page_ (this),
    blank_page_ (this),
    page_number_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void print::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // page-layout
      //
      if (n.name () == "page-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< page_layout_type > r (
          page_layout_traits::create (i, f, this));

        if (!this->page_layout_)
        {
          this->page_layout_.set (::std::move (r));
          continue;
        }
      }

      // system-layout
      //
      if (n.name () == "system-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< system_layout_type > r (
          system_layout_traits::create (i, f, this));

        if (!this->system_layout_)
        {
          this->system_layout_.set (::std::move (r));
          continue;
        }
      }

      // staff-layout
      //
      if (n.name () == "staff-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_layout_type > r (
          staff_layout_traits::create (i, f, this));

        this->staff_layout_.push_back (::std::move (r));
        continue;
      }

      // measure-layout
      //
      if (n.name () == "measure-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_layout_type > r (
          measure_layout_traits::create (i, f, this));

        if (!this->measure_layout_)
        {
          this->measure_layout_.set (::std::move (r));
          continue;
        }
      }

      // measure-numbering
      //
      if (n.name () == "measure-numbering" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_numbering_type > r (
          measure_numbering_traits::create (i, f, this));

        if (!this->measure_numbering_)
        {
          this->measure_numbering_.set (::std::move (r));
          continue;
        }
      }

      // part-name-display
      //
      if (n.name () == "part-name-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_name_display_type > r (
          part_name_display_traits::create (i, f, this));

        if (!this->part_name_display_)
        {
          this->part_name_display_.set (::std::move (r));
          continue;
        }
      }

      // part-abbreviation-display
      //
      if (n.name () == "part-abbreviation-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_abbreviation_display_type > r (
          part_abbreviation_display_traits::create (i, f, this));

        if (!this->part_abbreviation_display_)
        {
          this->part_abbreviation_display_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "staff-spacing" && n.namespace_ ().empty ())
      {
        this->staff_spacing_.set (staff_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "new-system" && n.namespace_ ().empty ())
      {
        this->new_system_.set (new_system_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "new-page" && n.namespace_ ().empty ())
      {
        this->new_page_.set (new_page_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "blank-page" && n.namespace_ ().empty ())
      {
        this->blank_page_.set (blank_page_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "page-number" && n.namespace_ ().empty ())
      {
        this->page_number_.set (page_number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  print* print::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class print (*this, f, c);
  }

  print& print::
  operator= (const print& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->page_layout_ = x.page_layout_;
      this->system_layout_ = x.system_layout_;
      this->staff_layout_ = x.staff_layout_;
      this->measure_layout_ = x.measure_layout_;
      this->measure_numbering_ = x.measure_numbering_;
      this->part_name_display_ = x.part_name_display_;
      this->part_abbreviation_display_ = x.part_abbreviation_display_;
      this->staff_spacing_ = x.staff_spacing_;
      this->new_system_ = x.new_system_;
      this->new_page_ = x.new_page_;
      this->blank_page_ = x.blank_page_;
      this->page_number_ = x.page_number_;
      this->id_ = x.id_;
    }

    return *this;
  }

  print::
  ~print ()
  {
  }

  // root
  //

  root::
  root (const root_step_type& root_step)
  : ::xml_schema::type (),
    root_step_ (root_step, this),
    root_alter_ (this)
  {
  }

  root::
  root (::std::unique_ptr< root_step_type > root_step)
  : ::xml_schema::type (),
    root_step_ (std::move (root_step), this),
    root_alter_ (this)
  {
  }

  root::
  root (const root& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    root_step_ (x.root_step_, f, this),
    root_alter_ (x.root_alter_, f, this)
  {
  }

  root::
  root (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    root_step_ (this),
    root_alter_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void root::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // root-step
      //
      if (n.name () == "root-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< root_step_type > r (
          root_step_traits::create (i, f, this));

        if (!root_step_.present ())
        {
          this->root_step_.set (::std::move (r));
          continue;
        }
      }

      // root-alter
      //
      if (n.name () == "root-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< root_alter_type > r (
          root_alter_traits::create (i, f, this));

        if (!this->root_alter_)
        {
          this->root_alter_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!root_step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "root-step",
        "");
    }
  }

  root* root::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class root (*this, f, c);
  }

  root& root::
  operator= (const root& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->root_step_ = x.root_step_;
      this->root_alter_ = x.root_alter_;
    }

    return *this;
  }

  root::
  ~root ()
  {
  }

  // root_step
  //

  root_step::
  root_step (::musicxml::step::value _xsd_step_base)
  : ::musicxml::step (_xsd_step_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  root_step::
  root_step (const char* _xsd_string_base)
  : ::musicxml::step (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  root_step::
  root_step (const ::std::string& _xsd_string_base)
  : ::musicxml::step (_xsd_string_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  root_step::
  root_step (const ::musicxml::step& _xsd_step_base)
  : ::musicxml::step (_xsd_step_base),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  root_step::
  root_step (const root_step& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::step (x, f, c),
    text_ (x.text_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  root_step::
  root_step (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::step (e, f | ::xml_schema::flags::base, c),
    text_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void root_step::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  root_step* root_step::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class root_step (*this, f, c);
  }

  root_step& root_step::
  operator= (const root_step& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::step& > (*this) = x;
      this->text_ = x.text_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  root_step::
  ~root_step ()
  {
  }

  // scordatura
  //

  scordatura::
  scordatura ()
  : ::xml_schema::type (),
    accord_ (this),
    id_ (this)
  {
  }

  scordatura::
  scordatura (const scordatura& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    accord_ (x.accord_, f, this),
    id_ (x.id_, f, this)
  {
  }

  scordatura::
  scordatura (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    accord_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void scordatura::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accord
      //
      if (n.name () == "accord" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accord_type > r (
          accord_traits::create (i, f, this));

        this->accord_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  scordatura* scordatura::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scordatura (*this, f, c);
  }

  scordatura& scordatura::
  operator= (const scordatura& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->accord_ = x.accord_;
      this->id_ = x.id_;
    }

    return *this;
  }

  scordatura::
  ~scordatura ()
  {
  }

  // sound
  //

  sound::
  sound ()
  : ::xml_schema::type (),
    instrument_change_ (this),
    midi_device_ (this),
    midi_instrument_ (this),
    play_ (this),
    swing_ (this),
    offset_ (this),
    tempo_ (this),
    dynamics_ (this),
    dacapo_ (this),
    segno_ (this),
    dalsegno_ (this),
    coda_ (this),
    tocoda_ (this),
    divisions_ (this),
    forward_repeat_ (this),
    fine_ (this),
    time_only_ (this),
    pizzicato_ (this),
    pan_ (this),
    elevation_ (this),
    damper_pedal_ (this),
    soft_pedal_ (this),
    sostenuto_pedal_ (this),
    id_ (this)
  {
  }

  sound::
  sound (const sound& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    instrument_change_ (x.instrument_change_, f, this),
    midi_device_ (x.midi_device_, f, this),
    midi_instrument_ (x.midi_instrument_, f, this),
    play_ (x.play_, f, this),
    swing_ (x.swing_, f, this),
    offset_ (x.offset_, f, this),
    tempo_ (x.tempo_, f, this),
    dynamics_ (x.dynamics_, f, this),
    dacapo_ (x.dacapo_, f, this),
    segno_ (x.segno_, f, this),
    dalsegno_ (x.dalsegno_, f, this),
    coda_ (x.coda_, f, this),
    tocoda_ (x.tocoda_, f, this),
    divisions_ (x.divisions_, f, this),
    forward_repeat_ (x.forward_repeat_, f, this),
    fine_ (x.fine_, f, this),
    time_only_ (x.time_only_, f, this),
    pizzicato_ (x.pizzicato_, f, this),
    pan_ (x.pan_, f, this),
    elevation_ (x.elevation_, f, this),
    damper_pedal_ (x.damper_pedal_, f, this),
    soft_pedal_ (x.soft_pedal_, f, this),
    sostenuto_pedal_ (x.sostenuto_pedal_, f, this),
    id_ (x.id_, f, this)
  {
  }

  sound::
  sound (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    instrument_change_ (this),
    midi_device_ (this),
    midi_instrument_ (this),
    play_ (this),
    swing_ (this),
    offset_ (this),
    tempo_ (this),
    dynamics_ (this),
    dacapo_ (this),
    segno_ (this),
    dalsegno_ (this),
    coda_ (this),
    tocoda_ (this),
    divisions_ (this),
    forward_repeat_ (this),
    fine_ (this),
    time_only_ (this),
    pizzicato_ (this),
    pan_ (this),
    elevation_ (this),
    damper_pedal_ (this),
    soft_pedal_ (this),
    sostenuto_pedal_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void sound::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instrument-change
      //
      if (n.name () == "instrument-change" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_change_type > r (
          instrument_change_traits::create (i, f, this));

        this->instrument_change_.push_back (::std::move (r));
        continue;
      }

      // midi-device
      //
      if (n.name () == "midi-device" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_device_type > r (
          midi_device_traits::create (i, f, this));

        this->midi_device_.push_back (::std::move (r));
        continue;
      }

      // midi-instrument
      //
      if (n.name () == "midi-instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_instrument_type > r (
          midi_instrument_traits::create (i, f, this));

        this->midi_instrument_.push_back (::std::move (r));
        continue;
      }

      // play
      //
      if (n.name () == "play" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< play_type > r (
          play_traits::create (i, f, this));

        this->play_.push_back (::std::move (r));
        continue;
      }

      // swing
      //
      if (n.name () == "swing" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< swing_type > r (
          swing_traits::create (i, f, this));

        if (!this->swing_)
        {
          this->swing_.set (::std::move (r));
          continue;
        }
      }

      // offset
      //
      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< offset_type > r (
          offset_traits::create (i, f, this));

        if (!this->offset_)
        {
          this->offset_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tempo" && n.namespace_ ().empty ())
      {
        this->tempo_.set (tempo_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dynamics" && n.namespace_ ().empty ())
      {
        this->dynamics_.set (dynamics_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dacapo" && n.namespace_ ().empty ())
      {
        this->dacapo_.set (dacapo_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "segno" && n.namespace_ ().empty ())
      {
        this->segno_.set (segno_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dalsegno" && n.namespace_ ().empty ())
      {
        this->dalsegno_.set (dalsegno_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "coda" && n.namespace_ ().empty ())
      {
        this->coda_.set (coda_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "tocoda" && n.namespace_ ().empty ())
      {
        this->tocoda_.set (tocoda_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "divisions" && n.namespace_ ().empty ())
      {
        this->divisions_.set (divisions_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "forward-repeat" && n.namespace_ ().empty ())
      {
        this->forward_repeat_.set (forward_repeat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fine" && n.namespace_ ().empty ())
      {
        this->fine_.set (fine_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pizzicato" && n.namespace_ ().empty ())
      {
        this->pizzicato_.set (pizzicato_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pan" && n.namespace_ ().empty ())
      {
        this->pan_.set (pan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "elevation" && n.namespace_ ().empty ())
      {
        this->elevation_.set (elevation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "damper-pedal" && n.namespace_ ().empty ())
      {
        this->damper_pedal_.set (damper_pedal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "soft-pedal" && n.namespace_ ().empty ())
      {
        this->soft_pedal_.set (soft_pedal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sostenuto-pedal" && n.namespace_ ().empty ())
      {
        this->sostenuto_pedal_.set (sostenuto_pedal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  sound* sound::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sound (*this, f, c);
  }

  sound& sound::
  operator= (const sound& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->instrument_change_ = x.instrument_change_;
      this->midi_device_ = x.midi_device_;
      this->midi_instrument_ = x.midi_instrument_;
      this->play_ = x.play_;
      this->swing_ = x.swing_;
      this->offset_ = x.offset_;
      this->tempo_ = x.tempo_;
      this->dynamics_ = x.dynamics_;
      this->dacapo_ = x.dacapo_;
      this->segno_ = x.segno_;
      this->dalsegno_ = x.dalsegno_;
      this->coda_ = x.coda_;
      this->tocoda_ = x.tocoda_;
      this->divisions_ = x.divisions_;
      this->forward_repeat_ = x.forward_repeat_;
      this->fine_ = x.fine_;
      this->time_only_ = x.time_only_;
      this->pizzicato_ = x.pizzicato_;
      this->pan_ = x.pan_;
      this->elevation_ = x.elevation_;
      this->damper_pedal_ = x.damper_pedal_;
      this->soft_pedal_ = x.soft_pedal_;
      this->sostenuto_pedal_ = x.sostenuto_pedal_;
      this->id_ = x.id_;
    }

    return *this;
  }

  sound::
  ~sound ()
  {
  }

  // staff_divide
  //

  staff_divide::
  staff_divide (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  staff_divide::
  staff_divide (const staff_divide& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  staff_divide::
  staff_divide (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void staff_divide::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  staff_divide* staff_divide::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_divide (*this, f, c);
  }

  staff_divide& staff_divide::
  operator= (const staff_divide& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  staff_divide::
  ~staff_divide ()
  {
  }

  // stick
  //

  stick::
  stick (const stick_type_type& stick_type,
         const stick_material_type& stick_material)
  : ::xml_schema::type (),
    stick_type_ (stick_type, this),
    stick_material_ (stick_material, this),
    tip_ (this),
    parentheses_ (this),
    dashed_circle_ (this)
  {
  }

  stick::
  stick (const stick& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    stick_type_ (x.stick_type_, f, this),
    stick_material_ (x.stick_material_, f, this),
    tip_ (x.tip_, f, this),
    parentheses_ (x.parentheses_, f, this),
    dashed_circle_ (x.dashed_circle_, f, this)
  {
  }

  stick::
  stick (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    stick_type_ (this),
    stick_material_ (this),
    tip_ (this),
    parentheses_ (this),
    dashed_circle_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void stick::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // stick-type
      //
      if (n.name () == "stick-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stick_type_type > r (
          stick_type_traits::create (i, f, this));

        if (!stick_type_.present ())
        {
          this->stick_type_.set (::std::move (r));
          continue;
        }
      }

      // stick-material
      //
      if (n.name () == "stick-material" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stick_material_type > r (
          stick_material_traits::create (i, f, this));

        if (!stick_material_.present ())
        {
          this->stick_material_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!stick_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stick-type",
        "");
    }

    if (!stick_material_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "stick-material",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "tip" && n.namespace_ ().empty ())
      {
        this->tip_.set (tip_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dashed-circle" && n.namespace_ ().empty ())
      {
        this->dashed_circle_.set (dashed_circle_traits::create (i, f, this));
        continue;
      }
    }
  }

  stick* stick::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stick (*this, f, c);
  }

  stick& stick::
  operator= (const stick& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->stick_type_ = x.stick_type_;
      this->stick_material_ = x.stick_material_;
      this->tip_ = x.tip_;
      this->parentheses_ = x.parentheses_;
      this->dashed_circle_ = x.dashed_circle_;
    }

    return *this;
  }

  stick::
  ~stick ()
  {
  }

  // string_mute
  //

  string_mute::
  string_mute (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
  }

  string_mute::
  string_mute (const string_mute& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    id_ (x.id_, f, this)
  {
  }

  string_mute::
  string_mute (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void string_mute::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  string_mute* string_mute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class string_mute (*this, f, c);
  }

  string_mute& string_mute::
  operator= (const string_mute& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->id_ = x.id_;
    }

    return *this;
  }

  string_mute::
  ~string_mute ()
  {
  }

  // swing
  //

  swing::
  swing ()
  : ::xml_schema::type (),
    straight_ (this),
    first_ (this),
    second_ (this),
    swing_type_ (this),
    swing_style_ (this)
  {
  }

  swing::
  swing (const swing& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    straight_ (x.straight_, f, this),
    first_ (x.first_, f, this),
    second_ (x.second_, f, this),
    swing_type_ (x.swing_type_, f, this),
    swing_style_ (x.swing_style_, f, this)
  {
  }

  swing::
  swing (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    straight_ (this),
    first_ (this),
    second_ (this),
    swing_type_ (this),
    swing_style_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void swing::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // straight
      //
      if (n.name () == "straight" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< straight_type > r (
          straight_traits::create (i, f, this));

        if (!this->straight_)
        {
          this->straight_.set (::std::move (r));
          continue;
        }
      }

      // first
      //
      if (n.name () == "first" && n.namespace_ ().empty ())
      {
        if (!this->first_)
        {
          this->first_.set (first_traits::create (i, f, this));
          continue;
        }
      }

      // second
      //
      if (n.name () == "second" && n.namespace_ ().empty ())
      {
        if (!this->second_)
        {
          this->second_.set (second_traits::create (i, f, this));
          continue;
        }
      }

      // swing-type
      //
      if (n.name () == "swing-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< swing_type_type > r (
          swing_type_traits::create (i, f, this));

        if (!this->swing_type_)
        {
          this->swing_type_.set (::std::move (r));
          continue;
        }
      }

      // swing-style
      //
      if (n.name () == "swing-style" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< swing_style_type > r (
          swing_style_traits::create (i, f, this));

        if (!this->swing_style_)
        {
          this->swing_style_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  swing* swing::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class swing (*this, f, c);
  }

  swing& swing::
  operator= (const swing& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->straight_ = x.straight_;
      this->first_ = x.first_;
      this->second_ = x.second_;
      this->swing_type_ = x.swing_type_;
      this->swing_style_ = x.swing_style_;
    }

    return *this;
  }

  swing::
  ~swing ()
  {
  }

  // sync
  //

  sync::
  sync (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    latency_ (this),
    player_ (this),
    time_only_ (this)
  {
  }

  sync::
  sync (const sync& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    latency_ (x.latency_, f, this),
    player_ (x.player_, f, this),
    time_only_ (x.time_only_, f, this)
  {
  }

  sync::
  sync (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    latency_ (this),
    player_ (this),
    time_only_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void sync::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "latency" && n.namespace_ ().empty ())
      {
        this->latency_.set (latency_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "player" && n.namespace_ ().empty ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  sync* sync::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sync (*this, f, c);
  }

  sync& sync::
  operator= (const sync& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->latency_ = x.latency_;
      this->player_ = x.player_;
      this->time_only_ = x.time_only_;
    }

    return *this;
  }

  sync::
  ~sync ()
  {
  }

  // timpani
  //

  timpani::
  timpani ()
  : ::xml_schema::type (),
    smufl_ (this)
  {
  }

  timpani::
  timpani (const timpani& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  timpani::
  timpani (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void timpani::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  timpani* timpani::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class timpani (*this, f, c);
  }

  timpani& timpani::
  operator= (const timpani& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  timpani::
  ~timpani ()
  {
  }

  // wedge
  //

  wedge::
  wedge (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    spread_ (this),
    niente_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
  }

  wedge::
  wedge (const wedge& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    spread_ (x.spread_, f, this),
    niente_ (x.niente_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  wedge::
  wedge (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    spread_ (this),
    niente_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void wedge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "spread" && n.namespace_ ().empty ())
      {
        this->spread_.set (spread_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "niente" && n.namespace_ ().empty ())
      {
        this->niente_.set (niente_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  wedge* wedge::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wedge (*this, f, c);
  }

  wedge& wedge::
  operator= (const wedge& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->spread_ = x.spread_;
      this->niente_ = x.niente_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  wedge::
  ~wedge ()
  {
  }

  // wood
  //

  wood::
  wood (::musicxml::wood_value::value _xsd_wood_value_base)
  : ::musicxml::wood_value (_xsd_wood_value_base),
    smufl_ (this)
  {
  }

  wood::
  wood (const char* _xsd_string_base)
  : ::musicxml::wood_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  wood::
  wood (const ::std::string& _xsd_string_base)
  : ::musicxml::wood_value (_xsd_string_base),
    smufl_ (this)
  {
  }

  wood::
  wood (const ::musicxml::wood_value& _xsd_wood_value_base)
  : ::musicxml::wood_value (_xsd_wood_value_base),
    smufl_ (this)
  {
  }

  wood::
  wood (const wood& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::wood_value (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  wood::
  wood (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::wood_value (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void wood::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  wood* wood::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wood (*this, f, c);
  }

  wood& wood::
  operator= (const wood& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::wood_value& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  wood::
  ~wood ()
  {
  }

  // encoding
  //

  encoding::
  encoding ()
  : ::xml_schema::type (),
    encoding_date_ (this),
    encoder_ (this),
    software_ (this),
    encoding_description_ (this),
    supports_ (this)
  {
  }

  encoding::
  encoding (const encoding& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    encoding_date_ (x.encoding_date_, f, this),
    encoder_ (x.encoder_, f, this),
    software_ (x.software_, f, this),
    encoding_description_ (x.encoding_description_, f, this),
    supports_ (x.supports_, f, this)
  {
  }

  encoding::
  encoding (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    encoding_date_ (this),
    encoder_ (this),
    software_ (this),
    encoding_description_ (this),
    supports_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void encoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // encoding-date
      //
      if (n.name () == "encoding-date" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< encoding_date_type > r (
          encoding_date_traits::create (i, f, this));

        this->encoding_date_.push_back (::std::move (r));
        continue;
      }

      // encoder
      //
      if (n.name () == "encoder" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< encoder_type > r (
          encoder_traits::create (i, f, this));

        this->encoder_.push_back (::std::move (r));
        continue;
      }

      // software
      //
      if (n.name () == "software" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< software_type > r (
          software_traits::create (i, f, this));

        this->software_.push_back (::std::move (r));
        continue;
      }

      // encoding-description
      //
      if (n.name () == "encoding-description" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< encoding_description_type > r (
          encoding_description_traits::create (i, f, this));

        this->encoding_description_.push_back (::std::move (r));
        continue;
      }

      // supports
      //
      if (n.name () == "supports" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< supports_type > r (
          supports_traits::create (i, f, this));

        this->supports_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  encoding* encoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encoding (*this, f, c);
  }

  encoding& encoding::
  operator= (const encoding& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->encoding_date_ = x.encoding_date_;
      this->encoder_ = x.encoder_;
      this->software_ = x.software_;
      this->encoding_description_ = x.encoding_description_;
      this->supports_ = x.supports_;
    }

    return *this;
  }

  encoding::
  ~encoding ()
  {
  }

  // identification
  //

  identification::
  identification ()
  : ::xml_schema::type (),
    creator_ (this),
    rights_ (this),
    encoding_ (this),
    source_ (this),
    relation_ (this),
    miscellaneous_ (this)
  {
  }

  identification::
  identification (const identification& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    creator_ (x.creator_, f, this),
    rights_ (x.rights_, f, this),
    encoding_ (x.encoding_, f, this),
    source_ (x.source_, f, this),
    relation_ (x.relation_, f, this),
    miscellaneous_ (x.miscellaneous_, f, this)
  {
  }

  identification::
  identification (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    creator_ (this),
    rights_ (this),
    encoding_ (this),
    source_ (this),
    relation_ (this),
    miscellaneous_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void identification::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // creator
      //
      if (n.name () == "creator" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< creator_type > r (
          creator_traits::create (i, f, this));

        this->creator_.push_back (::std::move (r));
        continue;
      }

      // rights
      //
      if (n.name () == "rights" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< rights_type > r (
          rights_traits::create (i, f, this));

        this->rights_.push_back (::std::move (r));
        continue;
      }

      // encoding
      //
      if (n.name () == "encoding" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        if (!this->encoding_)
        {
          this->encoding_.set (::std::move (r));
          continue;
        }
      }

      // source
      //
      if (n.name () == "source" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< source_type > r (
          source_traits::create (i, f, this));

        if (!this->source_)
        {
          this->source_.set (::std::move (r));
          continue;
        }
      }

      // relation
      //
      if (n.name () == "relation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< relation_type > r (
          relation_traits::create (i, f, this));

        this->relation_.push_back (::std::move (r));
        continue;
      }

      // miscellaneous
      //
      if (n.name () == "miscellaneous" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< miscellaneous_type > r (
          miscellaneous_traits::create (i, f, this));

        if (!this->miscellaneous_)
        {
          this->miscellaneous_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  identification* identification::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class identification (*this, f, c);
  }

  identification& identification::
  operator= (const identification& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->creator_ = x.creator_;
      this->rights_ = x.rights_;
      this->encoding_ = x.encoding_;
      this->source_ = x.source_;
      this->relation_ = x.relation_;
      this->miscellaneous_ = x.miscellaneous_;
    }

    return *this;
  }

  identification::
  ~identification ()
  {
  }

  // miscellaneous
  //

  miscellaneous::
  miscellaneous ()
  : ::xml_schema::type (),
    miscellaneous_field_ (this)
  {
  }

  miscellaneous::
  miscellaneous (const miscellaneous& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    miscellaneous_field_ (x.miscellaneous_field_, f, this)
  {
  }

  miscellaneous::
  miscellaneous (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    miscellaneous_field_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void miscellaneous::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // miscellaneous-field
      //
      if (n.name () == "miscellaneous-field" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< miscellaneous_field_type > r (
          miscellaneous_field_traits::create (i, f, this));

        this->miscellaneous_field_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  miscellaneous* miscellaneous::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class miscellaneous (*this, f, c);
  }

  miscellaneous& miscellaneous::
  operator= (const miscellaneous& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->miscellaneous_field_ = x.miscellaneous_field_;
    }

    return *this;
  }

  miscellaneous::
  ~miscellaneous ()
  {
  }

  // miscellaneous_field
  //

  miscellaneous_field::
  miscellaneous_field (const name_type& name)
  : ::xml_schema::string (),
    name_ (name, this)
  {
  }

  miscellaneous_field::
  miscellaneous_field (const char* _xsd_string_base,
                       const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this)
  {
  }

  miscellaneous_field::
  miscellaneous_field (const ::std::string& _xsd_string_base,
                       const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this)
  {
  }

  miscellaneous_field::
  miscellaneous_field (const ::xml_schema::string& _xsd_string_base,
                       const name_type& name)
  : ::xml_schema::string (_xsd_string_base),
    name_ (name, this)
  {
  }

  miscellaneous_field::
  miscellaneous_field (const miscellaneous_field& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  miscellaneous_field::
  miscellaneous_field (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void miscellaneous_field::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  miscellaneous_field* miscellaneous_field::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class miscellaneous_field (*this, f, c);
  }

  miscellaneous_field& miscellaneous_field::
  operator= (const miscellaneous_field& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  miscellaneous_field::
  ~miscellaneous_field ()
  {
  }

  // supports
  //

  supports::
  supports (const type_type& type,
            const element_type& element)
  : ::xml_schema::type (),
    type_ (type, this),
    element_ (element, this),
    attribute_ (this),
    value_ (this)
  {
  }

  supports::
  supports (const supports& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    element_ (x.element_, f, this),
    attribute_ (x.attribute_, f, this),
    value_ (x.value_, f, this)
  {
  }

  supports::
  supports (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    element_ (this),
    attribute_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void supports::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "element" && n.namespace_ ().empty ())
      {
        this->element_.set (element_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "attribute" && n.namespace_ ().empty ())
      {
        this->attribute_.set (attribute_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!element_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "element",
        "");
    }
  }

  supports* supports::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class supports (*this, f, c);
  }

  supports& supports::
  operator= (const supports& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->element_ = x.element_;
      this->attribute_ = x.attribute_;
      this->value_ = x.value_;
    }

    return *this;
  }

  supports::
  ~supports ()
  {
  }

  // appearance
  //

  appearance::
  appearance ()
  : ::xml_schema::type (),
    line_width_ (this),
    note_size_ (this),
    distance_ (this),
    glyph_ (this),
    other_appearance_ (this)
  {
  }

  appearance::
  appearance (const appearance& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    line_width_ (x.line_width_, f, this),
    note_size_ (x.note_size_, f, this),
    distance_ (x.distance_, f, this),
    glyph_ (x.glyph_, f, this),
    other_appearance_ (x.other_appearance_, f, this)
  {
  }

  appearance::
  appearance (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    line_width_ (this),
    note_size_ (this),
    distance_ (this),
    glyph_ (this),
    other_appearance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void appearance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // line-width
      //
      if (n.name () == "line-width" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< line_width_type > r (
          line_width_traits::create (i, f, this));

        this->line_width_.push_back (::std::move (r));
        continue;
      }

      // note-size
      //
      if (n.name () == "note-size" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< note_size_type > r (
          note_size_traits::create (i, f, this));

        this->note_size_.push_back (::std::move (r));
        continue;
      }

      // distance
      //
      if (n.name () == "distance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< distance_type > r (
          distance_traits::create (i, f, this));

        this->distance_.push_back (::std::move (r));
        continue;
      }

      // glyph
      //
      if (n.name () == "glyph" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< glyph_type > r (
          glyph_traits::create (i, f, this));

        this->glyph_.push_back (::std::move (r));
        continue;
      }

      // other-appearance
      //
      if (n.name () == "other-appearance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_appearance_type > r (
          other_appearance_traits::create (i, f, this));

        this->other_appearance_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  appearance* appearance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class appearance (*this, f, c);
  }

  appearance& appearance::
  operator= (const appearance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->line_width_ = x.line_width_;
      this->note_size_ = x.note_size_;
      this->distance_ = x.distance_;
      this->glyph_ = x.glyph_;
      this->other_appearance_ = x.other_appearance_;
    }

    return *this;
  }

  appearance::
  ~appearance ()
  {
  }

  // distance
  //

  distance::
  distance (const ::xml_schema::decimal& _xsd_decimal_base,
            const type_type& type)
  : ::musicxml::tenths (_xsd_decimal_base),
    type_ (type, this)
  {
  }

  distance::
  distance (const distance& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::tenths (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  distance::
  distance (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::tenths (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void distance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  distance* distance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class distance (*this, f, c);
  }

  distance& distance::
  operator= (const distance& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::tenths& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  distance::
  ~distance ()
  {
  }

  // glyph
  //

  glyph::
  glyph (const char* _xsd_nmtoken_base,
         const type_type& type)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    type_ (type, this)
  {
  }

  glyph::
  glyph (const ::std::string& _xsd_nmtoken_base,
         const type_type& type)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    type_ (type, this)
  {
  }

  glyph::
  glyph (const ::xml_schema::nmtoken& _xsd_nmtoken_base,
         const type_type& type)
  : ::musicxml::smufl_glyph_name (_xsd_nmtoken_base),
    type_ (type, this)
  {
  }

  glyph::
  glyph (const glyph& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  glyph::
  glyph (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::musicxml::smufl_glyph_name (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void glyph::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  glyph* glyph::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class glyph (*this, f, c);
  }

  glyph& glyph::
  operator= (const glyph& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::smufl_glyph_name& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  glyph::
  ~glyph ()
  {
  }

  // line_width
  //

  line_width::
  line_width (const ::xml_schema::decimal& _xsd_decimal_base,
              const type_type& type)
  : ::musicxml::tenths (_xsd_decimal_base),
    type_ (type, this)
  {
  }

  line_width::
  line_width (const line_width& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::tenths (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  line_width::
  line_width (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::tenths (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void line_width::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  line_width* line_width::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class line_width (*this, f, c);
  }

  line_width& line_width::
  operator= (const line_width& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::tenths& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  line_width::
  ~line_width ()
  {
  }

  // measure_layout
  //

  measure_layout::
  measure_layout ()
  : ::xml_schema::type (),
    measure_distance_ (this)
  {
  }

  measure_layout::
  measure_layout (const measure_layout& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    measure_distance_ (x.measure_distance_, f, this)
  {
  }

  measure_layout::
  measure_layout (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    measure_distance_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void measure_layout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // measure-distance
      //
      if (n.name () == "measure-distance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_distance_type > r (
          measure_distance_traits::create (i, f, this));

        if (!this->measure_distance_)
        {
          this->measure_distance_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  measure_layout* measure_layout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure_layout (*this, f, c);
  }

  measure_layout& measure_layout::
  operator= (const measure_layout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->measure_distance_ = x.measure_distance_;
    }

    return *this;
  }

  measure_layout::
  ~measure_layout ()
  {
  }

  // note_size
  //

  note_size::
  note_size (const ::xml_schema::decimal& _xsd_decimal_base,
             const type_type& type)
  : ::musicxml::non_negative_decimal (_xsd_decimal_base),
    type_ (type, this)
  {
  }

  note_size::
  note_size (const note_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::non_negative_decimal (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  note_size::
  note_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::non_negative_decimal (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void note_size::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  note_size* note_size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note_size (*this, f, c);
  }

  note_size& note_size::
  operator= (const note_size& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::non_negative_decimal& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  note_size::
  ~note_size ()
  {
  }

  // other_appearance
  //

  other_appearance::
  other_appearance (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this)
  {
  }

  other_appearance::
  other_appearance (const char* _xsd_string_base,
                    const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_appearance::
  other_appearance (const ::std::string& _xsd_string_base,
                    const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_appearance::
  other_appearance (const ::xml_schema::string& _xsd_string_base,
                    const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this)
  {
  }

  other_appearance::
  other_appearance (const other_appearance& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  other_appearance::
  other_appearance (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_appearance::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  other_appearance* other_appearance::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_appearance (*this, f, c);
  }

  other_appearance& other_appearance::
  operator= (const other_appearance& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  other_appearance::
  ~other_appearance ()
  {
  }

  // page_layout
  //

  page_layout::
  page_layout ()
  : ::xml_schema::type (),
    page_height_ (this),
    page_width_ (this),
    page_margins_ (this)
  {
  }

  page_layout::
  page_layout (const page_layout& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    page_height_ (x.page_height_, f, this),
    page_width_ (x.page_width_, f, this),
    page_margins_ (x.page_margins_, f, this)
  {
  }

  page_layout::
  page_layout (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    page_height_ (this),
    page_width_ (this),
    page_margins_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void page_layout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // page-height
      //
      if (n.name () == "page-height" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< page_height_type > r (
          page_height_traits::create (i, f, this));

        if (!this->page_height_)
        {
          this->page_height_.set (::std::move (r));
          continue;
        }
      }

      // page-width
      //
      if (n.name () == "page-width" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< page_width_type > r (
          page_width_traits::create (i, f, this));

        if (!this->page_width_)
        {
          this->page_width_.set (::std::move (r));
          continue;
        }
      }

      // page-margins
      //
      if (n.name () == "page-margins" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< page_margins_type > r (
          page_margins_traits::create (i, f, this));

        this->page_margins_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  page_layout* page_layout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class page_layout (*this, f, c);
  }

  page_layout& page_layout::
  operator= (const page_layout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->page_height_ = x.page_height_;
      this->page_width_ = x.page_width_;
      this->page_margins_ = x.page_margins_;
    }

    return *this;
  }

  page_layout::
  ~page_layout ()
  {
  }

  // page_margins
  //

  page_margins::
  page_margins (const left_margin_type& left_margin,
                const right_margin_type& right_margin,
                const top_margin_type& top_margin,
                const bottom_margin_type& bottom_margin)
  : ::xml_schema::type (),
    left_margin_ (left_margin, this),
    right_margin_ (right_margin, this),
    top_margin_ (top_margin, this),
    bottom_margin_ (bottom_margin, this),
    type_ (this)
  {
  }

  page_margins::
  page_margins (const page_margins& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    left_margin_ (x.left_margin_, f, this),
    right_margin_ (x.right_margin_, f, this),
    top_margin_ (x.top_margin_, f, this),
    bottom_margin_ (x.bottom_margin_, f, this),
    type_ (x.type_, f, this)
  {
  }

  page_margins::
  page_margins (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    left_margin_ (this),
    right_margin_ (this),
    top_margin_ (this),
    bottom_margin_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void page_margins::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // left-margin
      //
      if (n.name () == "left-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< left_margin_type > r (
          left_margin_traits::create (i, f, this));

        if (!left_margin_.present ())
        {
          this->left_margin_.set (::std::move (r));
          continue;
        }
      }

      // right-margin
      //
      if (n.name () == "right-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< right_margin_type > r (
          right_margin_traits::create (i, f, this));

        if (!right_margin_.present ())
        {
          this->right_margin_.set (::std::move (r));
          continue;
        }
      }

      // top-margin
      //
      if (n.name () == "top-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< top_margin_type > r (
          top_margin_traits::create (i, f, this));

        if (!top_margin_.present ())
        {
          this->top_margin_.set (::std::move (r));
          continue;
        }
      }

      // bottom-margin
      //
      if (n.name () == "bottom-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bottom_margin_type > r (
          bottom_margin_traits::create (i, f, this));

        if (!bottom_margin_.present ())
        {
          this->bottom_margin_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!left_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "left-margin",
        "");
    }

    if (!right_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "right-margin",
        "");
    }

    if (!top_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "top-margin",
        "");
    }

    if (!bottom_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bottom-margin",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }
  }

  page_margins* page_margins::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class page_margins (*this, f, c);
  }

  page_margins& page_margins::
  operator= (const page_margins& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->left_margin_ = x.left_margin_;
      this->right_margin_ = x.right_margin_;
      this->top_margin_ = x.top_margin_;
      this->bottom_margin_ = x.bottom_margin_;
      this->type_ = x.type_;
    }

    return *this;
  }

  page_margins::
  ~page_margins ()
  {
  }

  // scaling
  //

  scaling::
  scaling (const millimeters_type& millimeters,
           const tenths_type& tenths)
  : ::xml_schema::type (),
    millimeters_ (millimeters, this),
    tenths_ (tenths, this)
  {
  }

  scaling::
  scaling (const scaling& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    millimeters_ (x.millimeters_, f, this),
    tenths_ (x.tenths_, f, this)
  {
  }

  scaling::
  scaling (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    millimeters_ (this),
    tenths_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void scaling::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // millimeters
      //
      if (n.name () == "millimeters" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< millimeters_type > r (
          millimeters_traits::create (i, f, this));

        if (!millimeters_.present ())
        {
          this->millimeters_.set (::std::move (r));
          continue;
        }
      }

      // tenths
      //
      if (n.name () == "tenths" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tenths_type > r (
          tenths_traits::create (i, f, this));

        if (!tenths_.present ())
        {
          this->tenths_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!millimeters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "millimeters",
        "");
    }

    if (!tenths_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "tenths",
        "");
    }
  }

  scaling* scaling::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class scaling (*this, f, c);
  }

  scaling& scaling::
  operator= (const scaling& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->millimeters_ = x.millimeters_;
      this->tenths_ = x.tenths_;
    }

    return *this;
  }

  scaling::
  ~scaling ()
  {
  }

  // staff_layout
  //

  staff_layout::
  staff_layout ()
  : ::xml_schema::type (),
    staff_distance_ (this),
    number_ (this)
  {
  }

  staff_layout::
  staff_layout (const staff_layout& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    staff_distance_ (x.staff_distance_, f, this),
    number_ (x.number_, f, this)
  {
  }

  staff_layout::
  staff_layout (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    staff_distance_ (this),
    number_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void staff_layout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // staff-distance
      //
      if (n.name () == "staff-distance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_distance_type > r (
          staff_distance_traits::create (i, f, this));

        if (!this->staff_distance_)
        {
          this->staff_distance_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }
  }

  staff_layout* staff_layout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class staff_layout (*this, f, c);
  }

  staff_layout& staff_layout::
  operator= (const staff_layout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->staff_distance_ = x.staff_distance_;
      this->number_ = x.number_;
    }

    return *this;
  }

  staff_layout::
  ~staff_layout ()
  {
  }

  // system_dividers
  //

  system_dividers::
  system_dividers (const left_divider_type& left_divider,
                   const right_divider_type& right_divider)
  : ::xml_schema::type (),
    left_divider_ (left_divider, this),
    right_divider_ (right_divider, this)
  {
  }

  system_dividers::
  system_dividers (::std::unique_ptr< left_divider_type > left_divider,
                   ::std::unique_ptr< right_divider_type > right_divider)
  : ::xml_schema::type (),
    left_divider_ (std::move (left_divider), this),
    right_divider_ (std::move (right_divider), this)
  {
  }

  system_dividers::
  system_dividers (const system_dividers& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    left_divider_ (x.left_divider_, f, this),
    right_divider_ (x.right_divider_, f, this)
  {
  }

  system_dividers::
  system_dividers (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    left_divider_ (this),
    right_divider_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void system_dividers::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // left-divider
      //
      if (n.name () == "left-divider" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< left_divider_type > r (
          left_divider_traits::create (i, f, this));

        if (!left_divider_.present ())
        {
          this->left_divider_.set (::std::move (r));
          continue;
        }
      }

      // right-divider
      //
      if (n.name () == "right-divider" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< right_divider_type > r (
          right_divider_traits::create (i, f, this));

        if (!right_divider_.present ())
        {
          this->right_divider_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!left_divider_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "left-divider",
        "");
    }

    if (!right_divider_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "right-divider",
        "");
    }
  }

  system_dividers* system_dividers::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_dividers (*this, f, c);
  }

  system_dividers& system_dividers::
  operator= (const system_dividers& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->left_divider_ = x.left_divider_;
      this->right_divider_ = x.right_divider_;
    }

    return *this;
  }

  system_dividers::
  ~system_dividers ()
  {
  }

  // system_layout
  //

  system_layout::
  system_layout ()
  : ::xml_schema::type (),
    system_margins_ (this),
    system_distance_ (this),
    top_system_distance_ (this),
    system_dividers_ (this)
  {
  }

  system_layout::
  system_layout (const system_layout& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    system_margins_ (x.system_margins_, f, this),
    system_distance_ (x.system_distance_, f, this),
    top_system_distance_ (x.top_system_distance_, f, this),
    system_dividers_ (x.system_dividers_, f, this)
  {
  }

  system_layout::
  system_layout (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    system_margins_ (this),
    system_distance_ (this),
    top_system_distance_ (this),
    system_dividers_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void system_layout::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // system-margins
      //
      if (n.name () == "system-margins" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< system_margins_type > r (
          system_margins_traits::create (i, f, this));

        if (!this->system_margins_)
        {
          this->system_margins_.set (::std::move (r));
          continue;
        }
      }

      // system-distance
      //
      if (n.name () == "system-distance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< system_distance_type > r (
          system_distance_traits::create (i, f, this));

        if (!this->system_distance_)
        {
          this->system_distance_.set (::std::move (r));
          continue;
        }
      }

      // top-system-distance
      //
      if (n.name () == "top-system-distance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< top_system_distance_type > r (
          top_system_distance_traits::create (i, f, this));

        if (!this->top_system_distance_)
        {
          this->top_system_distance_.set (::std::move (r));
          continue;
        }
      }

      // system-dividers
      //
      if (n.name () == "system-dividers" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< system_dividers_type > r (
          system_dividers_traits::create (i, f, this));

        if (!this->system_dividers_)
        {
          this->system_dividers_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  system_layout* system_layout::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_layout (*this, f, c);
  }

  system_layout& system_layout::
  operator= (const system_layout& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->system_margins_ = x.system_margins_;
      this->system_distance_ = x.system_distance_;
      this->top_system_distance_ = x.top_system_distance_;
      this->system_dividers_ = x.system_dividers_;
    }

    return *this;
  }

  system_layout::
  ~system_layout ()
  {
  }

  // system_margins
  //

  system_margins::
  system_margins (const left_margin_type& left_margin,
                  const right_margin_type& right_margin)
  : ::xml_schema::type (),
    left_margin_ (left_margin, this),
    right_margin_ (right_margin, this)
  {
  }

  system_margins::
  system_margins (const system_margins& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    left_margin_ (x.left_margin_, f, this),
    right_margin_ (x.right_margin_, f, this)
  {
  }

  system_margins::
  system_margins (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    left_margin_ (this),
    right_margin_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void system_margins::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // left-margin
      //
      if (n.name () == "left-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< left_margin_type > r (
          left_margin_traits::create (i, f, this));

        if (!left_margin_.present ())
        {
          this->left_margin_.set (::std::move (r));
          continue;
        }
      }

      // right-margin
      //
      if (n.name () == "right-margin" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< right_margin_type > r (
          right_margin_traits::create (i, f, this));

        if (!right_margin_.present ())
        {
          this->right_margin_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!left_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "left-margin",
        "");
    }

    if (!right_margin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "right-margin",
        "");
    }
  }

  system_margins* system_margins::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class system_margins (*this, f, c);
  }

  system_margins& system_margins::
  operator= (const system_margins& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->left_margin_ = x.left_margin_;
      this->right_margin_ = x.right_margin_;
    }

    return *this;
  }

  system_margins::
  ~system_margins ()
  {
  }

  // bookmark
  //

  bookmark::
  bookmark (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this),
    name_ (this),
    element_ (this),
    position_ (this)
  {
  }

  bookmark::
  bookmark (const bookmark& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this),
    element_ (x.element_, f, this),
    position_ (x.position_, f, this)
  {
  }

  bookmark::
  bookmark (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this),
    name_ (this),
    element_ (this),
    position_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void bookmark::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "element" && n.namespace_ ().empty ())
      {
        this->element_.set (element_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "position" && n.namespace_ ().empty ())
      {
        this->position_.set (position_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  bookmark* bookmark::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bookmark (*this, f, c);
  }

  bookmark& bookmark::
  operator= (const bookmark& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
      this->name_ = x.name_;
      this->element_ = x.element_;
      this->position_ = x.position_;
    }

    return *this;
  }

  bookmark::
  ~bookmark ()
  {
  }

  // link
  //

  const link::type_type link::type_default_value_ (
    "simple");

  const link::show_type link::show_default_value_ (
    "replace");

  const link::actuate_type link::actuate_default_value_ (
    "onRequest");

  link::
  link (const href_type& href)
  : ::xml_schema::type (),
    href_ (href, this),
    type_ (type_default_value (), this),
    role_ (this),
    title_ (this),
    show_ (show_default_value (), this),
    actuate_ (actuate_default_value (), this),
    name_ (this),
    element_ (this),
    position_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this)
  {
  }

  link::
  link (const link& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    href_ (x.href_, f, this),
    type_ (x.type_, f, this),
    role_ (x.role_, f, this),
    title_ (x.title_, f, this),
    show_ (x.show_, f, this),
    actuate_ (x.actuate_, f, this),
    name_ (x.name_, f, this),
    element_ (x.element_, f, this),
    position_ (x.position_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this)
  {
  }

  link::
  link (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    href_ (this),
    type_ (this),
    role_ (this),
    title_ (this),
    show_ (this),
    actuate_ (this),
    name_ (this),
    element_ (this),
    position_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void link::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "role" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->role_.set (role_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "title" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->title_.set (title_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->show_.set (show_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "actuate" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->actuate_.set (actuate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "element" && n.namespace_ ().empty ())
      {
        this->element_.set (element_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "position" && n.namespace_ ().empty ())
      {
        this->position_.set (position_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "http://www.w3.org/1999/xlink");
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!show_.present ())
    {
      this->show_.set (show_default_value ());
    }

    if (!actuate_.present ())
    {
      this->actuate_.set (actuate_default_value ());
    }
  }

  link* link::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class link (*this, f, c);
  }

  link& link::
  operator= (const link& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->href_ = x.href_;
      this->type_ = x.type_;
      this->role_ = x.role_;
      this->title_ = x.title_;
      this->show_ = x.show_;
      this->actuate_ = x.actuate_;
      this->name_ = x.name_;
      this->element_ = x.element_;
      this->position_ = x.position_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
    }

    return *this;
  }

  link::
  ~link ()
  {
  }

  // accidental
  //

  accidental::
  accidental (::musicxml::accidental_value::value _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    cautionary_ (this),
    editorial_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  accidental::
  accidental (const char* _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    cautionary_ (this),
    editorial_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  accidental::
  accidental (const ::std::string& _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    cautionary_ (this),
    editorial_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  accidental::
  accidental (const ::musicxml::accidental_value& _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    cautionary_ (this),
    editorial_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  accidental::
  accidental (const accidental& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::accidental_value (x, f, c),
    cautionary_ (x.cautionary_, f, this),
    editorial_ (x.editorial_, f, this),
    parentheses_ (x.parentheses_, f, this),
    bracket_ (x.bracket_, f, this),
    size_ (x.size_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  accidental::
  accidental (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::musicxml::accidental_value (e, f | ::xml_schema::flags::base, c),
    cautionary_ (this),
    editorial_ (this),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void accidental::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "cautionary" && n.namespace_ ().empty ())
      {
        this->cautionary_.set (cautionary_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "editorial" && n.namespace_ ().empty ())
      {
        this->editorial_.set (editorial_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        this->bracket_.set (bracket_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  accidental* accidental::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accidental (*this, f, c);
  }

  accidental& accidental::
  operator= (const accidental& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::accidental_value& > (*this) = x;
      this->cautionary_ = x.cautionary_;
      this->editorial_ = x.editorial_;
      this->parentheses_ = x.parentheses_;
      this->bracket_ = x.bracket_;
      this->size_ = x.size_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  accidental::
  ~accidental ()
  {
  }

  // accidental_mark
  //

  accidental_mark::
  accidental_mark (::musicxml::accidental_value::value _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  accidental_mark::
  accidental_mark (const char* _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  accidental_mark::
  accidental_mark (const ::std::string& _xsd_string_base)
  : ::musicxml::accidental_value (_xsd_string_base),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  accidental_mark::
  accidental_mark (const ::musicxml::accidental_value& _xsd_accidental_value_base)
  : ::musicxml::accidental_value (_xsd_accidental_value_base),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  accidental_mark::
  accidental_mark (const accidental_mark& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::accidental_value (x, f, c),
    parentheses_ (x.parentheses_, f, this),
    bracket_ (x.bracket_, f, this),
    size_ (x.size_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this),
    id_ (x.id_, f, this)
  {
  }

  accidental_mark::
  accidental_mark (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::musicxml::accidental_value (e, f | ::xml_schema::flags::base, c),
    parentheses_ (this),
    bracket_ (this),
    size_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void accidental_mark::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        this->bracket_.set (bracket_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  accidental_mark* accidental_mark::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accidental_mark (*this, f, c);
  }

  accidental_mark& accidental_mark::
  operator= (const accidental_mark& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::accidental_value& > (*this) = x;
      this->parentheses_ = x.parentheses_;
      this->bracket_ = x.bracket_;
      this->size_ = x.size_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
      this->id_ = x.id_;
    }

    return *this;
  }

  accidental_mark::
  ~accidental_mark ()
  {
  }

  // arpeggiate
  //

  arpeggiate::
  arpeggiate ()
  : ::xml_schema::type (),
    number_ (this),
    direction_ (this),
    unbroken_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    id_ (this)
  {
  }

  arpeggiate::
  arpeggiate (const arpeggiate& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this),
    direction_ (x.direction_, f, this),
    unbroken_ (x.unbroken_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  arpeggiate::
  arpeggiate (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    direction_ (this),
    unbroken_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void arpeggiate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        this->direction_.set (direction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "unbroken" && n.namespace_ ().empty ())
      {
        this->unbroken_.set (unbroken_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  arpeggiate* arpeggiate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arpeggiate (*this, f, c);
  }

  arpeggiate& arpeggiate::
  operator= (const arpeggiate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
      this->direction_ = x.direction_;
      this->unbroken_ = x.unbroken_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  arpeggiate::
  ~arpeggiate ()
  {
  }

  // articulations
  //

  articulations::
  articulations ()
  : ::xml_schema::type (),
    accent_ (this),
    strong_accent_ (this),
    staccato_ (this),
    tenuto_ (this),
    detached_legato_ (this),
    staccatissimo_ (this),
    spiccato_ (this),
    scoop_ (this),
    plop_ (this),
    doit_ (this),
    falloff_ (this),
    breath_mark_ (this),
    caesura_ (this),
    stress_ (this),
    unstress_ (this),
    soft_accent_ (this),
    other_articulation_ (this),
    id_ (this)
  {
  }

  articulations::
  articulations (const articulations& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    accent_ (x.accent_, f, this),
    strong_accent_ (x.strong_accent_, f, this),
    staccato_ (x.staccato_, f, this),
    tenuto_ (x.tenuto_, f, this),
    detached_legato_ (x.detached_legato_, f, this),
    staccatissimo_ (x.staccatissimo_, f, this),
    spiccato_ (x.spiccato_, f, this),
    scoop_ (x.scoop_, f, this),
    plop_ (x.plop_, f, this),
    doit_ (x.doit_, f, this),
    falloff_ (x.falloff_, f, this),
    breath_mark_ (x.breath_mark_, f, this),
    caesura_ (x.caesura_, f, this),
    stress_ (x.stress_, f, this),
    unstress_ (x.unstress_, f, this),
    soft_accent_ (x.soft_accent_, f, this),
    other_articulation_ (x.other_articulation_, f, this),
    id_ (x.id_, f, this)
  {
  }

  articulations::
  articulations (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    accent_ (this),
    strong_accent_ (this),
    staccato_ (this),
    tenuto_ (this),
    detached_legato_ (this),
    staccatissimo_ (this),
    spiccato_ (this),
    scoop_ (this),
    plop_ (this),
    doit_ (this),
    falloff_ (this),
    breath_mark_ (this),
    caesura_ (this),
    stress_ (this),
    unstress_ (this),
    soft_accent_ (this),
    other_articulation_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void articulations::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accent
      //
      if (n.name () == "accent" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accent_type > r (
          accent_traits::create (i, f, this));

        this->accent_.push_back (::std::move (r));
        continue;
      }

      // strong-accent
      //
      if (n.name () == "strong-accent" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< strong_accent_type > r (
          strong_accent_traits::create (i, f, this));

        this->strong_accent_.push_back (::std::move (r));
        continue;
      }

      // staccato
      //
      if (n.name () == "staccato" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staccato_type > r (
          staccato_traits::create (i, f, this));

        this->staccato_.push_back (::std::move (r));
        continue;
      }

      // tenuto
      //
      if (n.name () == "tenuto" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tenuto_type > r (
          tenuto_traits::create (i, f, this));

        this->tenuto_.push_back (::std::move (r));
        continue;
      }

      // detached-legato
      //
      if (n.name () == "detached-legato" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< detached_legato_type > r (
          detached_legato_traits::create (i, f, this));

        this->detached_legato_.push_back (::std::move (r));
        continue;
      }

      // staccatissimo
      //
      if (n.name () == "staccatissimo" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staccatissimo_type > r (
          staccatissimo_traits::create (i, f, this));

        this->staccatissimo_.push_back (::std::move (r));
        continue;
      }

      // spiccato
      //
      if (n.name () == "spiccato" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< spiccato_type > r (
          spiccato_traits::create (i, f, this));

        this->spiccato_.push_back (::std::move (r));
        continue;
      }

      // scoop
      //
      if (n.name () == "scoop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< scoop_type > r (
          scoop_traits::create (i, f, this));

        this->scoop_.push_back (::std::move (r));
        continue;
      }

      // plop
      //
      if (n.name () == "plop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< plop_type > r (
          plop_traits::create (i, f, this));

        this->plop_.push_back (::std::move (r));
        continue;
      }

      // doit
      //
      if (n.name () == "doit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< doit_type > r (
          doit_traits::create (i, f, this));

        this->doit_.push_back (::std::move (r));
        continue;
      }

      // falloff
      //
      if (n.name () == "falloff" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< falloff_type > r (
          falloff_traits::create (i, f, this));

        this->falloff_.push_back (::std::move (r));
        continue;
      }

      // breath-mark
      //
      if (n.name () == "breath-mark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< breath_mark_type > r (
          breath_mark_traits::create (i, f, this));

        this->breath_mark_.push_back (::std::move (r));
        continue;
      }

      // caesura
      //
      if (n.name () == "caesura" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< caesura_type > r (
          caesura_traits::create (i, f, this));

        this->caesura_.push_back (::std::move (r));
        continue;
      }

      // stress
      //
      if (n.name () == "stress" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stress_type > r (
          stress_traits::create (i, f, this));

        this->stress_.push_back (::std::move (r));
        continue;
      }

      // unstress
      //
      if (n.name () == "unstress" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< unstress_type > r (
          unstress_traits::create (i, f, this));

        this->unstress_.push_back (::std::move (r));
        continue;
      }

      // soft-accent
      //
      if (n.name () == "soft-accent" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< soft_accent_type > r (
          soft_accent_traits::create (i, f, this));

        this->soft_accent_.push_back (::std::move (r));
        continue;
      }

      // other-articulation
      //
      if (n.name () == "other-articulation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_articulation_type > r (
          other_articulation_traits::create (i, f, this));

        this->other_articulation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  articulations* articulations::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class articulations (*this, f, c);
  }

  articulations& articulations::
  operator= (const articulations& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->accent_ = x.accent_;
      this->strong_accent_ = x.strong_accent_;
      this->staccato_ = x.staccato_;
      this->tenuto_ = x.tenuto_;
      this->detached_legato_ = x.detached_legato_;
      this->staccatissimo_ = x.staccatissimo_;
      this->spiccato_ = x.spiccato_;
      this->scoop_ = x.scoop_;
      this->plop_ = x.plop_;
      this->doit_ = x.doit_;
      this->falloff_ = x.falloff_;
      this->breath_mark_ = x.breath_mark_;
      this->caesura_ = x.caesura_;
      this->stress_ = x.stress_;
      this->unstress_ = x.unstress_;
      this->soft_accent_ = x.soft_accent_;
      this->other_articulation_ = x.other_articulation_;
      this->id_ = x.id_;
    }

    return *this;
  }

  articulations::
  ~articulations ()
  {
  }

  // arrow
  //

  arrow::
  arrow ()
  : ::xml_schema::type (),
    arrow_direction_ (this),
    arrow_style_ (this),
    arrowhead_ (this),
    circular_arrow_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  arrow::
  arrow (const arrow& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    arrow_direction_ (x.arrow_direction_, f, this),
    arrow_style_ (x.arrow_style_, f, this),
    arrowhead_ (x.arrowhead_, f, this),
    circular_arrow_ (x.circular_arrow_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  arrow::
  arrow (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    arrow_direction_ (this),
    arrow_style_ (this),
    arrowhead_ (this),
    circular_arrow_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void arrow::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // arrow-direction
      //
      if (n.name () == "arrow-direction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< arrow_direction_type > r (
          arrow_direction_traits::create (i, f, this));

        if (!this->arrow_direction_)
        {
          this->arrow_direction_.set (::std::move (r));
          continue;
        }
      }

      // arrow-style
      //
      if (n.name () == "arrow-style" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< arrow_style_type > r (
          arrow_style_traits::create (i, f, this));

        if (!this->arrow_style_)
        {
          this->arrow_style_.set (::std::move (r));
          continue;
        }
      }

      // arrowhead
      //
      if (n.name () == "arrowhead" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< arrowhead_type > r (
          arrowhead_traits::create (i, f, this));

        if (!this->arrowhead_)
        {
          this->arrowhead_.set (::std::move (r));
          continue;
        }
      }

      // circular-arrow
      //
      if (n.name () == "circular-arrow" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< circular_arrow_type > r (
          circular_arrow_traits::create (i, f, this));

        if (!this->circular_arrow_)
        {
          this->circular_arrow_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  arrow* arrow::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class arrow (*this, f, c);
  }

  arrow& arrow::
  operator= (const arrow& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->arrow_direction_ = x.arrow_direction_;
      this->arrow_style_ = x.arrow_style_;
      this->arrowhead_ = x.arrowhead_;
      this->circular_arrow_ = x.circular_arrow_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  arrow::
  ~arrow ()
  {
  }

  // assess
  //

  assess::
  assess (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    player_ (this),
    time_only_ (this)
  {
  }

  assess::
  assess (const assess& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    player_ (x.player_, f, this),
    time_only_ (x.time_only_, f, this)
  {
  }

  assess::
  assess (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    player_ (this),
    time_only_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void assess::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "player" && n.namespace_ ().empty ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  assess* assess::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class assess (*this, f, c);
  }

  assess& assess::
  operator= (const assess& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->player_ = x.player_;
      this->time_only_ = x.time_only_;
    }

    return *this;
  }

  assess::
  ~assess ()
  {
  }

  // backup
  //

  backup::
  backup (const duration_type& duration)
  : ::xml_schema::type (),
    duration_ (duration, this),
    footnote_ (this),
    level_ (this)
  {
  }

  backup::
  backup (const backup& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    duration_ (x.duration_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this)
  {
  }

  backup::
  backup (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    duration_ (this),
    footnote_ (this),
    level_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void backup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // duration
      //
      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!duration_.present ())
        {
          this->duration_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "duration",
        "");
    }
  }

  backup* backup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class backup (*this, f, c);
  }

  backup& backup::
  operator= (const backup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->duration_ = x.duration_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
    }

    return *this;
  }

  backup::
  ~backup ()
  {
  }

  // beam
  //

  beam::
  beam (::musicxml::beam_value::value _xsd_beam_value_base)
  : ::musicxml::beam_value (_xsd_beam_value_base),
    number_ (number_default_value (), this),
    repeater_ (this),
    fan_ (this),
    color_ (this),
    id_ (this)
  {
  }

  beam::
  beam (const char* _xsd_string_base)
  : ::musicxml::beam_value (_xsd_string_base),
    number_ (number_default_value (), this),
    repeater_ (this),
    fan_ (this),
    color_ (this),
    id_ (this)
  {
  }

  beam::
  beam (const ::std::string& _xsd_string_base)
  : ::musicxml::beam_value (_xsd_string_base),
    number_ (number_default_value (), this),
    repeater_ (this),
    fan_ (this),
    color_ (this),
    id_ (this)
  {
  }

  beam::
  beam (const ::musicxml::beam_value& _xsd_beam_value_base)
  : ::musicxml::beam_value (_xsd_beam_value_base),
    number_ (number_default_value (), this),
    repeater_ (this),
    fan_ (this),
    color_ (this),
    id_ (this)
  {
  }

  beam::
  beam (const beam& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::beam_value (x, f, c),
    number_ (x.number_, f, this),
    repeater_ (x.repeater_, f, this),
    fan_ (x.fan_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  beam::
  beam (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::beam_value (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    repeater_ (this),
    fan_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void beam::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "repeater" && n.namespace_ ().empty ())
      {
        this->repeater_.set (repeater_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fan" && n.namespace_ ().empty ())
      {
        this->fan_.set (fan_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  beam* beam::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class beam (*this, f, c);
  }

  beam& beam::
  operator= (const beam& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::beam_value& > (*this) = x;
      this->number_ = x.number_;
      this->repeater_ = x.repeater_;
      this->fan_ = x.fan_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  beam::
  ~beam ()
  {
  }

  // bend
  //

  bend::
  bend (const bend_alter_type& bend_alter)
  : ::xml_schema::type (),
    bend_alter_ (bend_alter, this),
    pre_bend_ (this),
    release_ (this),
    with_bar_ (this),
    shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this)
  {
  }

  bend::
  bend (const bend& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    bend_alter_ (x.bend_alter_, f, this),
    pre_bend_ (x.pre_bend_, f, this),
    release_ (x.release_, f, this),
    with_bar_ (x.with_bar_, f, this),
    shape_ (x.shape_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    accelerate_ (x.accelerate_, f, this),
    beats_ (x.beats_, f, this),
    first_beat_ (x.first_beat_, f, this),
    last_beat_ (x.last_beat_, f, this)
  {
  }

  bend::
  bend (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    bend_alter_ (this),
    pre_bend_ (this),
    release_ (this),
    with_bar_ (this),
    shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void bend::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // bend-alter
      //
      if (n.name () == "bend-alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bend_alter_type > r (
          bend_alter_traits::create (i, f, this));

        if (!bend_alter_.present ())
        {
          this->bend_alter_.set (::std::move (r));
          continue;
        }
      }

      // pre-bend
      //
      if (n.name () == "pre-bend" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pre_bend_type > r (
          pre_bend_traits::create (i, f, this));

        if (!this->pre_bend_)
        {
          this->pre_bend_.set (::std::move (r));
          continue;
        }
      }

      // release
      //
      if (n.name () == "release" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< release_type > r (
          release_traits::create (i, f, this));

        if (!this->release_)
        {
          this->release_.set (::std::move (r));
          continue;
        }
      }

      // with-bar
      //
      if (n.name () == "with-bar" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< with_bar_type > r (
          with_bar_traits::create (i, f, this));

        if (!this->with_bar_)
        {
          this->with_bar_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!bend_alter_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bend-alter",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "shape" && n.namespace_ ().empty ())
      {
        this->shape_.set (shape_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accelerate" && n.namespace_ ().empty ())
      {
        this->accelerate_.set (accelerate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        this->beats_.set (beats_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "first-beat" && n.namespace_ ().empty ())
      {
        this->first_beat_.set (first_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "last-beat" && n.namespace_ ().empty ())
      {
        this->last_beat_.set (last_beat_traits::create (i, f, this));
        continue;
      }
    }
  }

  bend* bend::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bend (*this, f, c);
  }

  bend& bend::
  operator= (const bend& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->bend_alter_ = x.bend_alter_;
      this->pre_bend_ = x.pre_bend_;
      this->release_ = x.release_;
      this->with_bar_ = x.with_bar_;
      this->shape_ = x.shape_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->accelerate_ = x.accelerate_;
      this->beats_ = x.beats_;
      this->first_beat_ = x.first_beat_;
      this->last_beat_ = x.last_beat_;
    }

    return *this;
  }

  bend::
  ~bend ()
  {
  }

  // breath_mark
  //

  breath_mark::
  breath_mark (::musicxml::breath_mark_value::value _xsd_breath_mark_value_base)
  : ::musicxml::breath_mark_value (_xsd_breath_mark_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  breath_mark::
  breath_mark (const char* _xsd_string_base)
  : ::musicxml::breath_mark_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  breath_mark::
  breath_mark (const ::std::string& _xsd_string_base)
  : ::musicxml::breath_mark_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  breath_mark::
  breath_mark (const ::musicxml::breath_mark_value& _xsd_breath_mark_value_base)
  : ::musicxml::breath_mark_value (_xsd_breath_mark_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  breath_mark::
  breath_mark (const breath_mark& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::breath_mark_value (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  breath_mark::
  breath_mark (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::breath_mark_value (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void breath_mark::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  breath_mark* breath_mark::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class breath_mark (*this, f, c);
  }

  breath_mark& breath_mark::
  operator= (const breath_mark& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::breath_mark_value& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  breath_mark::
  ~breath_mark ()
  {
  }

  // caesura
  //

  caesura::
  caesura (::musicxml::caesura_value::value _xsd_caesura_value_base)
  : ::musicxml::caesura_value (_xsd_caesura_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  caesura::
  caesura (const char* _xsd_string_base)
  : ::musicxml::caesura_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  caesura::
  caesura (const ::std::string& _xsd_string_base)
  : ::musicxml::caesura_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  caesura::
  caesura (const ::musicxml::caesura_value& _xsd_caesura_value_base)
  : ::musicxml::caesura_value (_xsd_caesura_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  caesura::
  caesura (const caesura& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::caesura_value (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  caesura::
  caesura (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::caesura_value (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void caesura::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  caesura* caesura::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class caesura (*this, f, c);
  }

  caesura& caesura::
  operator= (const caesura& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::caesura_value& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  caesura::
  ~caesura ()
  {
  }

  // elision
  //

  elision::
  elision ()
  : ::xml_schema::string (),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  elision::
  elision (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  elision::
  elision (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  elision::
  elision (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  elision::
  elision (const elision& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  elision::
  elision (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void elision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  elision* elision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class elision (*this, f, c);
  }

  elision& elision::
  operator= (const elision& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  elision::
  ~elision ()
  {
  }

  // empty_line
  //

  empty_line::
  empty_line ()
  : ::xml_schema::type (),
    line_shape_ (this),
    line_type_ (this),
    line_length_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  empty_line::
  empty_line (const empty_line& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    line_shape_ (x.line_shape_, f, this),
    line_type_ (x.line_type_, f, this),
    line_length_ (x.line_length_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  empty_line::
  empty_line (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    line_shape_ (this),
    line_type_ (this),
    line_length_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_line::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "line-shape" && n.namespace_ ().empty ())
      {
        this->line_shape_.set (line_shape_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-length" && n.namespace_ ().empty ())
      {
        this->line_length_.set (line_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_line* empty_line::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_line (*this, f, c);
  }

  empty_line& empty_line::
  operator= (const empty_line& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->line_shape_ = x.line_shape_;
      this->line_type_ = x.line_type_;
      this->line_length_ = x.line_length_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  empty_line::
  ~empty_line ()
  {
  }

  // extend
  //

  extend::
  extend ()
  : ::xml_schema::type (),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  extend::
  extend (const extend& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this)
  {
  }

  extend::
  extend (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void extend::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  extend* extend::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class extend (*this, f, c);
  }

  extend& extend::
  operator= (const extend& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
    }

    return *this;
  }

  extend::
  ~extend ()
  {
  }

  // figure
  //

  figure::
  figure ()
  : ::xml_schema::type (),
    prefix_ (this),
    figure_number_ (this),
    suffix_ (this),
    extend_ (this),
    footnote_ (this),
    level_ (this)
  {
  }

  figure::
  figure (const figure& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    prefix_ (x.prefix_, f, this),
    figure_number_ (x.figure_number_, f, this),
    suffix_ (x.suffix_, f, this),
    extend_ (x.extend_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this)
  {
  }

  figure::
  figure (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    prefix_ (this),
    figure_number_ (this),
    suffix_ (this),
    extend_ (this),
    footnote_ (this),
    level_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void figure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // prefix
      //
      if (n.name () == "prefix" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< prefix_type > r (
          prefix_traits::create (i, f, this));

        if (!this->prefix_)
        {
          this->prefix_.set (::std::move (r));
          continue;
        }
      }

      // figure-number
      //
      if (n.name () == "figure-number" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< figure_number_type > r (
          figure_number_traits::create (i, f, this));

        if (!this->figure_number_)
        {
          this->figure_number_.set (::std::move (r));
          continue;
        }
      }

      // suffix
      //
      if (n.name () == "suffix" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< suffix_type > r (
          suffix_traits::create (i, f, this));

        if (!this->suffix_)
        {
          this->suffix_.set (::std::move (r));
          continue;
        }
      }

      // extend
      //
      if (n.name () == "extend" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< extend_type > r (
          extend_traits::create (i, f, this));

        if (!this->extend_)
        {
          this->extend_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  figure* figure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class figure (*this, f, c);
  }

  figure& figure::
  operator= (const figure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->prefix_ = x.prefix_;
      this->figure_number_ = x.figure_number_;
      this->suffix_ = x.suffix_;
      this->extend_ = x.extend_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
    }

    return *this;
  }

  figure::
  ~figure ()
  {
  }

  // figured_bass
  //

  figured_bass::
  figured_bass ()
  : ::xml_schema::type (),
    figure_ (this),
    duration_ (this),
    footnote_ (this),
    level_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    placement_ (this),
    print_object_ (this),
    print_dot_ (this),
    print_spacing_ (this),
    print_lyric_ (this),
    parentheses_ (this),
    id_ (this)
  {
  }

  figured_bass::
  figured_bass (const figured_bass& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    figure_ (x.figure_, f, this),
    duration_ (x.duration_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    halign_ (x.halign_, f, this),
    valign_ (x.valign_, f, this),
    placement_ (x.placement_, f, this),
    print_object_ (x.print_object_, f, this),
    print_dot_ (x.print_dot_, f, this),
    print_spacing_ (x.print_spacing_, f, this),
    print_lyric_ (x.print_lyric_, f, this),
    parentheses_ (x.parentheses_, f, this),
    id_ (x.id_, f, this)
  {
  }

  figured_bass::
  figured_bass (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    figure_ (this),
    duration_ (this),
    footnote_ (this),
    level_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    halign_ (this),
    valign_ (this),
    placement_ (this),
    print_object_ (this),
    print_dot_ (this),
    print_spacing_ (this),
    print_lyric_ (this),
    parentheses_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void figured_bass::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // figure
      //
      if (n.name () == "figure" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< figure_type > r (
          figure_traits::create (i, f, this));

        this->figure_.push_back (::std::move (r));
        continue;
      }

      // duration
      //
      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!this->duration_)
        {
          this->duration_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "halign" && n.namespace_ ().empty ())
      {
        this->halign_.set (halign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "valign" && n.namespace_ ().empty ())
      {
        this->valign_.set (valign_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-dot" && n.namespace_ ().empty ())
      {
        this->print_dot_.set (print_dot_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-spacing" && n.namespace_ ().empty ())
      {
        this->print_spacing_.set (print_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-lyric" && n.namespace_ ().empty ())
      {
        this->print_lyric_.set (print_lyric_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  figured_bass* figured_bass::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class figured_bass (*this, f, c);
  }

  figured_bass& figured_bass::
  operator= (const figured_bass& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->figure_ = x.figure_;
      this->duration_ = x.duration_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->halign_ = x.halign_;
      this->valign_ = x.valign_;
      this->placement_ = x.placement_;
      this->print_object_ = x.print_object_;
      this->print_dot_ = x.print_dot_;
      this->print_spacing_ = x.print_spacing_;
      this->print_lyric_ = x.print_lyric_;
      this->parentheses_ = x.parentheses_;
      this->id_ = x.id_;
    }

    return *this;
  }

  figured_bass::
  ~figured_bass ()
  {
  }

  // forward
  //

  forward::
  forward (const duration_type& duration)
  : ::xml_schema::type (),
    duration_ (duration, this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    staff_ (this)
  {
  }

  forward::
  forward (const forward& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    duration_ (x.duration_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    voice_ (x.voice_, f, this),
    staff_ (x.staff_, f, this)
  {
  }

  forward::
  forward (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    duration_ (this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    staff_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void forward::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // duration
      //
      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!duration_.present ())
        {
          this->duration_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // voice
      //
      if (n.name () == "voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< voice_type > r (
          voice_traits::create (i, f, this));

        if (!this->voice_)
        {
          this->voice_.set (::std::move (r));
          continue;
        }
      }

      // staff
      //
      if (n.name () == "staff" && n.namespace_ ().empty ())
      {
        if (!this->staff_)
        {
          this->staff_.set (staff_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "duration",
        "");
    }
  }

  forward* forward::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class forward (*this, f, c);
  }

  forward& forward::
  operator= (const forward& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->duration_ = x.duration_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->voice_ = x.voice_;
      this->staff_ = x.staff_;
    }

    return *this;
  }

  forward::
  ~forward ()
  {
  }

  // glissando
  //

  glissando::
  glissando (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  glissando::
  glissando (const char* _xsd_string_base,
             const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  glissando::
  glissando (const ::std::string& _xsd_string_base,
             const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  glissando::
  glissando (const ::xml_schema::string& _xsd_string_base,
             const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
  }

  glissando::
  glissando (const glissando& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  glissando::
  glissando (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void glissando::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  glissando* glissando::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class glissando (*this, f, c);
  }

  glissando& glissando::
  operator= (const glissando& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  glissando::
  ~glissando ()
  {
  }

  // grace
  //

  grace::
  grace ()
  : ::xml_schema::type (),
    steal_time_previous_ (this),
    steal_time_following_ (this),
    make_time_ (this),
    slash_ (this)
  {
  }

  grace::
  grace (const grace& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    steal_time_previous_ (x.steal_time_previous_, f, this),
    steal_time_following_ (x.steal_time_following_, f, this),
    make_time_ (x.make_time_, f, this),
    slash_ (x.slash_, f, this)
  {
  }

  grace::
  grace (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    steal_time_previous_ (this),
    steal_time_following_ (this),
    make_time_ (this),
    slash_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void grace::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "steal-time-previous" && n.namespace_ ().empty ())
      {
        this->steal_time_previous_.set (steal_time_previous_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "steal-time-following" && n.namespace_ ().empty ())
      {
        this->steal_time_following_.set (steal_time_following_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "make-time" && n.namespace_ ().empty ())
      {
        this->make_time_.set (make_time_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "slash" && n.namespace_ ().empty ())
      {
        this->slash_.set (slash_traits::create (i, f, this));
        continue;
      }
    }
  }

  grace* grace::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class grace (*this, f, c);
  }

  grace& grace::
  operator= (const grace& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->steal_time_previous_ = x.steal_time_previous_;
      this->steal_time_following_ = x.steal_time_following_;
      this->make_time_ = x.make_time_;
      this->slash_ = x.slash_;
    }

    return *this;
  }

  grace::
  ~grace ()
  {
  }

  // hammer_on_pull_off
  //

  hammer_on_pull_off::
  hammer_on_pull_off (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    number_ (number_default_value (), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hammer_on_pull_off::
  hammer_on_pull_off (const char* _xsd_string_base,
                      const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hammer_on_pull_off::
  hammer_on_pull_off (const ::std::string& _xsd_string_base,
                      const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hammer_on_pull_off::
  hammer_on_pull_off (const ::xml_schema::string& _xsd_string_base,
                      const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hammer_on_pull_off::
  hammer_on_pull_off (const hammer_on_pull_off& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  hammer_on_pull_off::
  hammer_on_pull_off (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void hammer_on_pull_off::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  hammer_on_pull_off* hammer_on_pull_off::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hammer_on_pull_off (*this, f, c);
  }

  hammer_on_pull_off& hammer_on_pull_off::
  operator= (const hammer_on_pull_off& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  hammer_on_pull_off::
  ~hammer_on_pull_off ()
  {
  }

  // handbell
  //

  handbell::
  handbell (::musicxml::handbell_value::value _xsd_handbell_value_base)
  : ::musicxml::handbell_value (_xsd_handbell_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  handbell::
  handbell (const char* _xsd_string_base)
  : ::musicxml::handbell_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  handbell::
  handbell (const ::std::string& _xsd_string_base)
  : ::musicxml::handbell_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  handbell::
  handbell (const ::musicxml::handbell_value& _xsd_handbell_value_base)
  : ::musicxml::handbell_value (_xsd_handbell_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  handbell::
  handbell (const handbell& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::handbell_value (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  handbell::
  handbell (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::handbell_value (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void handbell::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  handbell* handbell::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class handbell (*this, f, c);
  }

  handbell& handbell::
  operator= (const handbell& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::handbell_value& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  handbell::
  ~handbell ()
  {
  }

  // harmon_closed
  //

  harmon_closed::
  harmon_closed (::musicxml::harmon_closed_value::value _xsd_harmon_closed_value_base)
  : ::musicxml::harmon_closed_value (_xsd_harmon_closed_value_base),
    location_ (this)
  {
  }

  harmon_closed::
  harmon_closed (const char* _xsd_string_base)
  : ::musicxml::harmon_closed_value (_xsd_string_base),
    location_ (this)
  {
  }

  harmon_closed::
  harmon_closed (const ::std::string& _xsd_string_base)
  : ::musicxml::harmon_closed_value (_xsd_string_base),
    location_ (this)
  {
  }

  harmon_closed::
  harmon_closed (const ::musicxml::harmon_closed_value& _xsd_harmon_closed_value_base)
  : ::musicxml::harmon_closed_value (_xsd_harmon_closed_value_base),
    location_ (this)
  {
  }

  harmon_closed::
  harmon_closed (const harmon_closed& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::harmon_closed_value (x, f, c),
    location_ (x.location_, f, this)
  {
  }

  harmon_closed::
  harmon_closed (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::harmon_closed_value (e, f | ::xml_schema::flags::base, c),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void harmon_closed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }
  }

  harmon_closed* harmon_closed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmon_closed (*this, f, c);
  }

  harmon_closed& harmon_closed::
  operator= (const harmon_closed& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::harmon_closed_value& > (*this) = x;
      this->location_ = x.location_;
    }

    return *this;
  }

  harmon_closed::
  ~harmon_closed ()
  {
  }

  // harmon_mute
  //

  harmon_mute::
  harmon_mute (const harmon_closed_type& harmon_closed)
  : ::xml_schema::type (),
    harmon_closed_ (harmon_closed, this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  harmon_mute::
  harmon_mute (::std::unique_ptr< harmon_closed_type > harmon_closed)
  : ::xml_schema::type (),
    harmon_closed_ (std::move (harmon_closed), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  harmon_mute::
  harmon_mute (const harmon_mute& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    harmon_closed_ (x.harmon_closed_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  harmon_mute::
  harmon_mute (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    harmon_closed_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void harmon_mute::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // harmon-closed
      //
      if (n.name () == "harmon-closed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harmon_closed_type > r (
          harmon_closed_traits::create (i, f, this));

        if (!harmon_closed_.present ())
        {
          this->harmon_closed_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!harmon_closed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "harmon-closed",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  harmon_mute* harmon_mute::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmon_mute (*this, f, c);
  }

  harmon_mute& harmon_mute::
  operator= (const harmon_mute& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->harmon_closed_ = x.harmon_closed_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  harmon_mute::
  ~harmon_mute ()
  {
  }

  // harmonic
  //

  harmonic::
  harmonic ()
  : ::xml_schema::type (),
    natural_ (this),
    artificial_ (this),
    base_pitch_ (this),
    touching_pitch_ (this),
    sounding_pitch_ (this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  harmonic::
  harmonic (const harmonic& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    natural_ (x.natural_, f, this),
    artificial_ (x.artificial_, f, this),
    base_pitch_ (x.base_pitch_, f, this),
    touching_pitch_ (x.touching_pitch_, f, this),
    sounding_pitch_ (x.sounding_pitch_, f, this),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  harmonic::
  harmonic (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    natural_ (this),
    artificial_ (this),
    base_pitch_ (this),
    touching_pitch_ (this),
    sounding_pitch_ (this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void harmonic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // natural
      //
      if (n.name () == "natural" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< natural_type > r (
          natural_traits::create (i, f, this));

        if (!this->natural_)
        {
          this->natural_.set (::std::move (r));
          continue;
        }
      }

      // artificial
      //
      if (n.name () == "artificial" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< artificial_type > r (
          artificial_traits::create (i, f, this));

        if (!this->artificial_)
        {
          this->artificial_.set (::std::move (r));
          continue;
        }
      }

      // base-pitch
      //
      if (n.name () == "base-pitch" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< base_pitch_type > r (
          base_pitch_traits::create (i, f, this));

        if (!this->base_pitch_)
        {
          this->base_pitch_.set (::std::move (r));
          continue;
        }
      }

      // touching-pitch
      //
      if (n.name () == "touching-pitch" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< touching_pitch_type > r (
          touching_pitch_traits::create (i, f, this));

        if (!this->touching_pitch_)
        {
          this->touching_pitch_.set (::std::move (r));
          continue;
        }
      }

      // sounding-pitch
      //
      if (n.name () == "sounding-pitch" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sounding_pitch_type > r (
          sounding_pitch_traits::create (i, f, this));

        if (!this->sounding_pitch_)
        {
          this->sounding_pitch_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  harmonic* harmonic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class harmonic (*this, f, c);
  }

  harmonic& harmonic::
  operator= (const harmonic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->natural_ = x.natural_;
      this->artificial_ = x.artificial_;
      this->base_pitch_ = x.base_pitch_;
      this->touching_pitch_ = x.touching_pitch_;
      this->sounding_pitch_ = x.sounding_pitch_;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  harmonic::
  ~harmonic ()
  {
  }

  // heel_toe
  //

  heel_toe::
  heel_toe ()
  : ::musicxml::empty_placement (),
    substitution_ (this)
  {
  }

  heel_toe::
  heel_toe (const heel_toe& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::empty_placement (x, f, c),
    substitution_ (x.substitution_, f, this)
  {
  }

  heel_toe::
  heel_toe (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::empty_placement (e, f | ::xml_schema::flags::base, c),
    substitution_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void heel_toe::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::musicxml::empty_placement::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "substitution" && n.namespace_ ().empty ())
      {
        this->substitution_.set (substitution_traits::create (i, f, this));
        continue;
      }
    }
  }

  heel_toe* heel_toe::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class heel_toe (*this, f, c);
  }

  heel_toe& heel_toe::
  operator= (const heel_toe& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::empty_placement& > (*this) = x;
      this->substitution_ = x.substitution_;
    }

    return *this;
  }

  heel_toe::
  ~heel_toe ()
  {
  }

  // hole
  //

  hole::
  hole (const hole_closed_type& hole_closed)
  : ::xml_schema::type (),
    hole_type_ (this),
    hole_closed_ (hole_closed, this),
    hole_shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hole::
  hole (::std::unique_ptr< hole_closed_type > hole_closed)
  : ::xml_schema::type (),
    hole_type_ (this),
    hole_closed_ (std::move (hole_closed), this),
    hole_shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  hole::
  hole (const hole& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    hole_type_ (x.hole_type_, f, this),
    hole_closed_ (x.hole_closed_, f, this),
    hole_shape_ (x.hole_shape_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  hole::
  hole (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    hole_type_ (this),
    hole_closed_ (this),
    hole_shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void hole::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // hole-type
      //
      if (n.name () == "hole-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hole_type_type > r (
          hole_type_traits::create (i, f, this));

        if (!this->hole_type_)
        {
          this->hole_type_.set (::std::move (r));
          continue;
        }
      }

      // hole-closed
      //
      if (n.name () == "hole-closed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hole_closed_type > r (
          hole_closed_traits::create (i, f, this));

        if (!hole_closed_.present ())
        {
          this->hole_closed_.set (::std::move (r));
          continue;
        }
      }

      // hole-shape
      //
      if (n.name () == "hole-shape" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hole_shape_type > r (
          hole_shape_traits::create (i, f, this));

        if (!this->hole_shape_)
        {
          this->hole_shape_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!hole_closed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hole-closed",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  hole* hole::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hole (*this, f, c);
  }

  hole& hole::
  operator= (const hole& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->hole_type_ = x.hole_type_;
      this->hole_closed_ = x.hole_closed_;
      this->hole_shape_ = x.hole_shape_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  hole::
  ~hole ()
  {
  }

  // hole_closed
  //

  hole_closed::
  hole_closed (::musicxml::hole_closed_value::value _xsd_hole_closed_value_base)
  : ::musicxml::hole_closed_value (_xsd_hole_closed_value_base),
    location_ (this)
  {
  }

  hole_closed::
  hole_closed (const char* _xsd_string_base)
  : ::musicxml::hole_closed_value (_xsd_string_base),
    location_ (this)
  {
  }

  hole_closed::
  hole_closed (const ::std::string& _xsd_string_base)
  : ::musicxml::hole_closed_value (_xsd_string_base),
    location_ (this)
  {
  }

  hole_closed::
  hole_closed (const ::musicxml::hole_closed_value& _xsd_hole_closed_value_base)
  : ::musicxml::hole_closed_value (_xsd_hole_closed_value_base),
    location_ (this)
  {
  }

  hole_closed::
  hole_closed (const hole_closed& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::hole_closed_value (x, f, c),
    location_ (x.location_, f, this)
  {
  }

  hole_closed::
  hole_closed (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::hole_closed_value (e, f | ::xml_schema::flags::base, c),
    location_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void hole_closed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }
    }
  }

  hole_closed* hole_closed::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class hole_closed (*this, f, c);
  }

  hole_closed& hole_closed::
  operator= (const hole_closed& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::hole_closed_value& > (*this) = x;
      this->location_ = x.location_;
    }

    return *this;
  }

  hole_closed::
  ~hole_closed ()
  {
  }

  // instrument
  //

  instrument::
  instrument (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this)
  {
  }

  instrument::
  instrument (const instrument& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  instrument::
  instrument (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void instrument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  instrument* instrument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class instrument (*this, f, c);
  }

  instrument& instrument::
  operator= (const instrument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  instrument::
  ~instrument ()
  {
  }

  // listen
  //

  listen::
  listen ()
  : ::xml_schema::type (),
    assess_ (this),
    wait_ (this),
    other_listen_ (this)
  {
  }

  listen::
  listen (const listen& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    assess_ (x.assess_, f, this),
    wait_ (x.wait_, f, this),
    other_listen_ (x.other_listen_, f, this)
  {
  }

  listen::
  listen (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    assess_ (this),
    wait_ (this),
    other_listen_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void listen::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // assess
      //
      if (n.name () == "assess" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< assess_type > r (
          assess_traits::create (i, f, this));

        this->assess_.push_back (::std::move (r));
        continue;
      }

      // wait
      //
      if (n.name () == "wait" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< wait_type > r (
          wait_traits::create (i, f, this));

        this->wait_.push_back (::std::move (r));
        continue;
      }

      // other-listen
      //
      if (n.name () == "other-listen" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_listen_type > r (
          other_listen_traits::create (i, f, this));

        this->other_listen_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  listen* listen::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class listen (*this, f, c);
  }

  listen& listen::
  operator= (const listen& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->assess_ = x.assess_;
      this->wait_ = x.wait_;
      this->other_listen_ = x.other_listen_;
    }

    return *this;
  }

  listen::
  ~listen ()
  {
  }

  // lyric
  //

  lyric::
  lyric ()
  : ::xml_schema::type (),
    syllabic_ (this),
    text_ (this),
    elision_ (this),
    extend_ (this),
    laughing_ (this),
    humming_ (this),
    end_line_ (this),
    end_paragraph_ (this),
    footnote_ (this),
    level_ (this),
    number_ (this),
    name_ (this),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    print_object_ (this),
    time_only_ (this),
    id_ (this)
  {
  }

  lyric::
  lyric (const lyric& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    syllabic_ (x.syllabic_, f, this),
    text_ (x.text_, f, this),
    elision_ (x.elision_, f, this),
    extend_ (x.extend_, f, this),
    laughing_ (x.laughing_, f, this),
    humming_ (x.humming_, f, this),
    end_line_ (x.end_line_, f, this),
    end_paragraph_ (x.end_paragraph_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    number_ (x.number_, f, this),
    name_ (x.name_, f, this),
    justify_ (x.justify_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    color_ (x.color_, f, this),
    print_object_ (x.print_object_, f, this),
    time_only_ (x.time_only_, f, this),
    id_ (x.id_, f, this)
  {
  }

  lyric::
  lyric (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    syllabic_ (this),
    text_ (this),
    elision_ (this),
    extend_ (this),
    laughing_ (this),
    humming_ (this),
    end_line_ (this),
    end_paragraph_ (this),
    footnote_ (this),
    level_ (this),
    number_ (this),
    name_ (this),
    justify_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    print_object_ (this),
    time_only_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void lyric::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // syllabic
      //
      if (n.name () == "syllabic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< syllabic_type > r (
          syllabic_traits::create (i, f, this));

        this->syllabic_.push_back (::std::move (r));
        continue;
      }

      // text
      //
      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< text_type > r (
          text_traits::create (i, f, this));

        this->text_.push_back (::std::move (r));
        continue;
      }

      // elision
      //
      if (n.name () == "elision" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< elision_type > r (
          elision_traits::create (i, f, this));

        this->elision_.push_back (::std::move (r));
        continue;
      }

      // extend
      //
      if (n.name () == "extend" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< extend_type > r (
          extend_traits::create (i, f, this));

        if (!this->extend_)
        {
          this->extend_.set (::std::move (r));
          continue;
        }
      }

      // laughing
      //
      if (n.name () == "laughing" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< laughing_type > r (
          laughing_traits::create (i, f, this));

        if (!this->laughing_)
        {
          this->laughing_.set (::std::move (r));
          continue;
        }
      }

      // humming
      //
      if (n.name () == "humming" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< humming_type > r (
          humming_traits::create (i, f, this));

        if (!this->humming_)
        {
          this->humming_.set (::std::move (r));
          continue;
        }
      }

      // end-line
      //
      if (n.name () == "end-line" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< end_line_type > r (
          end_line_traits::create (i, f, this));

        if (!this->end_line_)
        {
          this->end_line_.set (::std::move (r));
          continue;
        }
      }

      // end-paragraph
      //
      if (n.name () == "end-paragraph" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< end_paragraph_type > r (
          end_paragraph_traits::create (i, f, this));

        if (!this->end_paragraph_)
        {
          this->end_paragraph_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  lyric* lyric::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lyric (*this, f, c);
  }

  lyric& lyric::
  operator= (const lyric& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->syllabic_ = x.syllabic_;
      this->text_ = x.text_;
      this->elision_ = x.elision_;
      this->extend_ = x.extend_;
      this->laughing_ = x.laughing_;
      this->humming_ = x.humming_;
      this->end_line_ = x.end_line_;
      this->end_paragraph_ = x.end_paragraph_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->number_ = x.number_;
      this->name_ = x.name_;
      this->justify_ = x.justify_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->color_ = x.color_;
      this->print_object_ = x.print_object_;
      this->time_only_ = x.time_only_;
      this->id_ = x.id_;
    }

    return *this;
  }

  lyric::
  ~lyric ()
  {
  }

  // mordent
  //

  mordent::
  mordent ()
  : ::musicxml::empty_trill_sound (),
    long__ (this),
    approach_ (this),
    departure_ (this)
  {
  }

  mordent::
  mordent (const mordent& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::empty_trill_sound (x, f, c),
    long__ (x.long__, f, this),
    approach_ (x.approach_, f, this),
    departure_ (x.departure_, f, this)
  {
  }

  mordent::
  mordent (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::empty_trill_sound (e, f | ::xml_schema::flags::base, c),
    long__ (this),
    approach_ (this),
    departure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void mordent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::musicxml::empty_trill_sound::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "long" && n.namespace_ ().empty ())
      {
        this->long__.set (long_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "approach" && n.namespace_ ().empty ())
      {
        this->approach_.set (approach_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "departure" && n.namespace_ ().empty ())
      {
        this->departure_.set (departure_traits::create (i, f, this));
        continue;
      }
    }
  }

  mordent* mordent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class mordent (*this, f, c);
  }

  mordent& mordent::
  operator= (const mordent& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::empty_trill_sound& > (*this) = x;
      this->long__ = x.long__;
      this->approach_ = x.approach_;
      this->departure_ = x.departure_;
    }

    return *this;
  }

  mordent::
  ~mordent ()
  {
  }

  // non_arpeggiate
  //

  non_arpeggiate::
  non_arpeggiate (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    id_ (this)
  {
  }

  non_arpeggiate::
  non_arpeggiate (const non_arpeggiate& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  non_arpeggiate::
  non_arpeggiate (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void non_arpeggiate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  non_arpeggiate* non_arpeggiate::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class non_arpeggiate (*this, f, c);
  }

  non_arpeggiate& non_arpeggiate::
  operator= (const non_arpeggiate& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  non_arpeggiate::
  ~non_arpeggiate ()
  {
  }

  // notations
  //

  notations::
  notations ()
  : ::xml_schema::type (),
    footnote_ (this),
    level_ (this),
    tied_ (this),
    slur_ (this),
    tuplet_ (this),
    glissando_ (this),
    slide_ (this),
    ornaments_ (this),
    technical_ (this),
    articulations_ (this),
    dynamics_ (this),
    fermata_ (this),
    arpeggiate_ (this),
    non_arpeggiate_ (this),
    accidental_mark_ (this),
    other_notation_ (this),
    print_object_ (this),
    id_ (this)
  {
  }

  notations::
  notations (const notations& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    tied_ (x.tied_, f, this),
    slur_ (x.slur_, f, this),
    tuplet_ (x.tuplet_, f, this),
    glissando_ (x.glissando_, f, this),
    slide_ (x.slide_, f, this),
    ornaments_ (x.ornaments_, f, this),
    technical_ (x.technical_, f, this),
    articulations_ (x.articulations_, f, this),
    dynamics_ (x.dynamics_, f, this),
    fermata_ (x.fermata_, f, this),
    arpeggiate_ (x.arpeggiate_, f, this),
    non_arpeggiate_ (x.non_arpeggiate_, f, this),
    accidental_mark_ (x.accidental_mark_, f, this),
    other_notation_ (x.other_notation_, f, this),
    print_object_ (x.print_object_, f, this),
    id_ (x.id_, f, this)
  {
  }

  notations::
  notations (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    footnote_ (this),
    level_ (this),
    tied_ (this),
    slur_ (this),
    tuplet_ (this),
    glissando_ (this),
    slide_ (this),
    ornaments_ (this),
    technical_ (this),
    articulations_ (this),
    dynamics_ (this),
    fermata_ (this),
    arpeggiate_ (this),
    non_arpeggiate_ (this),
    accidental_mark_ (this),
    other_notation_ (this),
    print_object_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void notations::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // tied
      //
      if (n.name () == "tied" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tied_type > r (
          tied_traits::create (i, f, this));

        this->tied_.push_back (::std::move (r));
        continue;
      }

      // slur
      //
      if (n.name () == "slur" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slur_type > r (
          slur_traits::create (i, f, this));

        this->slur_.push_back (::std::move (r));
        continue;
      }

      // tuplet
      //
      if (n.name () == "tuplet" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_type > r (
          tuplet_traits::create (i, f, this));

        this->tuplet_.push_back (::std::move (r));
        continue;
      }

      // glissando
      //
      if (n.name () == "glissando" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< glissando_type > r (
          glissando_traits::create (i, f, this));

        this->glissando_.push_back (::std::move (r));
        continue;
      }

      // slide
      //
      if (n.name () == "slide" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< slide_type > r (
          slide_traits::create (i, f, this));

        this->slide_.push_back (::std::move (r));
        continue;
      }

      // ornaments
      //
      if (n.name () == "ornaments" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ornaments_type > r (
          ornaments_traits::create (i, f, this));

        this->ornaments_.push_back (::std::move (r));
        continue;
      }

      // technical
      //
      if (n.name () == "technical" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< technical_type > r (
          technical_traits::create (i, f, this));

        this->technical_.push_back (::std::move (r));
        continue;
      }

      // articulations
      //
      if (n.name () == "articulations" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< articulations_type > r (
          articulations_traits::create (i, f, this));

        this->articulations_.push_back (::std::move (r));
        continue;
      }

      // dynamics
      //
      if (n.name () == "dynamics" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< dynamics_type > r (
          dynamics_traits::create (i, f, this));

        this->dynamics_.push_back (::std::move (r));
        continue;
      }

      // fermata
      //
      if (n.name () == "fermata" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fermata_type > r (
          fermata_traits::create (i, f, this));

        this->fermata_.push_back (::std::move (r));
        continue;
      }

      // arpeggiate
      //
      if (n.name () == "arpeggiate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< arpeggiate_type > r (
          arpeggiate_traits::create (i, f, this));

        this->arpeggiate_.push_back (::std::move (r));
        continue;
      }

      // non-arpeggiate
      //
      if (n.name () == "non-arpeggiate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< non_arpeggiate_type > r (
          non_arpeggiate_traits::create (i, f, this));

        this->non_arpeggiate_.push_back (::std::move (r));
        continue;
      }

      // accidental-mark
      //
      if (n.name () == "accidental-mark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accidental_mark_type > r (
          accidental_mark_traits::create (i, f, this));

        this->accidental_mark_.push_back (::std::move (r));
        continue;
      }

      // other-notation
      //
      if (n.name () == "other-notation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_notation_type > r (
          other_notation_traits::create (i, f, this));

        this->other_notation_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  notations* notations::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class notations (*this, f, c);
  }

  notations& notations::
  operator= (const notations& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->tied_ = x.tied_;
      this->slur_ = x.slur_;
      this->tuplet_ = x.tuplet_;
      this->glissando_ = x.glissando_;
      this->slide_ = x.slide_;
      this->ornaments_ = x.ornaments_;
      this->technical_ = x.technical_;
      this->articulations_ = x.articulations_;
      this->dynamics_ = x.dynamics_;
      this->fermata_ = x.fermata_;
      this->arpeggiate_ = x.arpeggiate_;
      this->non_arpeggiate_ = x.non_arpeggiate_;
      this->accidental_mark_ = x.accidental_mark_;
      this->other_notation_ = x.other_notation_;
      this->print_object_ = x.print_object_;
      this->id_ = x.id_;
    }

    return *this;
  }

  notations::
  ~notations ()
  {
  }

  // note
  //

  note::
  note ()
  : ::xml_schema::type (),
    grace_ (this),
    chord_ (this),
    pitch_ (this),
    unpitched_ (this),
    rest_ (this),
    tie_ (this),
    cue_ (this),
    duration_ (this),
    instrument_ (this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    type_ (this),
    dot_ (this),
    accidental_ (this),
    time_modification_ (this),
    stem_ (this),
    notehead_ (this),
    notehead_text_ (this),
    staff_ (this),
    beam_ (this),
    notations_ (this),
    lyric_ (this),
    play_ (this),
    listen_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    print_dot_ (this),
    print_spacing_ (this),
    print_lyric_ (this),
    print_leger_ (this),
    dynamics_ (this),
    end_dynamics_ (this),
    attack_ (this),
    release_ (this),
    time_only_ (this),
    pizzicato_ (this),
    id_ (this)
  {
  }

  note::
  note (const note& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    grace_ (x.grace_, f, this),
    chord_ (x.chord_, f, this),
    pitch_ (x.pitch_, f, this),
    unpitched_ (x.unpitched_, f, this),
    rest_ (x.rest_, f, this),
    tie_ (x.tie_, f, this),
    cue_ (x.cue_, f, this),
    duration_ (x.duration_, f, this),
    instrument_ (x.instrument_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    voice_ (x.voice_, f, this),
    type_ (x.type_, f, this),
    dot_ (x.dot_, f, this),
    accidental_ (x.accidental_, f, this),
    time_modification_ (x.time_modification_, f, this),
    stem_ (x.stem_, f, this),
    notehead_ (x.notehead_, f, this),
    notehead_text_ (x.notehead_text_, f, this),
    staff_ (x.staff_, f, this),
    beam_ (x.beam_, f, this),
    notations_ (x.notations_, f, this),
    lyric_ (x.lyric_, f, this),
    play_ (x.play_, f, this),
    listen_ (x.listen_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    print_object_ (x.print_object_, f, this),
    print_dot_ (x.print_dot_, f, this),
    print_spacing_ (x.print_spacing_, f, this),
    print_lyric_ (x.print_lyric_, f, this),
    print_leger_ (x.print_leger_, f, this),
    dynamics_ (x.dynamics_, f, this),
    end_dynamics_ (x.end_dynamics_, f, this),
    attack_ (x.attack_, f, this),
    release_ (x.release_, f, this),
    time_only_ (x.time_only_, f, this),
    pizzicato_ (x.pizzicato_, f, this),
    id_ (x.id_, f, this)
  {
  }

  note::
  note (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    grace_ (this),
    chord_ (this),
    pitch_ (this),
    unpitched_ (this),
    rest_ (this),
    tie_ (this),
    cue_ (this),
    duration_ (this),
    instrument_ (this),
    footnote_ (this),
    level_ (this),
    voice_ (this),
    type_ (this),
    dot_ (this),
    accidental_ (this),
    time_modification_ (this),
    stem_ (this),
    notehead_ (this),
    notehead_text_ (this),
    staff_ (this),
    beam_ (this),
    notations_ (this),
    lyric_ (this),
    play_ (this),
    listen_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    print_dot_ (this),
    print_spacing_ (this),
    print_lyric_ (this),
    print_leger_ (this),
    dynamics_ (this),
    end_dynamics_ (this),
    attack_ (this),
    release_ (this),
    time_only_ (this),
    pizzicato_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void note::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // grace
      //
      if (n.name () == "grace" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< grace_type > r (
          grace_traits::create (i, f, this));

        if (!this->grace_)
        {
          this->grace_.set (::std::move (r));
          continue;
        }
      }

      // chord
      //
      if (n.name () == "chord" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< chord_type > r (
          chord_traits::create (i, f, this));

        if (!this->chord_)
        {
          this->chord_.set (::std::move (r));
          continue;
        }
      }

      // pitch
      //
      if (n.name () == "pitch" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pitch_type > r (
          pitch_traits::create (i, f, this));

        if (!this->pitch_)
        {
          this->pitch_.set (::std::move (r));
          continue;
        }
      }

      // unpitched
      //
      if (n.name () == "unpitched" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< unpitched_type > r (
          unpitched_traits::create (i, f, this));

        if (!this->unpitched_)
        {
          this->unpitched_.set (::std::move (r));
          continue;
        }
      }

      // rest
      //
      if (n.name () == "rest" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< rest_type > r (
          rest_traits::create (i, f, this));

        if (!this->rest_)
        {
          this->rest_.set (::std::move (r));
          continue;
        }
      }

      // tie
      //
      if (n.name () == "tie" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tie_type > r (
          tie_traits::create (i, f, this));

        this->tie_.push_back (::std::move (r));
        continue;
      }

      // cue
      //
      if (n.name () == "cue" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< cue_type > r (
          cue_traits::create (i, f, this));

        if (!this->cue_)
        {
          this->cue_.set (::std::move (r));
          continue;
        }
      }

      // duration
      //
      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< duration_type > r (
          duration_traits::create (i, f, this));

        if (!this->duration_)
        {
          this->duration_.set (::std::move (r));
          continue;
        }
      }

      // instrument
      //
      if (n.name () == "instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_type > r (
          instrument_traits::create (i, f, this));

        this->instrument_.push_back (::std::move (r));
        continue;
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      // voice
      //
      if (n.name () == "voice" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< voice_type > r (
          voice_traits::create (i, f, this));

        if (!this->voice_)
        {
          this->voice_.set (::std::move (r));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!this->type_)
        {
          this->type_.set (::std::move (r));
          continue;
        }
      }

      // dot
      //
      if (n.name () == "dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< dot_type > r (
          dot_traits::create (i, f, this));

        this->dot_.push_back (::std::move (r));
        continue;
      }

      // accidental
      //
      if (n.name () == "accidental" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accidental_type > r (
          accidental_traits::create (i, f, this));

        if (!this->accidental_)
        {
          this->accidental_.set (::std::move (r));
          continue;
        }
      }

      // time-modification
      //
      if (n.name () == "time-modification" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< time_modification_type > r (
          time_modification_traits::create (i, f, this));

        if (!this->time_modification_)
        {
          this->time_modification_.set (::std::move (r));
          continue;
        }
      }

      // stem
      //
      if (n.name () == "stem" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stem_type > r (
          stem_traits::create (i, f, this));

        if (!this->stem_)
        {
          this->stem_.set (::std::move (r));
          continue;
        }
      }

      // notehead
      //
      if (n.name () == "notehead" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< notehead_type > r (
          notehead_traits::create (i, f, this));

        if (!this->notehead_)
        {
          this->notehead_.set (::std::move (r));
          continue;
        }
      }

      // notehead-text
      //
      if (n.name () == "notehead-text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< notehead_text_type > r (
          notehead_text_traits::create (i, f, this));

        if (!this->notehead_text_)
        {
          this->notehead_text_.set (::std::move (r));
          continue;
        }
      }

      // staff
      //
      if (n.name () == "staff" && n.namespace_ ().empty ())
      {
        if (!this->staff_)
        {
          this->staff_.set (staff_traits::create (i, f, this));
          continue;
        }
      }

      // beam
      //
      if (n.name () == "beam" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< beam_type > r (
          beam_traits::create (i, f, this));

        this->beam_.push_back (::std::move (r));
        continue;
      }

      // notations
      //
      if (n.name () == "notations" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< notations_type > r (
          notations_traits::create (i, f, this));

        this->notations_.push_back (::std::move (r));
        continue;
      }

      // lyric
      //
      if (n.name () == "lyric" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< lyric_type > r (
          lyric_traits::create (i, f, this));

        this->lyric_.push_back (::std::move (r));
        continue;
      }

      // play
      //
      if (n.name () == "play" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< play_type > r (
          play_traits::create (i, f, this));

        if (!this->play_)
        {
          this->play_.set (::std::move (r));
          continue;
        }
      }

      // listen
      //
      if (n.name () == "listen" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< listen_type > r (
          listen_traits::create (i, f, this));

        if (!this->listen_)
        {
          this->listen_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-dot" && n.namespace_ ().empty ())
      {
        this->print_dot_.set (print_dot_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-spacing" && n.namespace_ ().empty ())
      {
        this->print_spacing_.set (print_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-lyric" && n.namespace_ ().empty ())
      {
        this->print_lyric_.set (print_lyric_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-leger" && n.namespace_ ().empty ())
      {
        this->print_leger_.set (print_leger_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dynamics" && n.namespace_ ().empty ())
      {
        this->dynamics_.set (dynamics_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "end-dynamics" && n.namespace_ ().empty ())
      {
        this->end_dynamics_.set (end_dynamics_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "attack" && n.namespace_ ().empty ())
      {
        this->attack_.set (attack_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "release" && n.namespace_ ().empty ())
      {
        this->release_.set (release_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "pizzicato" && n.namespace_ ().empty ())
      {
        this->pizzicato_.set (pizzicato_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  note* note::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note (*this, f, c);
  }

  note& note::
  operator= (const note& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->grace_ = x.grace_;
      this->chord_ = x.chord_;
      this->pitch_ = x.pitch_;
      this->unpitched_ = x.unpitched_;
      this->rest_ = x.rest_;
      this->tie_ = x.tie_;
      this->cue_ = x.cue_;
      this->duration_ = x.duration_;
      this->instrument_ = x.instrument_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->voice_ = x.voice_;
      this->type_ = x.type_;
      this->dot_ = x.dot_;
      this->accidental_ = x.accidental_;
      this->time_modification_ = x.time_modification_;
      this->stem_ = x.stem_;
      this->notehead_ = x.notehead_;
      this->notehead_text_ = x.notehead_text_;
      this->staff_ = x.staff_;
      this->beam_ = x.beam_;
      this->notations_ = x.notations_;
      this->lyric_ = x.lyric_;
      this->play_ = x.play_;
      this->listen_ = x.listen_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->print_object_ = x.print_object_;
      this->print_dot_ = x.print_dot_;
      this->print_spacing_ = x.print_spacing_;
      this->print_lyric_ = x.print_lyric_;
      this->print_leger_ = x.print_leger_;
      this->dynamics_ = x.dynamics_;
      this->end_dynamics_ = x.end_dynamics_;
      this->attack_ = x.attack_;
      this->release_ = x.release_;
      this->time_only_ = x.time_only_;
      this->pizzicato_ = x.pizzicato_;
      this->id_ = x.id_;
    }

    return *this;
  }

  note::
  ~note ()
  {
  }

  // note_type
  //

  note_type::
  note_type (::musicxml::note_type_value::value _xsd_note_type_value_base)
  : ::musicxml::note_type_value (_xsd_note_type_value_base),
    size_ (this)
  {
  }

  note_type::
  note_type (const char* _xsd_string_base)
  : ::musicxml::note_type_value (_xsd_string_base),
    size_ (this)
  {
  }

  note_type::
  note_type (const ::std::string& _xsd_string_base)
  : ::musicxml::note_type_value (_xsd_string_base),
    size_ (this)
  {
  }

  note_type::
  note_type (const ::musicxml::note_type_value& _xsd_note_type_value_base)
  : ::musicxml::note_type_value (_xsd_note_type_value_base),
    size_ (this)
  {
  }

  note_type::
  note_type (const note_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::note_type_value (x, f, c),
    size_ (x.size_, f, this)
  {
  }

  note_type::
  note_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::musicxml::note_type_value (e, f | ::xml_schema::flags::base, c),
    size_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void note_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        this->size_.set (size_traits::create (i, f, this));
        continue;
      }
    }
  }

  note_type* note_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class note_type (*this, f, c);
  }

  note_type& note_type::
  operator= (const note_type& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::note_type_value& > (*this) = x;
      this->size_ = x.size_;
    }

    return *this;
  }

  note_type::
  ~note_type ()
  {
  }

  // notehead
  //

  notehead::
  notehead (::musicxml::notehead_value::value _xsd_notehead_value_base)
  : ::musicxml::notehead_value (_xsd_notehead_value_base),
    filled_ (this),
    parentheses_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  notehead::
  notehead (const char* _xsd_string_base)
  : ::musicxml::notehead_value (_xsd_string_base),
    filled_ (this),
    parentheses_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  notehead::
  notehead (const ::std::string& _xsd_string_base)
  : ::musicxml::notehead_value (_xsd_string_base),
    filled_ (this),
    parentheses_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  notehead::
  notehead (const ::musicxml::notehead_value& _xsd_notehead_value_base)
  : ::musicxml::notehead_value (_xsd_notehead_value_base),
    filled_ (this),
    parentheses_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
  }

  notehead::
  notehead (const notehead& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::notehead_value (x, f, c),
    filled_ (x.filled_, f, this),
    parentheses_ (x.parentheses_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  notehead::
  notehead (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::musicxml::notehead_value (e, f | ::xml_schema::flags::base, c),
    filled_ (this),
    parentheses_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void notehead::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "filled" && n.namespace_ ().empty ())
      {
        this->filled_.set (filled_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "parentheses" && n.namespace_ ().empty ())
      {
        this->parentheses_.set (parentheses_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  notehead* notehead::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class notehead (*this, f, c);
  }

  notehead& notehead::
  operator= (const notehead& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::notehead_value& > (*this) = x;
      this->filled_ = x.filled_;
      this->parentheses_ = x.parentheses_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  notehead::
  ~notehead ()
  {
  }

  // notehead_text
  //

  notehead_text::
  notehead_text ()
  : ::xml_schema::type (),
    display_text_ (this),
    accidental_text_ (this)
  {
  }

  notehead_text::
  notehead_text (const notehead_text& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    display_text_ (x.display_text_, f, this),
    accidental_text_ (x.accidental_text_, f, this)
  {
  }

  notehead_text::
  notehead_text (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    display_text_ (this),
    accidental_text_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void notehead_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // display-text
      //
      if (n.name () == "display-text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_text_type > r (
          display_text_traits::create (i, f, this));

        this->display_text_.push_back (::std::move (r));
        continue;
      }

      // accidental-text
      //
      if (n.name () == "accidental-text" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accidental_text_type > r (
          accidental_text_traits::create (i, f, this));

        this->accidental_text_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  notehead_text* notehead_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class notehead_text (*this, f, c);
  }

  notehead_text& notehead_text::
  operator= (const notehead_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->display_text_ = x.display_text_;
      this->accidental_text_ = x.accidental_text_;
    }

    return *this;
  }

  notehead_text::
  ~notehead_text ()
  {
  }

  // ornaments
  //

  ornaments::
  ornaments ()
  : ::xml_schema::type (),
    trill_mark_ (this),
    turn_ (this),
    delayed_turn_ (this),
    inverted_turn_ (this),
    delayed_inverted_turn_ (this),
    vertical_turn_ (this),
    inverted_vertical_turn_ (this),
    shake_ (this),
    wavy_line_ (this),
    mordent_ (this),
    inverted_mordent_ (this),
    schleifer_ (this),
    tremolo_ (this),
    haydn_ (this),
    other_ornament_ (this),
    accidental_mark_ (this),
    id_ (this)
  {
  }

  ornaments::
  ornaments (const ornaments& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    trill_mark_ (x.trill_mark_, f, this),
    turn_ (x.turn_, f, this),
    delayed_turn_ (x.delayed_turn_, f, this),
    inverted_turn_ (x.inverted_turn_, f, this),
    delayed_inverted_turn_ (x.delayed_inverted_turn_, f, this),
    vertical_turn_ (x.vertical_turn_, f, this),
    inverted_vertical_turn_ (x.inverted_vertical_turn_, f, this),
    shake_ (x.shake_, f, this),
    wavy_line_ (x.wavy_line_, f, this),
    mordent_ (x.mordent_, f, this),
    inverted_mordent_ (x.inverted_mordent_, f, this),
    schleifer_ (x.schleifer_, f, this),
    tremolo_ (x.tremolo_, f, this),
    haydn_ (x.haydn_, f, this),
    other_ornament_ (x.other_ornament_, f, this),
    accidental_mark_ (x.accidental_mark_, f, this),
    id_ (x.id_, f, this)
  {
  }

  ornaments::
  ornaments (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    trill_mark_ (this),
    turn_ (this),
    delayed_turn_ (this),
    inverted_turn_ (this),
    delayed_inverted_turn_ (this),
    vertical_turn_ (this),
    inverted_vertical_turn_ (this),
    shake_ (this),
    wavy_line_ (this),
    mordent_ (this),
    inverted_mordent_ (this),
    schleifer_ (this),
    tremolo_ (this),
    haydn_ (this),
    other_ornament_ (this),
    accidental_mark_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ornaments::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // trill-mark
      //
      if (n.name () == "trill-mark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< trill_mark_type > r (
          trill_mark_traits::create (i, f, this));

        this->trill_mark_.push_back (::std::move (r));
        continue;
      }

      // turn
      //
      if (n.name () == "turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< turn_type > r (
          turn_traits::create (i, f, this));

        this->turn_.push_back (::std::move (r));
        continue;
      }

      // delayed-turn
      //
      if (n.name () == "delayed-turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< delayed_turn_type > r (
          delayed_turn_traits::create (i, f, this));

        this->delayed_turn_.push_back (::std::move (r));
        continue;
      }

      // inverted-turn
      //
      if (n.name () == "inverted-turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< inverted_turn_type > r (
          inverted_turn_traits::create (i, f, this));

        this->inverted_turn_.push_back (::std::move (r));
        continue;
      }

      // delayed-inverted-turn
      //
      if (n.name () == "delayed-inverted-turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< delayed_inverted_turn_type > r (
          delayed_inverted_turn_traits::create (i, f, this));

        this->delayed_inverted_turn_.push_back (::std::move (r));
        continue;
      }

      // vertical-turn
      //
      if (n.name () == "vertical-turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< vertical_turn_type > r (
          vertical_turn_traits::create (i, f, this));

        this->vertical_turn_.push_back (::std::move (r));
        continue;
      }

      // inverted-vertical-turn
      //
      if (n.name () == "inverted-vertical-turn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< inverted_vertical_turn_type > r (
          inverted_vertical_turn_traits::create (i, f, this));

        this->inverted_vertical_turn_.push_back (::std::move (r));
        continue;
      }

      // shake
      //
      if (n.name () == "shake" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< shake_type > r (
          shake_traits::create (i, f, this));

        this->shake_.push_back (::std::move (r));
        continue;
      }

      // wavy-line
      //
      if (n.name () == "wavy-line" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< wavy_line_type > r (
          wavy_line_traits::create (i, f, this));

        this->wavy_line_.push_back (::std::move (r));
        continue;
      }

      // mordent
      //
      if (n.name () == "mordent" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< mordent_type > r (
          mordent_traits::create (i, f, this));

        this->mordent_.push_back (::std::move (r));
        continue;
      }

      // inverted-mordent
      //
      if (n.name () == "inverted-mordent" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< inverted_mordent_type > r (
          inverted_mordent_traits::create (i, f, this));

        this->inverted_mordent_.push_back (::std::move (r));
        continue;
      }

      // schleifer
      //
      if (n.name () == "schleifer" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< schleifer_type > r (
          schleifer_traits::create (i, f, this));

        this->schleifer_.push_back (::std::move (r));
        continue;
      }

      // tremolo
      //
      if (n.name () == "tremolo" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tremolo_type > r (
          tremolo_traits::create (i, f, this));

        this->tremolo_.push_back (::std::move (r));
        continue;
      }

      // haydn
      //
      if (n.name () == "haydn" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< haydn_type > r (
          haydn_traits::create (i, f, this));

        this->haydn_.push_back (::std::move (r));
        continue;
      }

      // other-ornament
      //
      if (n.name () == "other-ornament" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_ornament_type > r (
          other_ornament_traits::create (i, f, this));

        this->other_ornament_.push_back (::std::move (r));
        continue;
      }

      // accidental-mark
      //
      if (n.name () == "accidental-mark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< accidental_mark_type > r (
          accidental_mark_traits::create (i, f, this));

        this->accidental_mark_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  ornaments* ornaments::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ornaments (*this, f, c);
  }

  ornaments& ornaments::
  operator= (const ornaments& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->trill_mark_ = x.trill_mark_;
      this->turn_ = x.turn_;
      this->delayed_turn_ = x.delayed_turn_;
      this->inverted_turn_ = x.inverted_turn_;
      this->delayed_inverted_turn_ = x.delayed_inverted_turn_;
      this->vertical_turn_ = x.vertical_turn_;
      this->inverted_vertical_turn_ = x.inverted_vertical_turn_;
      this->shake_ = x.shake_;
      this->wavy_line_ = x.wavy_line_;
      this->mordent_ = x.mordent_;
      this->inverted_mordent_ = x.inverted_mordent_;
      this->schleifer_ = x.schleifer_;
      this->tremolo_ = x.tremolo_;
      this->haydn_ = x.haydn_;
      this->other_ornament_ = x.other_ornament_;
      this->accidental_mark_ = x.accidental_mark_;
      this->id_ = x.id_;
    }

    return *this;
  }

  ornaments::
  ~ornaments ()
  {
  }

  // other_notation
  //

  other_notation::
  other_notation (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    number_ (number_default_value (), this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_notation::
  other_notation (const char* _xsd_string_base,
                  const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_notation::
  other_notation (const ::std::string& _xsd_string_base,
                  const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_notation::
  other_notation (const ::xml_schema::string& _xsd_string_base,
                  const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
  }

  other_notation::
  other_notation (const other_notation& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    print_object_ (x.print_object_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this),
    id_ (x.id_, f, this)
  {
  }

  other_notation::
  other_notation (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    print_object_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_notation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  other_notation* other_notation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_notation (*this, f, c);
  }

  other_notation& other_notation::
  operator= (const other_notation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->print_object_ = x.print_object_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
      this->id_ = x.id_;
    }

    return *this;
  }

  other_notation::
  ~other_notation ()
  {
  }

  // other_placement_text
  //

  other_placement_text::
  other_placement_text ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  other_placement_text::
  other_placement_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  other_placement_text::
  other_placement_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  other_placement_text::
  other_placement_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  other_placement_text::
  other_placement_text (const other_placement_text& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  other_placement_text::
  other_placement_text (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_placement_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  other_placement_text* other_placement_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_placement_text (*this, f, c);
  }

  other_placement_text& other_placement_text::
  operator= (const other_placement_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  other_placement_text::
  ~other_placement_text ()
  {
  }

  // other_text
  //

  other_text::
  other_text ()
  : ::xml_schema::string (),
    smufl_ (this)
  {
  }

  other_text::
  other_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    smufl_ (this)
  {
  }

  other_text::
  other_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    smufl_ (this)
  {
  }

  other_text::
  other_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    smufl_ (this)
  {
  }

  other_text::
  other_text (const other_text& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    smufl_ (x.smufl_, f, this)
  {
  }

  other_text::
  other_text (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void other_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }
  }

  other_text* other_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class other_text (*this, f, c);
  }

  other_text& other_text::
  operator= (const other_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  other_text::
  ~other_text ()
  {
  }

  // pitch
  //

  pitch::
  pitch (const step_type& step,
         const octave_type& octave)
  : ::xml_schema::type (),
    step_ (step, this),
    alter_ (this),
    octave_ (octave, this)
  {
  }

  pitch::
  pitch (const pitch& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    step_ (x.step_, f, this),
    alter_ (x.alter_, f, this),
    octave_ (x.octave_, f, this)
  {
  }

  pitch::
  pitch (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    step_ (this),
    alter_ (this),
    octave_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void pitch::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // step
      //
      if (n.name () == "step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< step_type > r (
          step_traits::create (i, f, this));

        if (!step_.present ())
        {
          this->step_.set (::std::move (r));
          continue;
        }
      }

      // alter
      //
      if (n.name () == "alter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< alter_type > r (
          alter_traits::create (i, f, this));

        if (!this->alter_)
        {
          this->alter_.set (::std::move (r));
          continue;
        }
      }

      // octave
      //
      if (n.name () == "octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< octave_type > r (
          octave_traits::create (i, f, this));

        if (!octave_.present ())
        {
          this->octave_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!step_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "step",
        "");
    }

    if (!octave_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "octave",
        "");
    }
  }

  pitch* pitch::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class pitch (*this, f, c);
  }

  pitch& pitch::
  operator= (const pitch& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->step_ = x.step_;
      this->alter_ = x.alter_;
      this->octave_ = x.octave_;
    }

    return *this;
  }

  pitch::
  ~pitch ()
  {
  }

  // placement_text
  //

  placement_text::
  placement_text ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  placement_text::
  placement_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  placement_text::
  placement_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  placement_text::
  placement_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  placement_text::
  placement_text (const placement_text& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  placement_text::
  placement_text (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void placement_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  placement_text* placement_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class placement_text (*this, f, c);
  }

  placement_text& placement_text::
  operator= (const placement_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  placement_text::
  ~placement_text ()
  {
  }

  // release
  //

  release::
  release ()
  : ::musicxml::empty (),
    offset_ (this)
  {
  }

  release::
  release (const release& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::empty (x, f, c),
    offset_ (x.offset_, f, this)
  {
  }

  release::
  release (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::empty (e, f | ::xml_schema::flags::base, c),
    offset_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void release::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }
    }
  }

  release* release::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class release (*this, f, c);
  }

  release& release::
  operator= (const release& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::empty& > (*this) = x;
      this->offset_ = x.offset_;
    }

    return *this;
  }

  release::
  ~release ()
  {
  }

  // rest
  //

  rest::
  rest ()
  : ::xml_schema::type (),
    display_step_ (this),
    display_octave_ (this),
    measure_ (this)
  {
  }

  rest::
  rest (const rest& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    display_step_ (x.display_step_, f, this),
    display_octave_ (x.display_octave_, f, this),
    measure_ (x.measure_, f, this)
  {
  }

  rest::
  rest (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    display_step_ (this),
    display_octave_ (this),
    measure_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void rest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // display-step
      //
      if (n.name () == "display-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_step_type > r (
          display_step_traits::create (i, f, this));

        if (!this->display_step_)
        {
          this->display_step_.set (::std::move (r));
          continue;
        }
      }

      // display-octave
      //
      if (n.name () == "display-octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_octave_type > r (
          display_octave_traits::create (i, f, this));

        if (!this->display_octave_)
        {
          this->display_octave_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "measure" && n.namespace_ ().empty ())
      {
        this->measure_.set (measure_traits::create (i, f, this));
        continue;
      }
    }
  }

  rest* rest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class rest (*this, f, c);
  }

  rest& rest::
  operator= (const rest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->display_step_ = x.display_step_;
      this->display_octave_ = x.display_octave_;
      this->measure_ = x.measure_;
    }

    return *this;
  }

  rest::
  ~rest ()
  {
  }

  // slide
  //

  slide::
  slide (const type_type& type)
  : ::xml_schema::string (),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this),
    id_ (this)
  {
  }

  slide::
  slide (const char* _xsd_string_base,
         const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this),
    id_ (this)
  {
  }

  slide::
  slide (const ::std::string& _xsd_string_base,
         const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this),
    id_ (this)
  {
  }

  slide::
  slide (const ::xml_schema::string& _xsd_string_base,
         const type_type& type)
  : ::xml_schema::string (_xsd_string_base),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this),
    id_ (this)
  {
  }

  slide::
  slide (const slide& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    accelerate_ (x.accelerate_, f, this),
    beats_ (x.beats_, f, this),
    first_beat_ (x.first_beat_, f, this),
    last_beat_ (x.last_beat_, f, this),
    id_ (x.id_, f, this)
  {
  }

  slide::
  slide (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    accelerate_ (this),
    beats_ (this),
    first_beat_ (this),
    last_beat_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void slide::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "accelerate" && n.namespace_ ().empty ())
      {
        this->accelerate_.set (accelerate_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "beats" && n.namespace_ ().empty ())
      {
        this->beats_.set (beats_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "first-beat" && n.namespace_ ().empty ())
      {
        this->first_beat_.set (first_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "last-beat" && n.namespace_ ().empty ())
      {
        this->last_beat_.set (last_beat_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  slide* slide::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class slide (*this, f, c);
  }

  slide& slide::
  operator= (const slide& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->accelerate_ = x.accelerate_;
      this->beats_ = x.beats_;
      this->first_beat_ = x.first_beat_;
      this->last_beat_ = x.last_beat_;
      this->id_ = x.id_;
    }

    return *this;
  }

  slide::
  ~slide ()
  {
  }

  // slur
  //

  slur::
  slur (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (number_default_value (), this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    orientation_ (this),
    bezier_x_ (this),
    bezier_y_ (this),
    bezier_x2_ (this),
    bezier_y2_ (this),
    bezier_offset_ (this),
    bezier_offset2_ (this),
    color_ (this),
    id_ (this)
  {
  }

  slur::
  slur (const slur& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    orientation_ (x.orientation_, f, this),
    bezier_x_ (x.bezier_x_, f, this),
    bezier_y_ (x.bezier_y_, f, this),
    bezier_x2_ (x.bezier_x2_, f, this),
    bezier_y2_ (x.bezier_y2_, f, this),
    bezier_offset_ (x.bezier_offset_, f, this),
    bezier_offset2_ (x.bezier_offset2_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  slur::
  slur (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    orientation_ (this),
    bezier_x_ (this),
    bezier_y_ (this),
    bezier_x2_ (this),
    bezier_y2_ (this),
    bezier_offset_ (this),
    bezier_offset2_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void slur::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orientation" && n.namespace_ ().empty ())
      {
        this->orientation_.set (orientation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-x" && n.namespace_ ().empty ())
      {
        this->bezier_x_.set (bezier_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-y" && n.namespace_ ().empty ())
      {
        this->bezier_y_.set (bezier_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-x2" && n.namespace_ ().empty ())
      {
        this->bezier_x2_.set (bezier_x2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-y2" && n.namespace_ ().empty ())
      {
        this->bezier_y2_.set (bezier_y2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-offset" && n.namespace_ ().empty ())
      {
        this->bezier_offset_.set (bezier_offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-offset2" && n.namespace_ ().empty ())
      {
        this->bezier_offset2_.set (bezier_offset2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  slur* slur::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class slur (*this, f, c);
  }

  slur& slur::
  operator= (const slur& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->orientation_ = x.orientation_;
      this->bezier_x_ = x.bezier_x_;
      this->bezier_y_ = x.bezier_y_;
      this->bezier_x2_ = x.bezier_x2_;
      this->bezier_y2_ = x.bezier_y2_;
      this->bezier_offset_ = x.bezier_offset_;
      this->bezier_offset2_ = x.bezier_offset2_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  slur::
  ~slur ()
  {
  }

  // stem
  //

  stem::
  stem (::musicxml::stem_value::value _xsd_stem_value_base)
  : ::musicxml::stem_value (_xsd_stem_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  stem::
  stem (const char* _xsd_string_base)
  : ::musicxml::stem_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  stem::
  stem (const ::std::string& _xsd_string_base)
  : ::musicxml::stem_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  stem::
  stem (const ::musicxml::stem_value& _xsd_stem_value_base)
  : ::musicxml::stem_value (_xsd_stem_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  stem::
  stem (const stem& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::stem_value (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this)
  {
  }

  stem::
  stem (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::musicxml::stem_value (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void stem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  stem* stem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class stem (*this, f, c);
  }

  stem& stem::
  operator= (const stem& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::stem_value& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
    }

    return *this;
  }

  stem::
  ~stem ()
  {
  }

  // strong_accent
  //

  const strong_accent::type_type strong_accent::type_default_value_ (
    "up");

  strong_accent::
  strong_accent ()
  : ::musicxml::empty_placement (),
    type_ (type_default_value (), this)
  {
  }

  strong_accent::
  strong_accent (const strong_accent& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::empty_placement (x, f, c),
    type_ (x.type_, f, this)
  {
  }

  strong_accent::
  strong_accent (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::empty_placement (e, f | ::xml_schema::flags::base, c),
    type_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void strong_accent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::musicxml::empty_placement::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  strong_accent* strong_accent::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class strong_accent (*this, f, c);
  }

  strong_accent& strong_accent::
  operator= (const strong_accent& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::empty_placement& > (*this) = x;
      this->type_ = x.type_;
    }

    return *this;
  }

  strong_accent::
  ~strong_accent ()
  {
  }

  // style_text
  //

  style_text::
  style_text ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  style_text::
  style_text (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  style_text::
  style_text (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  style_text::
  style_text (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  style_text::
  style_text (const style_text& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  style_text::
  style_text (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void style_text::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  style_text* style_text::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class style_text (*this, f, c);
  }

  style_text& style_text::
  operator= (const style_text& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  style_text::
  ~style_text ()
  {
  }

  // tap
  //

  tap::
  tap ()
  : ::xml_schema::string (),
    hand_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  tap::
  tap (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    hand_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  tap::
  tap (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    hand_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  tap::
  tap (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    hand_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
  }

  tap::
  tap (const tap& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    hand_ (x.hand_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this)
  {
  }

  tap::
  tap (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    hand_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "hand" && n.namespace_ ().empty ())
      {
        this->hand_.set (hand_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }
    }
  }

  tap* tap::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tap (*this, f, c);
  }

  tap& tap::
  operator= (const tap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->hand_ = x.hand_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
    }

    return *this;
  }

  tap::
  ~tap ()
  {
  }

  // technical
  //

  technical::
  technical ()
  : ::xml_schema::type (),
    up_bow_ (this),
    down_bow_ (this),
    harmonic_ (this),
    open_string_ (this),
    thumb_position_ (this),
    fingering_ (this),
    pluck_ (this),
    double_tongue_ (this),
    triple_tongue_ (this),
    stopped_ (this),
    snap_pizzicato_ (this),
    fret_ (this),
    string_ (this),
    hammer_on_ (this),
    pull_off_ (this),
    bend_ (this),
    tap_ (this),
    heel_ (this),
    toe_ (this),
    fingernails_ (this),
    hole_ (this),
    arrow_ (this),
    handbell_ (this),
    brass_bend_ (this),
    flip_ (this),
    smear_ (this),
    open_ (this),
    half_muted_ (this),
    harmon_mute_ (this),
    golpe_ (this),
    other_technical_ (this),
    id_ (this)
  {
  }

  technical::
  technical (const technical& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    up_bow_ (x.up_bow_, f, this),
    down_bow_ (x.down_bow_, f, this),
    harmonic_ (x.harmonic_, f, this),
    open_string_ (x.open_string_, f, this),
    thumb_position_ (x.thumb_position_, f, this),
    fingering_ (x.fingering_, f, this),
    pluck_ (x.pluck_, f, this),
    double_tongue_ (x.double_tongue_, f, this),
    triple_tongue_ (x.triple_tongue_, f, this),
    stopped_ (x.stopped_, f, this),
    snap_pizzicato_ (x.snap_pizzicato_, f, this),
    fret_ (x.fret_, f, this),
    string_ (x.string_, f, this),
    hammer_on_ (x.hammer_on_, f, this),
    pull_off_ (x.pull_off_, f, this),
    bend_ (x.bend_, f, this),
    tap_ (x.tap_, f, this),
    heel_ (x.heel_, f, this),
    toe_ (x.toe_, f, this),
    fingernails_ (x.fingernails_, f, this),
    hole_ (x.hole_, f, this),
    arrow_ (x.arrow_, f, this),
    handbell_ (x.handbell_, f, this),
    brass_bend_ (x.brass_bend_, f, this),
    flip_ (x.flip_, f, this),
    smear_ (x.smear_, f, this),
    open_ (x.open_, f, this),
    half_muted_ (x.half_muted_, f, this),
    harmon_mute_ (x.harmon_mute_, f, this),
    golpe_ (x.golpe_, f, this),
    other_technical_ (x.other_technical_, f, this),
    id_ (x.id_, f, this)
  {
  }

  technical::
  technical (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    up_bow_ (this),
    down_bow_ (this),
    harmonic_ (this),
    open_string_ (this),
    thumb_position_ (this),
    fingering_ (this),
    pluck_ (this),
    double_tongue_ (this),
    triple_tongue_ (this),
    stopped_ (this),
    snap_pizzicato_ (this),
    fret_ (this),
    string_ (this),
    hammer_on_ (this),
    pull_off_ (this),
    bend_ (this),
    tap_ (this),
    heel_ (this),
    toe_ (this),
    fingernails_ (this),
    hole_ (this),
    arrow_ (this),
    handbell_ (this),
    brass_bend_ (this),
    flip_ (this),
    smear_ (this),
    open_ (this),
    half_muted_ (this),
    harmon_mute_ (this),
    golpe_ (this),
    other_technical_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void technical::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // up-bow
      //
      if (n.name () == "up-bow" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< up_bow_type > r (
          up_bow_traits::create (i, f, this));

        this->up_bow_.push_back (::std::move (r));
        continue;
      }

      // down-bow
      //
      if (n.name () == "down-bow" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< down_bow_type > r (
          down_bow_traits::create (i, f, this));

        this->down_bow_.push_back (::std::move (r));
        continue;
      }

      // harmonic
      //
      if (n.name () == "harmonic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harmonic_type > r (
          harmonic_traits::create (i, f, this));

        this->harmonic_.push_back (::std::move (r));
        continue;
      }

      // open-string
      //
      if (n.name () == "open-string" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< open_string_type > r (
          open_string_traits::create (i, f, this));

        this->open_string_.push_back (::std::move (r));
        continue;
      }

      // thumb-position
      //
      if (n.name () == "thumb-position" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< thumb_position_type > r (
          thumb_position_traits::create (i, f, this));

        this->thumb_position_.push_back (::std::move (r));
        continue;
      }

      // fingering
      //
      if (n.name () == "fingering" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fingering_type > r (
          fingering_traits::create (i, f, this));

        this->fingering_.push_back (::std::move (r));
        continue;
      }

      // pluck
      //
      if (n.name () == "pluck" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pluck_type > r (
          pluck_traits::create (i, f, this));

        this->pluck_.push_back (::std::move (r));
        continue;
      }

      // double-tongue
      //
      if (n.name () == "double-tongue" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< double_tongue_type > r (
          double_tongue_traits::create (i, f, this));

        this->double_tongue_.push_back (::std::move (r));
        continue;
      }

      // triple-tongue
      //
      if (n.name () == "triple-tongue" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< triple_tongue_type > r (
          triple_tongue_traits::create (i, f, this));

        this->triple_tongue_.push_back (::std::move (r));
        continue;
      }

      // stopped
      //
      if (n.name () == "stopped" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< stopped_type > r (
          stopped_traits::create (i, f, this));

        this->stopped_.push_back (::std::move (r));
        continue;
      }

      // snap-pizzicato
      //
      if (n.name () == "snap-pizzicato" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< snap_pizzicato_type > r (
          snap_pizzicato_traits::create (i, f, this));

        this->snap_pizzicato_.push_back (::std::move (r));
        continue;
      }

      // fret
      //
      if (n.name () == "fret" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fret_type > r (
          fret_traits::create (i, f, this));

        this->fret_.push_back (::std::move (r));
        continue;
      }

      // string
      //
      if (n.name () == "string" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< string_type > r (
          string_traits::create (i, f, this));

        this->string_.push_back (::std::move (r));
        continue;
      }

      // hammer-on
      //
      if (n.name () == "hammer-on" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hammer_on_type > r (
          hammer_on_traits::create (i, f, this));

        this->hammer_on_.push_back (::std::move (r));
        continue;
      }

      // pull-off
      //
      if (n.name () == "pull-off" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< pull_off_type > r (
          pull_off_traits::create (i, f, this));

        this->pull_off_.push_back (::std::move (r));
        continue;
      }

      // bend
      //
      if (n.name () == "bend" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bend_type > r (
          bend_traits::create (i, f, this));

        this->bend_.push_back (::std::move (r));
        continue;
      }

      // tap
      //
      if (n.name () == "tap" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tap_type > r (
          tap_traits::create (i, f, this));

        this->tap_.push_back (::std::move (r));
        continue;
      }

      // heel
      //
      if (n.name () == "heel" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< heel_type > r (
          heel_traits::create (i, f, this));

        this->heel_.push_back (::std::move (r));
        continue;
      }

      // toe
      //
      if (n.name () == "toe" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< toe_type > r (
          toe_traits::create (i, f, this));

        this->toe_.push_back (::std::move (r));
        continue;
      }

      // fingernails
      //
      if (n.name () == "fingernails" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< fingernails_type > r (
          fingernails_traits::create (i, f, this));

        this->fingernails_.push_back (::std::move (r));
        continue;
      }

      // hole
      //
      if (n.name () == "hole" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< hole_type > r (
          hole_traits::create (i, f, this));

        this->hole_.push_back (::std::move (r));
        continue;
      }

      // arrow
      //
      if (n.name () == "arrow" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< arrow_type > r (
          arrow_traits::create (i, f, this));

        this->arrow_.push_back (::std::move (r));
        continue;
      }

      // handbell
      //
      if (n.name () == "handbell" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< handbell_type > r (
          handbell_traits::create (i, f, this));

        this->handbell_.push_back (::std::move (r));
        continue;
      }

      // brass-bend
      //
      if (n.name () == "brass-bend" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< brass_bend_type > r (
          brass_bend_traits::create (i, f, this));

        this->brass_bend_.push_back (::std::move (r));
        continue;
      }

      // flip
      //
      if (n.name () == "flip" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< flip_type > r (
          flip_traits::create (i, f, this));

        this->flip_.push_back (::std::move (r));
        continue;
      }

      // smear
      //
      if (n.name () == "smear" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< smear_type > r (
          smear_traits::create (i, f, this));

        this->smear_.push_back (::std::move (r));
        continue;
      }

      // open
      //
      if (n.name () == "open" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< open_type > r (
          open_traits::create (i, f, this));

        this->open_.push_back (::std::move (r));
        continue;
      }

      // half-muted
      //
      if (n.name () == "half-muted" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< half_muted_type > r (
          half_muted_traits::create (i, f, this));

        this->half_muted_.push_back (::std::move (r));
        continue;
      }

      // harmon-mute
      //
      if (n.name () == "harmon-mute" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harmon_mute_type > r (
          harmon_mute_traits::create (i, f, this));

        this->harmon_mute_.push_back (::std::move (r));
        continue;
      }

      // golpe
      //
      if (n.name () == "golpe" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< golpe_type > r (
          golpe_traits::create (i, f, this));

        this->golpe_.push_back (::std::move (r));
        continue;
      }

      // other-technical
      //
      if (n.name () == "other-technical" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< other_technical_type > r (
          other_technical_traits::create (i, f, this));

        this->other_technical_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  technical* technical::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class technical (*this, f, c);
  }

  technical& technical::
  operator= (const technical& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->up_bow_ = x.up_bow_;
      this->down_bow_ = x.down_bow_;
      this->harmonic_ = x.harmonic_;
      this->open_string_ = x.open_string_;
      this->thumb_position_ = x.thumb_position_;
      this->fingering_ = x.fingering_;
      this->pluck_ = x.pluck_;
      this->double_tongue_ = x.double_tongue_;
      this->triple_tongue_ = x.triple_tongue_;
      this->stopped_ = x.stopped_;
      this->snap_pizzicato_ = x.snap_pizzicato_;
      this->fret_ = x.fret_;
      this->string_ = x.string_;
      this->hammer_on_ = x.hammer_on_;
      this->pull_off_ = x.pull_off_;
      this->bend_ = x.bend_;
      this->tap_ = x.tap_;
      this->heel_ = x.heel_;
      this->toe_ = x.toe_;
      this->fingernails_ = x.fingernails_;
      this->hole_ = x.hole_;
      this->arrow_ = x.arrow_;
      this->handbell_ = x.handbell_;
      this->brass_bend_ = x.brass_bend_;
      this->flip_ = x.flip_;
      this->smear_ = x.smear_;
      this->open_ = x.open_;
      this->half_muted_ = x.half_muted_;
      this->harmon_mute_ = x.harmon_mute_;
      this->golpe_ = x.golpe_;
      this->other_technical_ = x.other_technical_;
      this->id_ = x.id_;
    }

    return *this;
  }

  technical::
  ~technical ()
  {
  }

  // text_element_data
  //

  text_element_data::
  text_element_data ()
  : ::xml_schema::string (),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    lang_ (this),
    dir_ (this)
  {
  }

  text_element_data::
  text_element_data (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    lang_ (this),
    dir_ (this)
  {
  }

  text_element_data::
  text_element_data (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    lang_ (this),
    dir_ (this)
  {
  }

  text_element_data::
  text_element_data (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    lang_ (this),
    dir_ (this)
  {
  }

  text_element_data::
  text_element_data (const text_element_data& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    underline_ (x.underline_, f, this),
    overline_ (x.overline_, f, this),
    line_through_ (x.line_through_, f, this),
    rotation_ (x.rotation_, f, this),
    letter_spacing_ (x.letter_spacing_, f, this),
    lang_ (x.lang_, f, this),
    dir_ (x.dir_, f, this)
  {
  }

  text_element_data::
  text_element_data (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    underline_ (this),
    overline_ (this),
    line_through_ (this),
    rotation_ (this),
    letter_spacing_ (this),
    lang_ (this),
    dir_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void text_element_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "underline" && n.namespace_ ().empty ())
      {
        this->underline_.set (underline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "overline" && n.namespace_ ().empty ())
      {
        this->overline_.set (overline_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-through" && n.namespace_ ().empty ())
      {
        this->line_through_.set (line_through_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "rotation" && n.namespace_ ().empty ())
      {
        this->rotation_.set (rotation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "letter-spacing" && n.namespace_ ().empty ())
      {
        this->letter_spacing_.set (letter_spacing_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dir" && n.namespace_ ().empty ())
      {
        this->dir_.set (dir_traits::create (i, f, this));
        continue;
      }
    }
  }

  text_element_data* text_element_data::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class text_element_data (*this, f, c);
  }

  text_element_data& text_element_data::
  operator= (const text_element_data& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->underline_ = x.underline_;
      this->overline_ = x.overline_;
      this->line_through_ = x.line_through_;
      this->rotation_ = x.rotation_;
      this->letter_spacing_ = x.letter_spacing_;
      this->lang_ = x.lang_;
      this->dir_ = x.dir_;
    }

    return *this;
  }

  text_element_data::
  ~text_element_data ()
  {
  }

  // tie
  //

  tie::
  tie (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    time_only_ (this)
  {
  }

  tie::
  tie (const tie& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    time_only_ (x.time_only_, f, this)
  {
  }

  tie::
  tie (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    time_only_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tie::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tie* tie::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tie (*this, f, c);
  }

  tie& tie::
  operator= (const tie& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->time_only_ = x.time_only_;
    }

    return *this;
  }

  tie::
  ~tie ()
  {
  }

  // tied
  //

  tied::
  tied (const type_type& type)
  : ::xml_schema::type (),
    type_ (type, this),
    number_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    orientation_ (this),
    bezier_x_ (this),
    bezier_y_ (this),
    bezier_x2_ (this),
    bezier_y2_ (this),
    bezier_offset_ (this),
    bezier_offset2_ (this),
    color_ (this),
    id_ (this)
  {
  }

  tied::
  tied (const tied& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    line_type_ (x.line_type_, f, this),
    dash_length_ (x.dash_length_, f, this),
    space_length_ (x.space_length_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    orientation_ (x.orientation_, f, this),
    bezier_x_ (x.bezier_x_, f, this),
    bezier_y_ (x.bezier_y_, f, this),
    bezier_x2_ (x.bezier_x2_, f, this),
    bezier_y2_ (x.bezier_y2_, f, this),
    bezier_offset_ (x.bezier_offset_, f, this),
    bezier_offset2_ (x.bezier_offset2_, f, this),
    color_ (x.color_, f, this),
    id_ (x.id_, f, this)
  {
  }

  tied::
  tied (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    number_ (this),
    line_type_ (this),
    dash_length_ (this),
    space_length_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    orientation_ (this),
    bezier_x_ (this),
    bezier_y_ (this),
    bezier_x2_ (this),
    bezier_y2_ (this),
    bezier_offset_ (this),
    bezier_offset2_ (this),
    color_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tied::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-type" && n.namespace_ ().empty ())
      {
        this->line_type_.set (line_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dash-length" && n.namespace_ ().empty ())
      {
        this->dash_length_.set (dash_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "space-length" && n.namespace_ ().empty ())
      {
        this->space_length_.set (space_length_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "orientation" && n.namespace_ ().empty ())
      {
        this->orientation_.set (orientation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-x" && n.namespace_ ().empty ())
      {
        this->bezier_x_.set (bezier_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-y" && n.namespace_ ().empty ())
      {
        this->bezier_y_.set (bezier_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-x2" && n.namespace_ ().empty ())
      {
        this->bezier_x2_.set (bezier_x2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-y2" && n.namespace_ ().empty ())
      {
        this->bezier_y2_.set (bezier_y2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-offset" && n.namespace_ ().empty ())
      {
        this->bezier_offset_.set (bezier_offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bezier-offset2" && n.namespace_ ().empty ())
      {
        this->bezier_offset2_.set (bezier_offset2_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tied* tied::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tied (*this, f, c);
  }

  tied& tied::
  operator= (const tied& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->line_type_ = x.line_type_;
      this->dash_length_ = x.dash_length_;
      this->space_length_ = x.space_length_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->orientation_ = x.orientation_;
      this->bezier_x_ = x.bezier_x_;
      this->bezier_y_ = x.bezier_y_;
      this->bezier_x2_ = x.bezier_x2_;
      this->bezier_y2_ = x.bezier_y2_;
      this->bezier_offset_ = x.bezier_offset_;
      this->bezier_offset2_ = x.bezier_offset2_;
      this->color_ = x.color_;
      this->id_ = x.id_;
    }

    return *this;
  }

  tied::
  ~tied ()
  {
  }

  // tremolo
  //

  const tremolo::type_type tremolo::type_default_value_ (
    "single");

  tremolo::
  tremolo (const ::xml_schema::integer& _xsd_integer_base)
  : ::musicxml::tremolo_marks (_xsd_integer_base),
    type_ (type_default_value (), this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
  }

  tremolo::
  tremolo (const tremolo& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::tremolo_marks (x, f, c),
    type_ (x.type_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    placement_ (x.placement_, f, this),
    smufl_ (x.smufl_, f, this)
  {
  }

  tremolo::
  tremolo (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::musicxml::tremolo_marks (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    placement_ (this),
    smufl_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tremolo::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "smufl" && n.namespace_ ().empty ())
      {
        this->smufl_.set (smufl_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }
  }

  tremolo* tremolo::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tremolo (*this, f, c);
  }

  tremolo& tremolo::
  operator= (const tremolo& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::tremolo_marks& > (*this) = x;
      this->type_ = x.type_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->placement_ = x.placement_;
      this->smufl_ = x.smufl_;
    }

    return *this;
  }

  tremolo::
  ~tremolo ()
  {
  }

  // tuplet
  //

  tuplet::
  tuplet (const type_type& type)
  : ::xml_schema::type (),
    tuplet_actual_ (this),
    tuplet_normal_ (this),
    type_ (type, this),
    number_ (this),
    bracket_ (this),
    show_number_ (this),
    show_type_ (this),
    line_shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    id_ (this)
  {
  }

  tuplet::
  tuplet (const tuplet& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tuplet_actual_ (x.tuplet_actual_, f, this),
    tuplet_normal_ (x.tuplet_normal_, f, this),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this),
    bracket_ (x.bracket_, f, this),
    show_number_ (x.show_number_, f, this),
    show_type_ (x.show_type_, f, this),
    line_shape_ (x.line_shape_, f, this),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    placement_ (x.placement_, f, this),
    id_ (x.id_, f, this)
  {
  }

  tuplet::
  tuplet (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tuplet_actual_ (this),
    tuplet_normal_ (this),
    type_ (this),
    number_ (this),
    bracket_ (this),
    show_number_ (this),
    show_type_ (this),
    line_shape_ (this),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    placement_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void tuplet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tuplet-actual
      //
      if (n.name () == "tuplet-actual" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_actual_type > r (
          tuplet_actual_traits::create (i, f, this));

        if (!this->tuplet_actual_)
        {
          this->tuplet_actual_.set (::std::move (r));
          continue;
        }
      }

      // tuplet-normal
      //
      if (n.name () == "tuplet-normal" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_normal_type > r (
          tuplet_normal_traits::create (i, f, this));

        if (!this->tuplet_normal_)
        {
          this->tuplet_normal_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "bracket" && n.namespace_ ().empty ())
      {
        this->bracket_.set (bracket_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show-number" && n.namespace_ ().empty ())
      {
        this->show_number_.set (show_number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show-type" && n.namespace_ ().empty ())
      {
        this->show_type_.set (show_type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "line-shape" && n.namespace_ ().empty ())
      {
        this->line_shape_.set (line_shape_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "placement" && n.namespace_ ().empty ())
      {
        this->placement_.set (placement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  tuplet* tuplet::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuplet (*this, f, c);
  }

  tuplet& tuplet::
  operator= (const tuplet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tuplet_actual_ = x.tuplet_actual_;
      this->tuplet_normal_ = x.tuplet_normal_;
      this->type_ = x.type_;
      this->number_ = x.number_;
      this->bracket_ = x.bracket_;
      this->show_number_ = x.show_number_;
      this->show_type_ = x.show_type_;
      this->line_shape_ = x.line_shape_;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->placement_ = x.placement_;
      this->id_ = x.id_;
    }

    return *this;
  }

  tuplet::
  ~tuplet ()
  {
  }

  // tuplet_dot
  //

  tuplet_dot::
  tuplet_dot ()
  : ::xml_schema::type (),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_dot::
  tuplet_dot (const tuplet_dot& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  tuplet_dot::
  tuplet_dot (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tuplet_dot::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  tuplet_dot* tuplet_dot::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuplet_dot (*this, f, c);
  }

  tuplet_dot& tuplet_dot::
  operator= (const tuplet_dot& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  tuplet_dot::
  ~tuplet_dot ()
  {
  }

  // tuplet_number
  //

  tuplet_number::
  tuplet_number (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_number::
  tuplet_number (const tuplet_number& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  tuplet_number::
  tuplet_number (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tuplet_number::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  tuplet_number* tuplet_number::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuplet_number (*this, f, c);
  }

  tuplet_number& tuplet_number::
  operator= (const tuplet_number& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  tuplet_number::
  ~tuplet_number ()
  {
  }

  // tuplet_portion
  //

  tuplet_portion::
  tuplet_portion ()
  : ::xml_schema::type (),
    tuplet_number_ (this),
    tuplet_type_ (this),
    tuplet_dot_ (this)
  {
  }

  tuplet_portion::
  tuplet_portion (const tuplet_portion& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tuplet_number_ (x.tuplet_number_, f, this),
    tuplet_type_ (x.tuplet_type_, f, this),
    tuplet_dot_ (x.tuplet_dot_, f, this)
  {
  }

  tuplet_portion::
  tuplet_portion (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tuplet_number_ (this),
    tuplet_type_ (this),
    tuplet_dot_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tuplet_portion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tuplet-number
      //
      if (n.name () == "tuplet-number" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_number_type > r (
          tuplet_number_traits::create (i, f, this));

        if (!this->tuplet_number_)
        {
          this->tuplet_number_.set (::std::move (r));
          continue;
        }
      }

      // tuplet-type
      //
      if (n.name () == "tuplet-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_type_type > r (
          tuplet_type_traits::create (i, f, this));

        if (!this->tuplet_type_)
        {
          this->tuplet_type_.set (::std::move (r));
          continue;
        }
      }

      // tuplet-dot
      //
      if (n.name () == "tuplet-dot" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< tuplet_dot_type > r (
          tuplet_dot_traits::create (i, f, this));

        this->tuplet_dot_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  tuplet_portion* tuplet_portion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuplet_portion (*this, f, c);
  }

  tuplet_portion& tuplet_portion::
  operator= (const tuplet_portion& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tuplet_number_ = x.tuplet_number_;
      this->tuplet_type_ = x.tuplet_type_;
      this->tuplet_dot_ = x.tuplet_dot_;
    }

    return *this;
  }

  tuplet_portion::
  ~tuplet_portion ()
  {
  }

  // tuplet_type
  //

  tuplet_type::
  tuplet_type (::musicxml::note_type_value::value _xsd_note_type_value_base)
  : ::musicxml::note_type_value (_xsd_note_type_value_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_type::
  tuplet_type (const char* _xsd_string_base)
  : ::musicxml::note_type_value (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_type::
  tuplet_type (const ::std::string& _xsd_string_base)
  : ::musicxml::note_type_value (_xsd_string_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_type::
  tuplet_type (const ::musicxml::note_type_value& _xsd_note_type_value_base)
  : ::musicxml::note_type_value (_xsd_note_type_value_base),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
  }

  tuplet_type::
  tuplet_type (const tuplet_type& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::note_type_value (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this)
  {
  }

  tuplet_type::
  tuplet_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::musicxml::note_type_value (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void tuplet_type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  tuplet_type* tuplet_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tuplet_type (*this, f, c);
  }

  tuplet_type& tuplet_type::
  operator= (const tuplet_type& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::note_type_value& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
    }

    return *this;
  }

  tuplet_type::
  ~tuplet_type ()
  {
  }

  // unpitched
  //

  unpitched::
  unpitched ()
  : ::xml_schema::type (),
    display_step_ (this),
    display_octave_ (this)
  {
  }

  unpitched::
  unpitched (const unpitched& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    display_step_ (x.display_step_, f, this),
    display_octave_ (x.display_octave_, f, this)
  {
  }

  unpitched::
  unpitched (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    display_step_ (this),
    display_octave_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void unpitched::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // display-step
      //
      if (n.name () == "display-step" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_step_type > r (
          display_step_traits::create (i, f, this));

        if (!this->display_step_)
        {
          this->display_step_.set (::std::move (r));
          continue;
        }
      }

      // display-octave
      //
      if (n.name () == "display-octave" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< display_octave_type > r (
          display_octave_traits::create (i, f, this));

        if (!this->display_octave_)
        {
          this->display_octave_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  unpitched* unpitched::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class unpitched (*this, f, c);
  }

  unpitched& unpitched::
  operator= (const unpitched& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->display_step_ = x.display_step_;
      this->display_octave_ = x.display_octave_;
    }

    return *this;
  }

  unpitched::
  ~unpitched ()
  {
  }

  // wait
  //

  wait::
  wait ()
  : ::xml_schema::type (),
    player_ (this),
    time_only_ (this)
  {
  }

  wait::
  wait (const wait& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    player_ (x.player_, f, this),
    time_only_ (x.time_only_, f, this)
  {
  }

  wait::
  wait (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    player_ (this),
    time_only_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void wait::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "player" && n.namespace_ ().empty ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "time-only" && n.namespace_ ().empty ())
      {
        this->time_only_.set (time_only_traits::create (i, f, this));
        continue;
      }
    }
  }

  wait* wait::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wait (*this, f, c);
  }

  wait& wait::
  operator= (const wait& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->player_ = x.player_;
      this->time_only_ = x.time_only_;
    }

    return *this;
  }

  wait::
  ~wait ()
  {
  }

  // credit
  //

  credit::
  credit ()
  : ::xml_schema::type (),
    credit_type_ (this),
    link_ (this),
    bookmark_ (this),
    credit_image_ (this),
    credit_words_ (this),
    credit_symbol_ (this),
    page_ (this),
    id_ (this)
  {
  }

  credit::
  credit (const credit& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    credit_type_ (x.credit_type_, f, this),
    link_ (x.link_, f, this),
    bookmark_ (x.bookmark_, f, this),
    credit_image_ (x.credit_image_, f, this),
    credit_words_ (x.credit_words_, f, this),
    credit_symbol_ (x.credit_symbol_, f, this),
    page_ (x.page_, f, this),
    id_ (x.id_, f, this)
  {
  }

  credit::
  credit (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    credit_type_ (this),
    link_ (this),
    bookmark_ (this),
    credit_image_ (this),
    credit_words_ (this),
    credit_symbol_ (this),
    page_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void credit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // credit-type
      //
      if (n.name () == "credit-type" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_type_type > r (
          credit_type_traits::create (i, f, this));

        this->credit_type_.push_back (::std::move (r));
        continue;
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< link_type > r (
          link_traits::create (i, f, this));

        this->link_.push_back (::std::move (r));
        continue;
      }

      // bookmark
      //
      if (n.name () == "bookmark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bookmark_type > r (
          bookmark_traits::create (i, f, this));

        this->bookmark_.push_back (::std::move (r));
        continue;
      }

      // credit-image
      //
      if (n.name () == "credit-image" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_image_type > r (
          credit_image_traits::create (i, f, this));

        if (!this->credit_image_)
        {
          this->credit_image_.set (::std::move (r));
          continue;
        }
      }

      // credit-words
      //
      if (n.name () == "credit-words" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_words_type > r (
          credit_words_traits::create (i, f, this));

        this->credit_words_.push_back (::std::move (r));
        continue;
      }

      // credit-symbol
      //
      if (n.name () == "credit-symbol" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_symbol_type > r (
          credit_symbol_traits::create (i, f, this));

        this->credit_symbol_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "page" && n.namespace_ ().empty ())
      {
        this->page_.set (page_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }
  }

  credit* credit::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class credit (*this, f, c);
  }

  credit& credit::
  operator= (const credit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->credit_type_ = x.credit_type_;
      this->link_ = x.link_;
      this->bookmark_ = x.bookmark_;
      this->credit_image_ = x.credit_image_;
      this->credit_words_ = x.credit_words_;
      this->credit_symbol_ = x.credit_symbol_;
      this->page_ = x.page_;
      this->id_ = x.id_;
    }

    return *this;
  }

  credit::
  ~credit ()
  {
  }

  // defaults
  //

  defaults::
  defaults ()
  : ::xml_schema::type (),
    scaling_ (this),
    concert_score_ (this),
    page_layout_ (this),
    system_layout_ (this),
    staff_layout_ (this),
    appearance_ (this),
    music_font_ (this),
    word_font_ (this),
    lyric_font_ (this),
    lyric_language_ (this)
  {
  }

  defaults::
  defaults (const defaults& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    scaling_ (x.scaling_, f, this),
    concert_score_ (x.concert_score_, f, this),
    page_layout_ (x.page_layout_, f, this),
    system_layout_ (x.system_layout_, f, this),
    staff_layout_ (x.staff_layout_, f, this),
    appearance_ (x.appearance_, f, this),
    music_font_ (x.music_font_, f, this),
    word_font_ (x.word_font_, f, this),
    lyric_font_ (x.lyric_font_, f, this),
    lyric_language_ (x.lyric_language_, f, this)
  {
  }

  defaults::
  defaults (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    scaling_ (this),
    concert_score_ (this),
    page_layout_ (this),
    system_layout_ (this),
    staff_layout_ (this),
    appearance_ (this),
    music_font_ (this),
    word_font_ (this),
    lyric_font_ (this),
    lyric_language_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void defaults::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // scaling
      //
      if (n.name () == "scaling" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< scaling_type > r (
          scaling_traits::create (i, f, this));

        if (!this->scaling_)
        {
          this->scaling_.set (::std::move (r));
          continue;
        }
      }

      // concert-score
      //
      if (n.name () == "concert-score" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< concert_score_type > r (
          concert_score_traits::create (i, f, this));

        if (!this->concert_score_)
        {
          this->concert_score_.set (::std::move (r));
          continue;
        }
      }

      // page-layout
      //
      if (n.name () == "page-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< page_layout_type > r (
          page_layout_traits::create (i, f, this));

        if (!this->page_layout_)
        {
          this->page_layout_.set (::std::move (r));
          continue;
        }
      }

      // system-layout
      //
      if (n.name () == "system-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< system_layout_type > r (
          system_layout_traits::create (i, f, this));

        if (!this->system_layout_)
        {
          this->system_layout_.set (::std::move (r));
          continue;
        }
      }

      // staff-layout
      //
      if (n.name () == "staff-layout" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< staff_layout_type > r (
          staff_layout_traits::create (i, f, this));

        this->staff_layout_.push_back (::std::move (r));
        continue;
      }

      // appearance
      //
      if (n.name () == "appearance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< appearance_type > r (
          appearance_traits::create (i, f, this));

        if (!this->appearance_)
        {
          this->appearance_.set (::std::move (r));
          continue;
        }
      }

      // music-font
      //
      if (n.name () == "music-font" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< music_font_type > r (
          music_font_traits::create (i, f, this));

        if (!this->music_font_)
        {
          this->music_font_.set (::std::move (r));
          continue;
        }
      }

      // word-font
      //
      if (n.name () == "word-font" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< word_font_type > r (
          word_font_traits::create (i, f, this));

        if (!this->word_font_)
        {
          this->word_font_.set (::std::move (r));
          continue;
        }
      }

      // lyric-font
      //
      if (n.name () == "lyric-font" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< lyric_font_type > r (
          lyric_font_traits::create (i, f, this));

        this->lyric_font_.push_back (::std::move (r));
        continue;
      }

      // lyric-language
      //
      if (n.name () == "lyric-language" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< lyric_language_type > r (
          lyric_language_traits::create (i, f, this));

        this->lyric_language_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  defaults* defaults::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class defaults (*this, f, c);
  }

  defaults& defaults::
  operator= (const defaults& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->scaling_ = x.scaling_;
      this->concert_score_ = x.concert_score_;
      this->page_layout_ = x.page_layout_;
      this->system_layout_ = x.system_layout_;
      this->staff_layout_ = x.staff_layout_;
      this->appearance_ = x.appearance_;
      this->music_font_ = x.music_font_;
      this->word_font_ = x.word_font_;
      this->lyric_font_ = x.lyric_font_;
      this->lyric_language_ = x.lyric_language_;
    }

    return *this;
  }

  defaults::
  ~defaults ()
  {
  }

  // empty_font
  //

  empty_font::
  empty_font ()
  : ::xml_schema::type (),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  empty_font::
  empty_font (const empty_font& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this)
  {
  }

  empty_font::
  empty_font (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void empty_font::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }
    }
  }

  empty_font* empty_font::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class empty_font (*this, f, c);
  }

  empty_font& empty_font::
  operator= (const empty_font& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
    }

    return *this;
  }

  empty_font::
  ~empty_font ()
  {
  }

  // group_barline
  //

  group_barline::
  group_barline (::musicxml::group_barline_value::value _xsd_group_barline_value_base)
  : ::musicxml::group_barline_value (_xsd_group_barline_value_base),
    color_ (this)
  {
  }

  group_barline::
  group_barline (const char* _xsd_string_base)
  : ::musicxml::group_barline_value (_xsd_string_base),
    color_ (this)
  {
  }

  group_barline::
  group_barline (const ::std::string& _xsd_string_base)
  : ::musicxml::group_barline_value (_xsd_string_base),
    color_ (this)
  {
  }

  group_barline::
  group_barline (const ::musicxml::group_barline_value& _xsd_group_barline_value_base)
  : ::musicxml::group_barline_value (_xsd_group_barline_value_base),
    color_ (this)
  {
  }

  group_barline::
  group_barline (const group_barline& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::group_barline_value (x, f, c),
    color_ (x.color_, f, this)
  {
  }

  group_barline::
  group_barline (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::musicxml::group_barline_value (e, f | ::xml_schema::flags::base, c),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void group_barline::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  group_barline* group_barline::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group_barline (*this, f, c);
  }

  group_barline& group_barline::
  operator= (const group_barline& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::group_barline_value& > (*this) = x;
      this->color_ = x.color_;
    }

    return *this;
  }

  group_barline::
  ~group_barline ()
  {
  }

  // group_name
  //

  group_name::
  group_name ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    justify_ (this)
  {
  }

  group_name::
  group_name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    justify_ (this)
  {
  }

  group_name::
  group_name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    justify_ (this)
  {
  }

  group_name::
  group_name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    justify_ (this)
  {
  }

  group_name::
  group_name (const group_name& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    justify_ (x.justify_, f, this)
  {
  }

  group_name::
  group_name (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    justify_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void group_name::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }
    }
  }

  group_name* group_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group_name (*this, f, c);
  }

  group_name& group_name::
  operator= (const group_name& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->justify_ = x.justify_;
    }

    return *this;
  }

  group_name::
  ~group_name ()
  {
  }

  // group_symbol
  //

  group_symbol::
  group_symbol (::musicxml::group_symbol_value::value _xsd_group_symbol_value_base)
  : ::musicxml::group_symbol_value (_xsd_group_symbol_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  group_symbol::
  group_symbol (const char* _xsd_string_base)
  : ::musicxml::group_symbol_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  group_symbol::
  group_symbol (const ::std::string& _xsd_string_base)
  : ::musicxml::group_symbol_value (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  group_symbol::
  group_symbol (const ::musicxml::group_symbol_value& _xsd_group_symbol_value_base)
  : ::musicxml::group_symbol_value (_xsd_group_symbol_value_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
  }

  group_symbol::
  group_symbol (const group_symbol& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::group_symbol_value (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    color_ (x.color_, f, this)
  {
  }

  group_symbol::
  group_symbol (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::musicxml::group_symbol_value (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    color_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void group_symbol::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }
    }
  }

  group_symbol* group_symbol::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class group_symbol (*this, f, c);
  }

  group_symbol& group_symbol::
  operator= (const group_symbol& x)
  {
    if (this != &x)
    {
      static_cast< ::musicxml::group_symbol_value& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->color_ = x.color_;
    }

    return *this;
  }

  group_symbol::
  ~group_symbol ()
  {
  }

  // instrument_link
  //

  instrument_link::
  instrument_link (const id_type& id)
  : ::xml_schema::type (),
    id_ (id, this)
  {
  }

  instrument_link::
  instrument_link (const instrument_link& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  instrument_link::
  instrument_link (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void instrument_link::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  instrument_link* instrument_link::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class instrument_link (*this, f, c);
  }

  instrument_link& instrument_link::
  operator= (const instrument_link& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  instrument_link::
  ~instrument_link ()
  {
  }

  // lyric_font
  //

  lyric_font::
  lyric_font ()
  : ::xml_schema::type (),
    number_ (this),
    name_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
  }

  lyric_font::
  lyric_font (const lyric_font& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this),
    name_ (x.name_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this)
  {
  }

  lyric_font::
  lyric_font (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    name_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void lyric_font::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }
    }
  }

  lyric_font* lyric_font::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lyric_font (*this, f, c);
  }

  lyric_font& lyric_font::
  operator= (const lyric_font& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
      this->name_ = x.name_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
    }

    return *this;
  }

  lyric_font::
  ~lyric_font ()
  {
  }

  // lyric_language
  //

  lyric_language::
  lyric_language (const lang_type& lang)
  : ::xml_schema::type (),
    number_ (this),
    name_ (this),
    lang_ (lang, this)
  {
  }

  lyric_language::
  lyric_language (const lyric_language& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    number_ (x.number_, f, this),
    name_ (x.name_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  lyric_language::
  lyric_language (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    number_ (this),
    name_ (this),
    lang_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void lyric_language::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }
    }

    if (!lang_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lang",
        "http://www.w3.org/XML/1998/namespace");
    }
  }

  lyric_language* lyric_language::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class lyric_language (*this, f, c);
  }

  lyric_language& lyric_language::
  operator= (const lyric_language& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->number_ = x.number_;
      this->name_ = x.name_;
      this->lang_ = x.lang_;
    }

    return *this;
  }

  lyric_language::
  ~lyric_language ()
  {
  }

  // opus
  //

  const opus::type_type opus::type_default_value_ (
    "simple");

  const opus::show_type opus::show_default_value_ (
    "replace");

  const opus::actuate_type opus::actuate_default_value_ (
    "onRequest");

  opus::
  opus (const href_type& href)
  : ::xml_schema::type (),
    href_ (href, this),
    type_ (type_default_value (), this),
    role_ (this),
    title_ (this),
    show_ (show_default_value (), this),
    actuate_ (actuate_default_value (), this)
  {
  }

  opus::
  opus (const opus& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    href_ (x.href_, f, this),
    type_ (x.type_, f, this),
    role_ (x.role_, f, this),
    title_ (x.title_, f, this),
    show_ (x.show_, f, this),
    actuate_ (x.actuate_, f, this)
  {
  }

  opus::
  opus (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    href_ (this),
    type_ (this),
    role_ (this),
    title_ (this),
    show_ (this),
    actuate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void opus::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "role" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->role_.set (role_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "title" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->title_.set (title_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->show_.set (show_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "actuate" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->actuate_.set (actuate_traits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "http://www.w3.org/1999/xlink");
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!show_.present ())
    {
      this->show_.set (show_default_value ());
    }

    if (!actuate_.present ())
    {
      this->actuate_.set (actuate_default_value ());
    }
  }

  opus* opus::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class opus (*this, f, c);
  }

  opus& opus::
  operator= (const opus& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->href_ = x.href_;
      this->type_ = x.type_;
      this->role_ = x.role_;
      this->title_ = x.title_;
      this->show_ = x.show_;
      this->actuate_ = x.actuate_;
    }

    return *this;
  }

  opus::
  ~opus ()
  {
  }

  // part_group
  //

  const part_group::number_type part_group::number_default_value_ (
    "1");

  part_group::
  part_group (const type_type& type)
  : ::xml_schema::type (),
    group_name_ (this),
    group_name_display_ (this),
    group_abbreviation_ (this),
    group_abbreviation_display_ (this),
    group_symbol_ (this),
    group_barline_ (this),
    group_time_ (this),
    footnote_ (this),
    level_ (this),
    type_ (type, this),
    number_ (number_default_value (), this)
  {
  }

  part_group::
  part_group (const part_group& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    group_name_ (x.group_name_, f, this),
    group_name_display_ (x.group_name_display_, f, this),
    group_abbreviation_ (x.group_abbreviation_, f, this),
    group_abbreviation_display_ (x.group_abbreviation_display_, f, this),
    group_symbol_ (x.group_symbol_, f, this),
    group_barline_ (x.group_barline_, f, this),
    group_time_ (x.group_time_, f, this),
    footnote_ (x.footnote_, f, this),
    level_ (x.level_, f, this),
    type_ (x.type_, f, this),
    number_ (x.number_, f, this)
  {
  }

  part_group::
  part_group (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    group_name_ (this),
    group_name_display_ (this),
    group_abbreviation_ (this),
    group_abbreviation_display_ (this),
    group_symbol_ (this),
    group_barline_ (this),
    group_time_ (this),
    footnote_ (this),
    level_ (this),
    type_ (this),
    number_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void part_group::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group-name
      //
      if (n.name () == "group-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_name_type > r (
          group_name_traits::create (i, f, this));

        if (!this->group_name_)
        {
          this->group_name_.set (::std::move (r));
          continue;
        }
      }

      // group-name-display
      //
      if (n.name () == "group-name-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_name_display_type > r (
          group_name_display_traits::create (i, f, this));

        if (!this->group_name_display_)
        {
          this->group_name_display_.set (::std::move (r));
          continue;
        }
      }

      // group-abbreviation
      //
      if (n.name () == "group-abbreviation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_abbreviation_type > r (
          group_abbreviation_traits::create (i, f, this));

        if (!this->group_abbreviation_)
        {
          this->group_abbreviation_.set (::std::move (r));
          continue;
        }
      }

      // group-abbreviation-display
      //
      if (n.name () == "group-abbreviation-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_abbreviation_display_type > r (
          group_abbreviation_display_traits::create (i, f, this));

        if (!this->group_abbreviation_display_)
        {
          this->group_abbreviation_display_.set (::std::move (r));
          continue;
        }
      }

      // group-symbol
      //
      if (n.name () == "group-symbol" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_symbol_type > r (
          group_symbol_traits::create (i, f, this));

        if (!this->group_symbol_)
        {
          this->group_symbol_.set (::std::move (r));
          continue;
        }
      }

      // group-barline
      //
      if (n.name () == "group-barline" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_barline_type > r (
          group_barline_traits::create (i, f, this));

        if (!this->group_barline_)
        {
          this->group_barline_.set (::std::move (r));
          continue;
        }
      }

      // group-time
      //
      if (n.name () == "group-time" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_time_type > r (
          group_time_traits::create (i, f, this));

        if (!this->group_time_)
        {
          this->group_time_.set (::std::move (r));
          continue;
        }
      }

      // footnote
      //
      if (n.name () == "footnote" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< footnote_type > r (
          footnote_traits::create (i, f, this));

        if (!this->footnote_)
        {
          this->footnote_.set (::std::move (r));
          continue;
        }
      }

      // level
      //
      if (n.name () == "level" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< level_type > r (
          level_traits::create (i, f, this));

        if (!this->level_)
        {
          this->level_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!number_.present ())
    {
      this->number_.set (number_default_value ());
    }
  }

  part_group* part_group::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_group (*this, f, c);
  }

  part_group& part_group::
  operator= (const part_group& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->group_name_ = x.group_name_;
      this->group_name_display_ = x.group_name_display_;
      this->group_abbreviation_ = x.group_abbreviation_;
      this->group_abbreviation_display_ = x.group_abbreviation_display_;
      this->group_symbol_ = x.group_symbol_;
      this->group_barline_ = x.group_barline_;
      this->group_time_ = x.group_time_;
      this->footnote_ = x.footnote_;
      this->level_ = x.level_;
      this->type_ = x.type_;
      this->number_ = x.number_;
    }

    return *this;
  }

  part_group::
  ~part_group ()
  {
  }

  // part_link
  //

  const part_link::type_type part_link::type_default_value_ (
    "simple");

  const part_link::show_type part_link::show_default_value_ (
    "replace");

  const part_link::actuate_type part_link::actuate_default_value_ (
    "onRequest");

  part_link::
  part_link (const href_type& href)
  : ::xml_schema::type (),
    instrument_link_ (this),
    group_link_ (this),
    href_ (href, this),
    type_ (type_default_value (), this),
    role_ (this),
    title_ (this),
    show_ (show_default_value (), this),
    actuate_ (actuate_default_value (), this)
  {
  }

  part_link::
  part_link (const part_link& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    instrument_link_ (x.instrument_link_, f, this),
    group_link_ (x.group_link_, f, this),
    href_ (x.href_, f, this),
    type_ (x.type_, f, this),
    role_ (x.role_, f, this),
    title_ (x.title_, f, this),
    show_ (x.show_, f, this),
    actuate_ (x.actuate_, f, this)
  {
  }

  part_link::
  part_link (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    instrument_link_ (this),
    group_link_ (this),
    href_ (this),
    type_ (this),
    role_ (this),
    title_ (this),
    show_ (this),
    actuate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void part_link::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instrument-link
      //
      if (n.name () == "instrument-link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_link_type > r (
          instrument_link_traits::create (i, f, this));

        this->instrument_link_.push_back (::std::move (r));
        continue;
      }

      // group-link
      //
      if (n.name () == "group-link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_link_type > r (
          group_link_traits::create (i, f, this));

        this->group_link_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "href" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->href_.set (href_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "role" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->role_.set (role_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "title" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->title_.set (title_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "show" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->show_.set (show_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "actuate" && n.namespace_ () == "http://www.w3.org/1999/xlink")
      {
        this->actuate_.set (actuate_traits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "href",
        "http://www.w3.org/1999/xlink");
    }

    if (!type_.present ())
    {
      this->type_.set (type_default_value ());
    }

    if (!show_.present ())
    {
      this->show_.set (show_default_value ());
    }

    if (!actuate_.present ())
    {
      this->actuate_.set (actuate_default_value ());
    }
  }

  part_link* part_link::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_link (*this, f, c);
  }

  part_link& part_link::
  operator= (const part_link& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->instrument_link_ = x.instrument_link_;
      this->group_link_ = x.group_link_;
      this->href_ = x.href_;
      this->type_ = x.type_;
      this->role_ = x.role_;
      this->title_ = x.title_;
      this->show_ = x.show_;
      this->actuate_ = x.actuate_;
    }

    return *this;
  }

  part_link::
  ~part_link ()
  {
  }

  // part_list
  //

  part_list::
  part_list ()
  : ::xml_schema::type (),
    part_group_ (this),
    score_part_ (this)
  {
  }

  part_list::
  part_list (const part_list& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    part_group_ (x.part_group_, f, this),
    score_part_ (x.score_part_, f, this)
  {
  }

  part_list::
  part_list (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    part_group_ (this),
    score_part_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void part_list::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // part-group
      //
      if (n.name () == "part-group" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_group_type > r (
          part_group_traits::create (i, f, this));

        this->part_group_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (part_group_id, this->part_group_.size () - 1));
        continue;
      }

      // score-part
      //
      if (n.name () == "score-part" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< score_part_type > r (
          score_part_traits::create (i, f, this));

        this->score_part_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (score_part_id, this->score_part_.size () - 1));
        continue;
      }

      break;
    }
  }

  part_list* part_list::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_list (*this, f, c);
  }

  part_list& part_list::
  operator= (const part_list& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->part_group_ = x.part_group_;
      this->score_part_ = x.score_part_;
    }

    return *this;
  }

  part_list::
  ~part_list ()
  {
  }

  // part_name
  //

  part_name::
  part_name ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    justify_ (this)
  {
  }

  part_name::
  part_name (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    justify_ (this)
  {
  }

  part_name::
  part_name (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    justify_ (this)
  {
  }

  part_name::
  part_name (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    justify_ (this)
  {
  }

  part_name::
  part_name (const part_name& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    print_object_ (x.print_object_, f, this),
    justify_ (x.justify_, f, this)
  {
  }

  part_name::
  part_name (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    print_object_ (this),
    justify_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void part_name::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "print-object" && n.namespace_ ().empty ())
      {
        this->print_object_.set (print_object_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "justify" && n.namespace_ ().empty ())
      {
        this->justify_.set (justify_traits::create (i, f, this));
        continue;
      }
    }
  }

  part_name* part_name::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part_name (*this, f, c);
  }

  part_name& part_name::
  operator= (const part_name& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->print_object_ = x.print_object_;
      this->justify_ = x.justify_;
    }

    return *this;
  }

  part_name::
  ~part_name ()
  {
  }

  // player
  //

  player::
  player (const player_name_type& player_name,
          const id_type& id)
  : ::xml_schema::type (),
    player_name_ (player_name, this),
    id_ (id, this)
  {
  }

  player::
  player (const player& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    player_name_ (x.player_name_, f, this),
    id_ (x.id_, f, this)
  {
  }

  player::
  player (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    player_name_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void player::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // player-name
      //
      if (n.name () == "player-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< player_name_type > r (
          player_name_traits::create (i, f, this));

        if (!player_name_.present ())
        {
          this->player_name_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!player_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "player-name",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  player* player::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class player (*this, f, c);
  }

  player& player::
  operator= (const player& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->player_name_ = x.player_name_;
      this->id_ = x.id_;
    }

    return *this;
  }

  player::
  ~player ()
  {
  }

  // score_instrument
  //

  score_instrument::
  score_instrument (const instrument_name_type& instrument_name,
                    const id_type& id)
  : ::xml_schema::type (),
    instrument_name_ (instrument_name, this),
    instrument_abbreviation_ (this),
    instrument_sound_ (this),
    solo_ (this),
    ensemble_ (this),
    virtual_instrument_ (this),
    id_ (id, this)
  {
  }

  score_instrument::
  score_instrument (const score_instrument& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    instrument_name_ (x.instrument_name_, f, this),
    instrument_abbreviation_ (x.instrument_abbreviation_, f, this),
    instrument_sound_ (x.instrument_sound_, f, this),
    solo_ (x.solo_, f, this),
    ensemble_ (x.ensemble_, f, this),
    virtual_instrument_ (x.virtual_instrument_, f, this),
    id_ (x.id_, f, this)
  {
  }

  score_instrument::
  score_instrument (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    instrument_name_ (this),
    instrument_abbreviation_ (this),
    instrument_sound_ (this),
    solo_ (this),
    ensemble_ (this),
    virtual_instrument_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void score_instrument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // instrument-name
      //
      if (n.name () == "instrument-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_name_type > r (
          instrument_name_traits::create (i, f, this));

        if (!instrument_name_.present ())
        {
          this->instrument_name_.set (::std::move (r));
          continue;
        }
      }

      // instrument-abbreviation
      //
      if (n.name () == "instrument-abbreviation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_abbreviation_type > r (
          instrument_abbreviation_traits::create (i, f, this));

        if (!this->instrument_abbreviation_)
        {
          this->instrument_abbreviation_.set (::std::move (r));
          continue;
        }
      }

      // instrument-sound
      //
      if (n.name () == "instrument-sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< instrument_sound_type > r (
          instrument_sound_traits::create (i, f, this));

        if (!this->instrument_sound_)
        {
          this->instrument_sound_.set (::std::move (r));
          continue;
        }
      }

      // solo
      //
      if (n.name () == "solo" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< solo_type > r (
          solo_traits::create (i, f, this));

        if (!this->solo_)
        {
          this->solo_.set (::std::move (r));
          continue;
        }
      }

      // ensemble
      //
      if (n.name () == "ensemble" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ensemble_type > r (
          ensemble_traits::create (i, f, this));

        if (!this->ensemble_)
        {
          this->ensemble_.set (::std::move (r));
          continue;
        }
      }

      // virtual-instrument
      //
      if (n.name () == "virtual-instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< virtual_instrument_type > r (
          virtual_instrument_traits::create (i, f, this));

        if (!this->virtual_instrument_)
        {
          this->virtual_instrument_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!instrument_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "instrument-name",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  score_instrument* score_instrument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class score_instrument (*this, f, c);
  }

  score_instrument& score_instrument::
  operator= (const score_instrument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->instrument_name_ = x.instrument_name_;
      this->instrument_abbreviation_ = x.instrument_abbreviation_;
      this->instrument_sound_ = x.instrument_sound_;
      this->solo_ = x.solo_;
      this->ensemble_ = x.ensemble_;
      this->virtual_instrument_ = x.virtual_instrument_;
      this->id_ = x.id_;
    }

    return *this;
  }

  score_instrument::
  ~score_instrument ()
  {
  }

  // score_part
  //

  score_part::
  score_part (const part_name_type& part_name,
              const id_type& id)
  : ::xml_schema::type (),
    identification_ (this),
    part_link_ (this),
    part_name_ (part_name, this),
    part_name_display_ (this),
    part_abbreviation_ (this),
    part_abbreviation_display_ (this),
    group_ (this),
    score_instrument_ (this),
    player_ (this),
    midi_device_ (this),
    midi_instrument_ (this),
    id_ (id, this)
  {
  }

  score_part::
  score_part (::std::unique_ptr< part_name_type > part_name,
              const id_type& id)
  : ::xml_schema::type (),
    identification_ (this),
    part_link_ (this),
    part_name_ (std::move (part_name), this),
    part_name_display_ (this),
    part_abbreviation_ (this),
    part_abbreviation_display_ (this),
    group_ (this),
    score_instrument_ (this),
    player_ (this),
    midi_device_ (this),
    midi_instrument_ (this),
    id_ (id, this)
  {
  }

  score_part::
  score_part (const score_part& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identification_ (x.identification_, f, this),
    part_link_ (x.part_link_, f, this),
    part_name_ (x.part_name_, f, this),
    part_name_display_ (x.part_name_display_, f, this),
    part_abbreviation_ (x.part_abbreviation_, f, this),
    part_abbreviation_display_ (x.part_abbreviation_display_, f, this),
    group_ (x.group_, f, this),
    score_instrument_ (x.score_instrument_, f, this),
    player_ (x.player_, f, this),
    midi_device_ (x.midi_device_, f, this),
    midi_instrument_ (x.midi_instrument_, f, this),
    id_ (x.id_, f, this)
  {
  }

  score_part::
  score_part (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identification_ (this),
    part_link_ (this),
    part_name_ (this),
    part_name_display_ (this),
    part_abbreviation_ (this),
    part_abbreviation_display_ (this),
    group_ (this),
    score_instrument_ (this),
    player_ (this),
    midi_device_ (this),
    midi_instrument_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void score_part::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identification
      //
      if (n.name () == "identification" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< identification_type > r (
          identification_traits::create (i, f, this));

        if (!this->identification_)
        {
          this->identification_.set (::std::move (r));
          continue;
        }
      }

      // part-link
      //
      if (n.name () == "part-link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_link_type > r (
          part_link_traits::create (i, f, this));

        this->part_link_.push_back (::std::move (r));
        continue;
      }

      // part-name
      //
      if (n.name () == "part-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_name_type > r (
          part_name_traits::create (i, f, this));

        if (!part_name_.present ())
        {
          this->part_name_.set (::std::move (r));
          continue;
        }
      }

      // part-name-display
      //
      if (n.name () == "part-name-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_name_display_type > r (
          part_name_display_traits::create (i, f, this));

        if (!this->part_name_display_)
        {
          this->part_name_display_.set (::std::move (r));
          continue;
        }
      }

      // part-abbreviation
      //
      if (n.name () == "part-abbreviation" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_abbreviation_type > r (
          part_abbreviation_traits::create (i, f, this));

        if (!this->part_abbreviation_)
        {
          this->part_abbreviation_.set (::std::move (r));
          continue;
        }
      }

      // part-abbreviation-display
      //
      if (n.name () == "part-abbreviation-display" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_abbreviation_display_type > r (
          part_abbreviation_display_traits::create (i, f, this));

        if (!this->part_abbreviation_display_)
        {
          this->part_abbreviation_display_.set (::std::move (r));
          continue;
        }
      }

      // group
      //
      if (n.name () == "group" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< group_type > r (
          group_traits::create (i, f, this));

        this->group_.push_back (::std::move (r));
        continue;
      }

      // score-instrument
      //
      if (n.name () == "score-instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< score_instrument_type > r (
          score_instrument_traits::create (i, f, this));

        this->score_instrument_.push_back (::std::move (r));
        continue;
      }

      // player
      //
      if (n.name () == "player" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< player_type > r (
          player_traits::create (i, f, this));

        this->player_.push_back (::std::move (r));
        continue;
      }

      // midi-device
      //
      if (n.name () == "midi-device" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_device_type > r (
          midi_device_traits::create (i, f, this));

        this->midi_device_.push_back (::std::move (r));
        continue;
      }

      // midi-instrument
      //
      if (n.name () == "midi-instrument" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< midi_instrument_type > r (
          midi_instrument_traits::create (i, f, this));

        this->midi_instrument_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!part_name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "part-name",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  score_part* score_part::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class score_part (*this, f, c);
  }

  score_part& score_part::
  operator= (const score_part& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->identification_ = x.identification_;
      this->part_link_ = x.part_link_;
      this->part_name_ = x.part_name_;
      this->part_name_display_ = x.part_name_display_;
      this->part_abbreviation_ = x.part_abbreviation_;
      this->part_abbreviation_display_ = x.part_abbreviation_display_;
      this->group_ = x.group_;
      this->score_instrument_ = x.score_instrument_;
      this->player_ = x.player_;
      this->midi_device_ = x.midi_device_;
      this->midi_instrument_ = x.midi_instrument_;
      this->id_ = x.id_;
    }

    return *this;
  }

  score_part::
  ~score_part ()
  {
  }

  // virtual_instrument
  //

  virtual_instrument::
  virtual_instrument ()
  : ::xml_schema::type (),
    virtual_library_ (this),
    virtual_name_ (this)
  {
  }

  virtual_instrument::
  virtual_instrument (const virtual_instrument& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    virtual_library_ (x.virtual_library_, f, this),
    virtual_name_ (x.virtual_name_, f, this)
  {
  }

  virtual_instrument::
  virtual_instrument (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    virtual_library_ (this),
    virtual_name_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void virtual_instrument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // virtual-library
      //
      if (n.name () == "virtual-library" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< virtual_library_type > r (
          virtual_library_traits::create (i, f, this));

        if (!this->virtual_library_)
        {
          this->virtual_library_.set (::std::move (r));
          continue;
        }
      }

      // virtual-name
      //
      if (n.name () == "virtual-name" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< virtual_name_type > r (
          virtual_name_traits::create (i, f, this));

        if (!this->virtual_name_)
        {
          this->virtual_name_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  virtual_instrument* virtual_instrument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class virtual_instrument (*this, f, c);
  }

  virtual_instrument& virtual_instrument::
  operator= (const virtual_instrument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->virtual_library_ = x.virtual_library_;
      this->virtual_name_ = x.virtual_name_;
    }

    return *this;
  }

  virtual_instrument::
  ~virtual_instrument ()
  {
  }

  // work
  //

  work::
  work ()
  : ::xml_schema::type (),
    work_number_ (this),
    work_title_ (this),
    opus_ (this)
  {
  }

  work::
  work (const work& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    work_number_ (x.work_number_, f, this),
    work_title_ (x.work_title_, f, this),
    opus_ (x.opus_, f, this)
  {
  }

  work::
  work (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    work_number_ (this),
    work_title_ (this),
    opus_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void work::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // work-number
      //
      if (n.name () == "work-number" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< work_number_type > r (
          work_number_traits::create (i, f, this));

        if (!this->work_number_)
        {
          this->work_number_.set (::std::move (r));
          continue;
        }
      }

      // work-title
      //
      if (n.name () == "work-title" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< work_title_type > r (
          work_title_traits::create (i, f, this));

        if (!this->work_title_)
        {
          this->work_title_.set (::std::move (r));
          continue;
        }
      }

      // opus
      //
      if (n.name () == "opus" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< opus_type > r (
          opus_traits::create (i, f, this));

        if (!this->opus_)
        {
          this->opus_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  work* work::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class work (*this, f, c);
  }

  work& work::
  operator= (const work& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->work_number_ = x.work_number_;
      this->work_title_ = x.work_title_;
      this->opus_ = x.opus_;
    }

    return *this;
  }

  work::
  ~work ()
  {
  }

  // number_or_normal_member
  //

  number_or_normal_member::
  number_or_normal_member (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_number_or_normal_member_convert ();
  }

  number_or_normal_member::
  number_or_normal_member (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_number_or_normal_member_convert ();
  }

  number_or_normal_member::
  number_or_normal_member (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_number_or_normal_member_convert ();
  }

  number_or_normal_member* number_or_normal_member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class number_or_normal_member (*this, f, c);
  }

  number_or_normal_member::value number_or_normal_member::
  _xsd_number_or_normal_member_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_number_or_normal_member_literals_);
    const value* i (::std::lower_bound (
                      _xsd_number_or_normal_member_indexes_,
                      _xsd_number_or_normal_member_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_number_or_normal_member_indexes_ + 1 || _xsd_number_or_normal_member_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const number_or_normal_member::
  _xsd_number_or_normal_member_literals_[1] =
  {
    "normal"
  };

  const number_or_normal_member::value number_or_normal_member::
  _xsd_number_or_normal_member_indexes_[1] =
  {
    ::musicxml::number_or_normal_member::normal
  };

  // positive_integer_or_empty_member
  //

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_positive_integer_or_empty_member_convert ();
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_positive_integer_or_empty_member_convert ();
  }

  positive_integer_or_empty_member::
  positive_integer_or_empty_member (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_positive_integer_or_empty_member_convert ();
  }

  positive_integer_or_empty_member* positive_integer_or_empty_member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class positive_integer_or_empty_member (*this, f, c);
  }

  positive_integer_or_empty_member::value positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_positive_integer_or_empty_member_literals_);
    const value* i (::std::lower_bound (
                      _xsd_positive_integer_or_empty_member_indexes_,
                      _xsd_positive_integer_or_empty_member_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_positive_integer_or_empty_member_indexes_ + 1 || _xsd_positive_integer_or_empty_member_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_literals_[1] =
  {
    ""
  };

  const positive_integer_or_empty_member::value positive_integer_or_empty_member::
  _xsd_positive_integer_or_empty_member_indexes_[1] =
  {
    ::musicxml::positive_integer_or_empty_member::empty
  };

  // directive
  //

  directive::
  directive ()
  : ::xml_schema::string (),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    lang_ (this)
  {
  }

  directive::
  directive (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    lang_ (this)
  {
  }

  directive::
  directive (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    lang_ (this)
  {
  }

  directive::
  directive (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    lang_ (this)
  {
  }

  directive::
  directive (const directive& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c),
    default_x_ (x.default_x_, f, this),
    default_y_ (x.default_y_, f, this),
    relative_x_ (x.relative_x_, f, this),
    relative_y_ (x.relative_y_, f, this),
    font_family_ (x.font_family_, f, this),
    font_style_ (x.font_style_, f, this),
    font_size_ (x.font_size_, f, this),
    font_weight_ (x.font_weight_, f, this),
    color_ (x.color_, f, this),
    lang_ (x.lang_, f, this)
  {
  }

  directive::
  directive (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
    default_x_ (this),
    default_y_ (this),
    relative_x_ (this),
    relative_y_ (this),
    font_family_ (this),
    font_style_ (this),
    font_size_ (this),
    font_weight_ (this),
    color_ (this),
    lang_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void directive::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "default-x" && n.namespace_ ().empty ())
      {
        this->default_x_.set (default_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "default-y" && n.namespace_ ().empty ())
      {
        this->default_y_.set (default_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-x" && n.namespace_ ().empty ())
      {
        this->relative_x_.set (relative_x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "relative-y" && n.namespace_ ().empty ())
      {
        this->relative_y_.set (relative_y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-family" && n.namespace_ ().empty ())
      {
        this->font_family_.set (font_family_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-style" && n.namespace_ ().empty ())
      {
        this->font_style_.set (font_style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-size" && n.namespace_ ().empty ())
      {
        this->font_size_.set (font_size_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "font-weight" && n.namespace_ ().empty ())
      {
        this->font_weight_.set (font_weight_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "color" && n.namespace_ ().empty ())
      {
        this->color_.set (color_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lang" && n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        this->lang_.set (lang_traits::create (i, f, this));
        continue;
      }
    }
  }

  directive* directive::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class directive (*this, f, c);
  }

  directive& directive::
  operator= (const directive& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::string& > (*this) = x;
      this->default_x_ = x.default_x_;
      this->default_y_ = x.default_y_;
      this->relative_x_ = x.relative_x_;
      this->relative_y_ = x.relative_y_;
      this->font_family_ = x.font_family_;
      this->font_style_ = x.font_style_;
      this->font_size_ = x.font_size_;
      this->font_weight_ = x.font_weight_;
      this->color_ = x.color_;
      this->lang_ = x.lang_;
    }

    return *this;
  }

  directive::
  ~directive ()
  {
  }

  // score_partwise
  //

  const score_partwise::version_type score_partwise::version_default_value_ (
    "1.0");

  score_partwise::
  score_partwise (const part_list_type& part_list)
  : ::xml_schema::type (),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (part_list, this),
    part_ (this),
    version_ (version_default_value (), this)
  {
  }

  score_partwise::
  score_partwise (::std::unique_ptr< part_list_type > part_list)
  : ::xml_schema::type (),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (std::move (part_list), this),
    part_ (this),
    version_ (version_default_value (), this)
  {
  }

  score_partwise::
  score_partwise (const score_partwise& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    work_ (x.work_, f, this),
    movement_number_ (x.movement_number_, f, this),
    movement_title_ (x.movement_title_, f, this),
    identification_ (x.identification_, f, this),
    defaults_ (x.defaults_, f, this),
    credit_ (x.credit_, f, this),
    part_list_ (x.part_list_, f, this),
    part_ (x.part_, f, this),
    version_ (x.version_, f, this)
  {
  }

  score_partwise::
  score_partwise (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (this),
    part_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void score_partwise::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // work
      //
      if (n.name () == "work" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< work_type > r (
          work_traits::create (i, f, this));

        if (!this->work_)
        {
          this->work_.set (::std::move (r));
          continue;
        }
      }

      // movement-number
      //
      if (n.name () == "movement-number" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< movement_number_type > r (
          movement_number_traits::create (i, f, this));

        if (!this->movement_number_)
        {
          this->movement_number_.set (::std::move (r));
          continue;
        }
      }

      // movement-title
      //
      if (n.name () == "movement-title" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< movement_title_type > r (
          movement_title_traits::create (i, f, this));

        if (!this->movement_title_)
        {
          this->movement_title_.set (::std::move (r));
          continue;
        }
      }

      // identification
      //
      if (n.name () == "identification" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< identification_type > r (
          identification_traits::create (i, f, this));

        if (!this->identification_)
        {
          this->identification_.set (::std::move (r));
          continue;
        }
      }

      // defaults
      //
      if (n.name () == "defaults" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< defaults_type > r (
          defaults_traits::create (i, f, this));

        if (!this->defaults_)
        {
          this->defaults_.set (::std::move (r));
          continue;
        }
      }

      // credit
      //
      if (n.name () == "credit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_type > r (
          credit_traits::create (i, f, this));

        this->credit_.push_back (::std::move (r));
        continue;
      }

      // part-list
      //
      if (n.name () == "part-list" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_list_type > r (
          part_list_traits::create (i, f, this));

        if (!part_list_.present ())
        {
          this->part_list_.set (::std::move (r));
          continue;
        }
      }

      // part
      //
      if (n.name () == "part" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_type > r (
          part_traits::create (i, f, this));

        this->part_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!part_list_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "part-list",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  score_partwise* score_partwise::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class score_partwise (*this, f, c);
  }

  score_partwise& score_partwise::
  operator= (const score_partwise& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->work_ = x.work_;
      this->movement_number_ = x.movement_number_;
      this->movement_title_ = x.movement_title_;
      this->identification_ = x.identification_;
      this->defaults_ = x.defaults_;
      this->credit_ = x.credit_;
      this->part_list_ = x.part_list_;
      this->part_ = x.part_;
      this->version_ = x.version_;
    }

    return *this;
  }

  score_partwise::
  ~score_partwise ()
  {
  }

  // score_timewise
  //

  const score_timewise::version_type score_timewise::version_default_value_ (
    "1.0");

  score_timewise::
  score_timewise (const part_list_type& part_list)
  : ::xml_schema::type (),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (part_list, this),
    measure_ (this),
    version_ (version_default_value (), this)
  {
  }

  score_timewise::
  score_timewise (::std::unique_ptr< part_list_type > part_list)
  : ::xml_schema::type (),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (std::move (part_list), this),
    measure_ (this),
    version_ (version_default_value (), this)
  {
  }

  score_timewise::
  score_timewise (const score_timewise& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    work_ (x.work_, f, this),
    movement_number_ (x.movement_number_, f, this),
    movement_title_ (x.movement_title_, f, this),
    identification_ (x.identification_, f, this),
    defaults_ (x.defaults_, f, this),
    credit_ (x.credit_, f, this),
    part_list_ (x.part_list_, f, this),
    measure_ (x.measure_, f, this),
    version_ (x.version_, f, this)
  {
  }

  score_timewise::
  score_timewise (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    work_ (this),
    movement_number_ (this),
    movement_title_ (this),
    identification_ (this),
    defaults_ (this),
    credit_ (this),
    part_list_ (this),
    measure_ (this),
    version_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void score_timewise::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // work
      //
      if (n.name () == "work" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< work_type > r (
          work_traits::create (i, f, this));

        if (!this->work_)
        {
          this->work_.set (::std::move (r));
          continue;
        }
      }

      // movement-number
      //
      if (n.name () == "movement-number" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< movement_number_type > r (
          movement_number_traits::create (i, f, this));

        if (!this->movement_number_)
        {
          this->movement_number_.set (::std::move (r));
          continue;
        }
      }

      // movement-title
      //
      if (n.name () == "movement-title" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< movement_title_type > r (
          movement_title_traits::create (i, f, this));

        if (!this->movement_title_)
        {
          this->movement_title_.set (::std::move (r));
          continue;
        }
      }

      // identification
      //
      if (n.name () == "identification" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< identification_type > r (
          identification_traits::create (i, f, this));

        if (!this->identification_)
        {
          this->identification_.set (::std::move (r));
          continue;
        }
      }

      // defaults
      //
      if (n.name () == "defaults" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< defaults_type > r (
          defaults_traits::create (i, f, this));

        if (!this->defaults_)
        {
          this->defaults_.set (::std::move (r));
          continue;
        }
      }

      // credit
      //
      if (n.name () == "credit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< credit_type > r (
          credit_traits::create (i, f, this));

        this->credit_.push_back (::std::move (r));
        continue;
      }

      // part-list
      //
      if (n.name () == "part-list" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_list_type > r (
          part_list_traits::create (i, f, this));

        if (!part_list_.present ())
        {
          this->part_list_.set (::std::move (r));
          continue;
        }
      }

      // measure
      //
      if (n.name () == "measure" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_type > r (
          measure_traits::create (i, f, this));

        this->measure_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!part_list_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "part-list",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        this->version_.set (version_traits::create (i, f, this));
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  score_timewise* score_timewise::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class score_timewise (*this, f, c);
  }

  score_timewise& score_timewise::
  operator= (const score_timewise& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->work_ = x.work_;
      this->movement_number_ = x.movement_number_;
      this->movement_title_ = x.movement_title_;
      this->identification_ = x.identification_;
      this->defaults_ = x.defaults_;
      this->credit_ = x.credit_;
      this->part_list_ = x.part_list_;
      this->measure_ = x.measure_;
      this->version_ = x.version_;
    }

    return *this;
  }

  score_timewise::
  ~score_timewise ()
  {
  }

  // part
  //

  part::
  part (const id_type& id)
  : ::xml_schema::type (),
    measure_ (this),
    id_ (id, this)
  {
  }

  part::
  part (const part& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    measure_ (x.measure_, f, this),
    id_ (x.id_, f, this)
  {
  }

  part::
  part (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    measure_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void part::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // measure
      //
      if (n.name () == "measure" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< measure_type > r (
          measure_traits::create (i, f, this));

        this->measure_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  part* part::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part (*this, f, c);
  }

  part& part::
  operator= (const part& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->measure_ = x.measure_;
      this->id_ = x.id_;
    }

    return *this;
  }

  part::
  ~part ()
  {
  }

  // measure
  //

  measure::
  measure (const number_type& number)
  : ::xml_schema::type (),
    part_ (this),
    number_ (number, this),
    text_ (this),
    implicit_ (this),
    non_controlling_ (this),
    width_ (this),
    id_ (this)
  {
  }

  measure::
  measure (const measure& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    part_ (x.part_, f, this),
    number_ (x.number_, f, this),
    text_ (x.text_, f, this),
    implicit_ (x.implicit_, f, this),
    non_controlling_ (x.non_controlling_, f, this),
    width_ (x.width_, f, this),
    id_ (x.id_, f, this)
  {
  }

  measure::
  measure (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    part_ (this),
    number_ (this),
    text_ (this),
    implicit_ (this),
    non_controlling_ (this),
    width_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void measure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // part
      //
      if (n.name () == "part" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< part_type > r (
          part_traits::create (i, f, this));

        this->part_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "implicit" && n.namespace_ ().empty ())
      {
        this->implicit_.set (implicit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "non-controlling" && n.namespace_ ().empty ())
      {
        this->non_controlling_.set (non_controlling_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  measure* measure::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure (*this, f, c);
  }

  measure& measure::
  operator= (const measure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->part_ = x.part_;
      this->number_ = x.number_;
      this->text_ = x.text_;
      this->implicit_ = x.implicit_;
      this->non_controlling_ = x.non_controlling_;
      this->width_ = x.width_;
      this->id_ = x.id_;
    }

    return *this;
  }

  measure::
  ~measure ()
  {
  }

  // measure1
  //

  measure1::
  measure1 (const number_type& number)
  : ::xml_schema::type (),
    note_ (this),
    backup_ (this),
    forward_ (this),
    direction_ (this),
    attributes_ (this),
    harmony_ (this),
    figured_bass_ (this),
    print_ (this),
    sound_ (this),
    listening_ (this),
    barline_ (this),
    grouping_ (this),
    link_ (this),
    bookmark_ (this),
    number_ (number, this),
    text_ (this),
    implicit_ (this),
    non_controlling_ (this),
    width_ (this),
    id_ (this)
  {
  }

  measure1::
  measure1 (const measure1& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    content_order_ (x.content_order_),
    note_ (x.note_, f, this),
    backup_ (x.backup_, f, this),
    forward_ (x.forward_, f, this),
    direction_ (x.direction_, f, this),
    attributes_ (x.attributes_, f, this),
    harmony_ (x.harmony_, f, this),
    figured_bass_ (x.figured_bass_, f, this),
    print_ (x.print_, f, this),
    sound_ (x.sound_, f, this),
    listening_ (x.listening_, f, this),
    barline_ (x.barline_, f, this),
    grouping_ (x.grouping_, f, this),
    link_ (x.link_, f, this),
    bookmark_ (x.bookmark_, f, this),
    number_ (x.number_, f, this),
    text_ (x.text_, f, this),
    implicit_ (x.implicit_, f, this),
    non_controlling_ (x.non_controlling_, f, this),
    width_ (x.width_, f, this),
    id_ (x.id_, f, this)
  {
  }

  measure1::
  measure1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    note_ (this),
    backup_ (this),
    forward_ (this),
    direction_ (this),
    attributes_ (this),
    harmony_ (this),
    figured_bass_ (this),
    print_ (this),
    sound_ (this),
    listening_ (this),
    barline_ (this),
    grouping_ (this),
    link_ (this),
    bookmark_ (this),
    number_ (this),
    text_ (this),
    implicit_ (this),
    non_controlling_ (this),
    width_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void measure1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // note
      //
      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (note_id, this->note_.size () - 1));
        continue;
      }

      // backup
      //
      if (n.name () == "backup" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< backup_type > r (
          backup_traits::create (i, f, this));

        this->backup_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (backup_id, this->backup_.size () - 1));
        continue;
      }

      // forward
      //
      if (n.name () == "forward" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< forward_type > r (
          forward_traits::create (i, f, this));

        this->forward_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (forward_id, this->forward_.size () - 1));
        continue;
      }

      // direction
      //
      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< direction_type > r (
          direction_traits::create (i, f, this));

        this->direction_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (direction_id, this->direction_.size () - 1));
        continue;
      }

      // attributes
      //
      if (n.name () == "attributes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< attributes_type > r (
          attributes_traits::create (i, f, this));

        this->attributes_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (attributes_id, this->attributes_.size () - 1));
        continue;
      }

      // harmony
      //
      if (n.name () == "harmony" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harmony_type > r (
          harmony_traits::create (i, f, this));

        this->harmony_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (harmony_id, this->harmony_.size () - 1));
        continue;
      }

      // figured-bass
      //
      if (n.name () == "figured-bass" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< figured_bass_type > r (
          figured_bass_traits::create (i, f, this));

        this->figured_bass_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (figured_bass_id, this->figured_bass_.size () - 1));
        continue;
      }

      // print
      //
      if (n.name () == "print" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< print_type > r (
          print_traits::create (i, f, this));

        this->print_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (print_id, this->print_.size () - 1));
        continue;
      }

      // sound
      //
      if (n.name () == "sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sound_type > r (
          sound_traits::create (i, f, this));

        this->sound_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (sound_id, this->sound_.size () - 1));
        continue;
      }

      // listening
      //
      if (n.name () == "listening" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< listening_type > r (
          listening_traits::create (i, f, this));

        this->listening_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (listening_id, this->listening_.size () - 1));
        continue;
      }

      // barline
      //
      if (n.name () == "barline" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< barline_type > r (
          barline_traits::create (i, f, this));

        this->barline_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (barline_id, this->barline_.size () - 1));
        continue;
      }

      // grouping
      //
      if (n.name () == "grouping" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< grouping_type > r (
          grouping_traits::create (i, f, this));

        this->grouping_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (grouping_id, this->grouping_.size () - 1));
        continue;
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< link_type > r (
          link_traits::create (i, f, this));

        this->link_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (link_id, this->link_.size () - 1));
        continue;
      }

      // bookmark
      //
      if (n.name () == "bookmark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bookmark_type > r (
          bookmark_traits::create (i, f, this));

        this->bookmark_.push_back (::std::move (r));
        this->content_order_.push_back (
          content_order_type (bookmark_id, this->bookmark_.size () - 1));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (number_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "text" && n.namespace_ ().empty ())
      {
        this->text_.set (text_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "implicit" && n.namespace_ ().empty ())
      {
        this->implicit_.set (implicit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "non-controlling" && n.namespace_ ().empty ())
      {
        this->non_controlling_.set (non_controlling_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        this->width_.set (width_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  measure1* measure1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measure1 (*this, f, c);
  }

  measure1& measure1::
  operator= (const measure1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->content_order_ = x.content_order_;
      this->note_ = x.note_;
      this->backup_ = x.backup_;
      this->forward_ = x.forward_;
      this->direction_ = x.direction_;
      this->attributes_ = x.attributes_;
      this->harmony_ = x.harmony_;
      this->figured_bass_ = x.figured_bass_;
      this->print_ = x.print_;
      this->sound_ = x.sound_;
      this->listening_ = x.listening_;
      this->barline_ = x.barline_;
      this->grouping_ = x.grouping_;
      this->link_ = x.link_;
      this->bookmark_ = x.bookmark_;
      this->number_ = x.number_;
      this->text_ = x.text_;
      this->implicit_ = x.implicit_;
      this->non_controlling_ = x.non_controlling_;
      this->width_ = x.width_;
      this->id_ = x.id_;
    }

    return *this;
  }

  measure1::
  ~measure1 ()
  {
  }

  // part1
  //

  part1::
  part1 (const id_type& id)
  : ::xml_schema::type (),
    note_ (this),
    backup_ (this),
    forward_ (this),
    direction_ (this),
    attributes_ (this),
    harmony_ (this),
    figured_bass_ (this),
    print_ (this),
    sound_ (this),
    listening_ (this),
    barline_ (this),
    grouping_ (this),
    link_ (this),
    bookmark_ (this),
    id_ (id, this)
  {
  }

  part1::
  part1 (const part1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    note_ (x.note_, f, this),
    backup_ (x.backup_, f, this),
    forward_ (x.forward_, f, this),
    direction_ (x.direction_, f, this),
    attributes_ (x.attributes_, f, this),
    harmony_ (x.harmony_, f, this),
    figured_bass_ (x.figured_bass_, f, this),
    print_ (x.print_, f, this),
    sound_ (x.sound_, f, this),
    listening_ (x.listening_, f, this),
    barline_ (x.barline_, f, this),
    grouping_ (x.grouping_, f, this),
    link_ (x.link_, f, this),
    bookmark_ (x.bookmark_, f, this),
    id_ (x.id_, f, this)
  {
  }

  part1::
  part1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    note_ (this),
    backup_ (this),
    forward_ (this),
    direction_ (this),
    attributes_ (this),
    harmony_ (this),
    figured_bass_ (this),
    print_ (this),
    sound_ (this),
    listening_ (this),
    barline_ (this),
    grouping_ (this),
    link_ (this),
    bookmark_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void part1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // note
      //
      if (n.name () == "note" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< note_type > r (
          note_traits::create (i, f, this));

        this->note_.push_back (::std::move (r));
        continue;
      }

      // backup
      //
      if (n.name () == "backup" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< backup_type > r (
          backup_traits::create (i, f, this));

        this->backup_.push_back (::std::move (r));
        continue;
      }

      // forward
      //
      if (n.name () == "forward" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< forward_type > r (
          forward_traits::create (i, f, this));

        this->forward_.push_back (::std::move (r));
        continue;
      }

      // direction
      //
      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< direction_type > r (
          direction_traits::create (i, f, this));

        this->direction_.push_back (::std::move (r));
        continue;
      }

      // attributes
      //
      if (n.name () == "attributes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< attributes_type > r (
          attributes_traits::create (i, f, this));

        this->attributes_.push_back (::std::move (r));
        continue;
      }

      // harmony
      //
      if (n.name () == "harmony" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< harmony_type > r (
          harmony_traits::create (i, f, this));

        this->harmony_.push_back (::std::move (r));
        continue;
      }

      // figured-bass
      //
      if (n.name () == "figured-bass" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< figured_bass_type > r (
          figured_bass_traits::create (i, f, this));

        this->figured_bass_.push_back (::std::move (r));
        continue;
      }

      // print
      //
      if (n.name () == "print" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< print_type > r (
          print_traits::create (i, f, this));

        this->print_.push_back (::std::move (r));
        continue;
      }

      // sound
      //
      if (n.name () == "sound" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< sound_type > r (
          sound_traits::create (i, f, this));

        this->sound_.push_back (::std::move (r));
        continue;
      }

      // listening
      //
      if (n.name () == "listening" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< listening_type > r (
          listening_traits::create (i, f, this));

        this->listening_.push_back (::std::move (r));
        continue;
      }

      // barline
      //
      if (n.name () == "barline" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< barline_type > r (
          barline_traits::create (i, f, this));

        this->barline_.push_back (::std::move (r));
        continue;
      }

      // grouping
      //
      if (n.name () == "grouping" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< grouping_type > r (
          grouping_traits::create (i, f, this));

        this->grouping_.push_back (::std::move (r));
        continue;
      }

      // link
      //
      if (n.name () == "link" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< link_type > r (
          link_traits::create (i, f, this));

        this->link_.push_back (::std::move (r));
        continue;
      }

      // bookmark
      //
      if (n.name () == "bookmark" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< bookmark_type > r (
          bookmark_traits::create (i, f, this));

        this->bookmark_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  part1* part1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class part1 (*this, f, c);
  }

  part1& part1::
  operator= (const part1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->note_ = x.note_;
      this->backup_ = x.backup_;
      this->forward_ = x.forward_;
      this->direction_ = x.direction_;
      this->attributes_ = x.attributes_;
      this->harmony_ = x.harmony_;
      this->figured_bass_ = x.figured_bass_;
      this->print_ = x.print_;
      this->sound_ = x.sound_;
      this->listening_ = x.listening_;
      this->barline_ = x.barline_;
      this->grouping_ = x.grouping_;
      this->link_ = x.link_;
      this->bookmark_ = x.bookmark_;
      this->id_ = x.id_;
    }

    return *this;
  }

  part1::
  ~part1 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace musicxml
{
  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_partwise_ (isrc, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_partwise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_partwise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_partwise_ (isrc, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_partwise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_partwise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_partwise > (
      ::musicxml::score_partwise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::musicxml::score_partwise > (
        ::musicxml::score_partwise_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "score-partwise" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::musicxml::score_partwise > r (
        ::xsd::cxx::tree::traits< ::musicxml::score_partwise, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "score-partwise",
      "");
  }

  ::std::unique_ptr< ::musicxml::score_partwise >
  score_partwise_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "score-partwise" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::musicxml::score_partwise > r (
        ::xsd::cxx::tree::traits< ::musicxml::score_partwise, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "score-partwise",
      "");
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_timewise_ (isrc, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_timewise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::musicxml::score_timewise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_timewise_ (isrc, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_timewise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::musicxml::score_timewise_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::musicxml::score_timewise > (
      ::musicxml::score_timewise_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::musicxml::score_timewise > (
        ::musicxml::score_timewise_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "score-timewise" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::musicxml::score_timewise > r (
        ::xsd::cxx::tree::traits< ::musicxml::score_timewise, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "score-timewise",
      "");
  }

  ::std::unique_ptr< ::musicxml::score_timewise >
  score_timewise_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "score-timewise" &&
        n.namespace_ () == "")
    {
      ::std::unique_ptr< ::musicxml::score_timewise > r (
        ::xsd::cxx::tree::traits< ::musicxml::score_timewise, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "score-timewise",
      "");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

